// // Package medusa provides primitives to interact with the openapi HTTP API.
// //
// // Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package medusa

// import (
// 	"bytes"
// 	"compress/gzip"
// 	"encoding/base64"
// 	"fmt"
// 	"net/http"
// 	"net/url"
// 	"path"
// 	"strings"
// 	"time"

// 	"github.com/deepmap/oapi-codegen/pkg/runtime"
// 	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
// 	"github.com/getkin/kin-openapi/openapi3"
// 	"github.com/labstack/echo/v4"
// )

// const (
// 	Cookie_authScopes = "cookie_auth.Scopes"
// )

// // Defines values for CartType.
// const (
// 	CartTypeClaim       CartType = "claim"
// 	CartTypeDefault     CartType = "default"
// 	CartTypeDraftOrder  CartType = "draft_order"
// 	CartTypePaymentLink CartType = "payment_link"
// 	CartTypeSwap        CartType = "swap"
// )

// // Defines values for DiscountRuleAllocation.
// const (
// 	Item  DiscountRuleAllocation = "item"
// 	Total DiscountRuleAllocation = "total"
// )

// // Defines values for DiscountRuleType.
// const (
// 	Fixed        DiscountRuleType = "fixed"
// 	FreeShipping DiscountRuleType = "free_shipping"
// 	Percentage   DiscountRuleType = "percentage"
// )

// // Defines values for OrderFulfillmentStatus.
// const (
// 	OrderFulfillmentStatusCanceled           OrderFulfillmentStatus = "canceled"
// 	OrderFulfillmentStatusFulfilled          OrderFulfillmentStatus = "fulfilled"
// 	OrderFulfillmentStatusNotFulfilled       OrderFulfillmentStatus = "not_fulfilled"
// 	OrderFulfillmentStatusPartiallyFulfilled OrderFulfillmentStatus = "partially_fulfilled"
// 	OrderFulfillmentStatusPartiallyReturned  OrderFulfillmentStatus = "partially_returned"
// 	OrderFulfillmentStatusPartiallyShipped   OrderFulfillmentStatus = "partially_shipped"
// 	OrderFulfillmentStatusRequiresAction     OrderFulfillmentStatus = "requires_action"
// 	OrderFulfillmentStatusReturned           OrderFulfillmentStatus = "returned"
// 	OrderFulfillmentStatusShipped            OrderFulfillmentStatus = "shipped"
// )

// // Defines values for OrderPaymentStatus.
// const (
// 	OrderPaymentStatusAwaiting          OrderPaymentStatus = "awaiting"
// 	OrderPaymentStatusCanceled          OrderPaymentStatus = "canceled"
// 	OrderPaymentStatusCaptured          OrderPaymentStatus = "captured"
// 	OrderPaymentStatusNotPaid           OrderPaymentStatus = "not_paid"
// 	OrderPaymentStatusPartiallyRefunded OrderPaymentStatus = "partially_refunded"
// 	OrderPaymentStatusRefuneded         OrderPaymentStatus = "refuneded"
// 	OrderPaymentStatusRequiresAction    OrderPaymentStatus = "requires_action"
// )

// // Defines values for OrderStatus.
// const (
// 	OrderStatusArchived       OrderStatus = "archived"
// 	OrderStatusCanceled       OrderStatus = "canceled"
// 	OrderStatusCompleted      OrderStatus = "completed"
// 	OrderStatusPending        OrderStatus = "pending"
// 	OrderStatusRequiresAction OrderStatus = "requires_action"
// )

// // Defines values for OrderItemChangeType.
// const (
// 	ItemAdd    OrderItemChangeType = "item_add"
// 	ItemRemove OrderItemChangeType = "item_remove"
// 	ItemUpdate OrderItemChangeType = "item_update"
// )

// // Defines values for PaymentSessionStatus.
// const (
// 	PaymentSessionStatusAuthorized   PaymentSessionStatus = "authorized"
// 	PaymentSessionStatusCanceled     PaymentSessionStatus = "canceled"
// 	PaymentSessionStatusError        PaymentSessionStatus = "error"
// 	PaymentSessionStatusPending      PaymentSessionStatus = "pending"
// 	PaymentSessionStatusRequiresMore PaymentSessionStatus = "requires_more"
// )

// // Defines values for PriceListStatus.
// const (
// 	PriceListStatusActive PriceListStatus = "active"
// 	PriceListStatusDraft  PriceListStatus = "draft"
// )

// // Defines values for PriceListType.
// const (
// 	Override PriceListType = "override"
// 	Sale     PriceListType = "sale"
// )

// // Defines values for ProductStatus.
// const (
// 	ProductStatusDraft     ProductStatus = "draft"
// 	ProductStatusProposed  ProductStatus = "proposed"
// 	ProductStatusPublished ProductStatus = "published"
// 	ProductStatusRejected  ProductStatus = "rejected"
// )

// // Defines values for ReturnStatus.
// const (
// 	ReturnStatusCanceled       ReturnStatus = "canceled"
// 	ReturnStatusReceived       ReturnStatus = "received"
// 	ReturnStatusRequested      ReturnStatus = "requested"
// 	ReturnStatusRequiresAction ReturnStatus = "requires_action"
// )

// // Defines values for ShippingOptionPriceType.
// const (
// 	Calculated ShippingOptionPriceType = "calculated"
// 	FlatRate   ShippingOptionPriceType = "flat_rate"
// )

// // Defines values for ShippingOptionRequirementType.
// const (
// 	MaxSubtotal ShippingOptionRequirementType = "max_subtotal"
// 	MinSubtotal ShippingOptionRequirementType = "min_subtotal"
// )

// // Defines values for ShippingProfileType.
// const (
// 	ShippingProfileTypeCustom   ShippingProfileType = "custom"
// 	ShippingProfileTypeDefault  ShippingProfileType = "default"
// 	ShippingProfileTypeGiftCard ShippingProfileType = "gift_card"
// )

// // Defines values for SwapFulfillmentStatus.
// const (
// 	SwapFulfillmentStatusCanceled       SwapFulfillmentStatus = "canceled"
// 	SwapFulfillmentStatusFulfilled      SwapFulfillmentStatus = "fulfilled"
// 	SwapFulfillmentStatusNotFulfilled   SwapFulfillmentStatus = "not_fulfilled"
// 	SwapFulfillmentStatusRequiresAction SwapFulfillmentStatus = "requires_action"
// 	SwapFulfillmentStatusShipped        SwapFulfillmentStatus = "shipped"
// )

// // Defines values for SwapPaymentStatus.
// const (
// 	Awaiting           SwapPaymentStatus = "awaiting"
// 	Canceled           SwapPaymentStatus = "canceled"
// 	Captured           SwapPaymentStatus = "captured"
// 	Confirmed          SwapPaymentStatus = "confirmed"
// 	DifferenceRefunded SwapPaymentStatus = "difference_refunded"
// 	NotPaid            SwapPaymentStatus = "not_paid"
// 	PartiallyRefunded  SwapPaymentStatus = "partially_refunded"
// 	Refunded           SwapPaymentStatus = "refunded"
// 	RequiresAction     SwapPaymentStatus = "requires_action"
// )

// // An address.
// type Address struct {
// 	// Address line 1
// 	Address1 *string `json:"address_1,omitempty"`

// 	// Address line 2
// 	Address2 *string `json:"address_2,omitempty"`

// 	// City
// 	City *string `json:"city,omitempty"`

// 	// Company name
// 	Company *string `json:"company,omitempty"`

// 	// A country object. Available if the relation `country` is expanded.
// 	Country *map[string]interface{} `json:"country,omitempty"`

// 	// The 2 character ISO code of the country in lower case
// 	CountryCode *string `json:"country_code,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// Available if the relation `customer` is expanded.
// 	Customer *[]map[string]interface{} `json:"customer,omitempty"`

// 	// ID of the customer this address belongs to
// 	CustomerId *string `json:"customer_id,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// First name
// 	FirstName *string `json:"first_name,omitempty"`

// 	// ID of the address
// 	Id *string `json:"id,omitempty"`

// 	// Last name
// 	LastName *string `json:"last_name,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Phone Number
// 	Phone *string `json:"phone,omitempty"`

// 	// Postal Code
// 	PostalCode *string `json:"postal_code,omitempty"`

// 	// Province
// 	Province *string `json:"province,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents a user cart
// type Cart struct {
// 	// An address.
// 	BillingAddress *Address `json:"billing_address,omitempty"`

// 	// The billing address's ID
// 	BillingAddressId *string `json:"billing_address_id,omitempty"`

// 	// The date with timezone at which the cart was completed.
// 	CompletedAt *time.Time `json:"completed_at,omitempty"`

// 	// The context of the cart which can include info like IP or user agent.
// 	Context *map[string]interface{} `json:"context,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// A customer object. Available if the relation `customer` is expanded.
// 	Customer *map[string]interface{} `json:"customer,omitempty"`

// 	// The customer's ID
// 	CustomerId *string `json:"customer_id,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The total of discount
// 	DiscountTotal *int `json:"discount_total,omitempty"`

// 	// Available if the relation `discounts` is expanded.
// 	Discounts *[]map[string]interface{} `json:"discounts,omitempty"`

// 	// The email associated with the cart
// 	Email *openapi_types.Email `json:"email,omitempty"`

// 	// The total of gift cards with taxes
// 	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

// 	// The total of gift cards
// 	GiftCardTotal *int `json:"gift_card_total,omitempty"`

// 	// Available if the relation `gift_cards` is expanded.
// 	GiftCards *[]map[string]interface{} `json:"gift_cards,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of a cart in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// Available if the relation `items` is expanded.
// 	Items *[]LineItem `json:"items,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
// 	Payment *Payment `json:"payment,omitempty"`

// 	// The date with timezone at which the payment was authorized.
// 	PaymentAuthorizedAt *time.Time `json:"payment_authorized_at,omitempty"`

// 	// The payment's ID if available
// 	PaymentId *string `json:"payment_id,omitempty"`

// 	// Payment Sessions are created when a Customer initilizes the checkout flow, and can be used to hold the state of a payment flow. Each Payment Session is controlled by a Payment Provider, who is responsible for the communication with external payment services. Authorized Payment Sessions will eventually get promoted to Payments to indicate that they are authorized for capture/refunds/etc.
// 	PaymentSession *PaymentSession `json:"payment_session,omitempty"`

// 	// The payment sessions created on the cart.
// 	PaymentSessions *[]PaymentSession `json:"payment_sessions,omitempty"`

// 	// The amount that can be refunded
// 	RefundableAmount *int `json:"refundable_amount,omitempty"`

// 	// The total amount refunded if the order associated with this cart is returned.
// 	RefundedTotal *int `json:"refunded_total,omitempty"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The region's ID
// 	RegionId *string `json:"region_id,omitempty"`

// 	// A sales channel object. Available if the relation `sales_channel` is expanded.
// 	SalesChannel *map[string]interface{} `json:"sales_channel,omitempty"`

// 	// The sales channel ID the cart is associated with.
// 	SalesChannelId *string `json:"sales_channel_id,omitempty"`

// 	// An address.
// 	ShippingAddress *Address `json:"shipping_address,omitempty"`

// 	// The shipping address's ID
// 	ShippingAddressId *string `json:"shipping_address_id,omitempty"`

// 	// The shipping methods added to the cart.
// 	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

// 	// The total of shipping
// 	ShippingTotal *int `json:"shipping_total,omitempty"`

// 	// The subtotal of the cart
// 	Subtotal *int `json:"subtotal,omitempty"`

// 	// The total of tax
// 	TaxTotal *int `json:"tax_total,omitempty"`

// 	// The total amount of the cart
// 	Total *int `json:"total,omitempty"`

// 	// The cart's type.
// 	Type *CartType `json:"type,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // The cart's type.
// type CartType string

// // Country details
// type Country struct {
// 	// The country name appropriate for display.
// 	DisplayName string `json:"display_name"`

// 	// The country's ID
// 	Id *string `json:"id,omitempty"`

// 	// The 2 character ISO code of the country in lower case
// 	Iso2 string `json:"iso_2"`

// 	// The 2 character ISO code of the country in lower case
// 	Iso3 string `json:"iso_3"`

// 	// The normalized country name in upper case.
// 	Name string `json:"name"`

// 	// The numerical ISO code for the country.
// 	NumCode string `json:"num_code"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The region ID this country is associated with.
// 	RegionId *string `json:"region_id,omitempty"`
// }

// // Currency
// type Currency struct {
// 	// The 3 character ISO code for the currency.
// 	Code string `json:"code"`

// 	// [EXPERIMENTAL] Does the currency prices include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// The written name of the currency
// 	Name string `json:"name"`

// 	// The symbol used to indicate the currency.
// 	Symbol string `json:"symbol"`

// 	// The native symbol used to indicate the currency.
// 	SymbolNative string `json:"symbol_native"`
// }

// // Represents a customer
// type Customer struct {
// 	// An address.
// 	BillingAddress *Address `json:"billing_address,omitempty"`

// 	// The customer's billing address ID
// 	BillingAddressId *string `json:"billing_address_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The customer's email
// 	Email openapi_types.Email `json:"email"`

// 	// The customer's first name
// 	FirstName *string `json:"first_name,omitempty"`

// 	// The customer groups the customer belongs to. Available if the relation `groups` is expanded.
// 	Groups *[]CustomerGroup `json:"groups,omitempty"`

// 	// Whether the customer has an account or not
// 	HasAccount *bool `json:"has_account,omitempty"`

// 	// The customer's ID
// 	Id *string `json:"id,omitempty"`

// 	// The customer's first name
// 	LastName *string `json:"last_name,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Available if the relation `orders` is expanded.
// 	Orders *[]map[string]interface{} `json:"orders,omitempty"`

// 	// The customer's phone number
// 	Phone *string `json:"phone,omitempty"`

// 	// Available if the relation `shipping_addresses` is expanded.
// 	ShippingAddresses *[]Address `json:"shipping_addresses,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents a customer group
// type CustomerGroup struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The customers that belong to the customer group. Available if the relation `customers` is expanded.
// 	Customers *[]map[string]interface{} `json:"customers,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The customer group's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The name of the customer group
// 	Name string `json:"name"`

// 	// The price lists that are associated with the customer group. Available if the relation `price_lists` is expanded.
// 	PriceLists *[]PriceList `json:"price_lists,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents a discount that can be applied to a cart for promotional purposes.
// type Discount struct {
// 	// A unique code for the discount - this will be used by the customer to apply the discount
// 	Code string `json:"code"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The time at which the discount can no longer be used.
// 	EndsAt *time.Time `json:"ends_at,omitempty"`

// 	// The discount's ID
// 	Id *string `json:"id,omitempty"`

// 	// Whether the Discount has been disabled. Disabled discounts cannot be applied to carts
// 	IsDisabled *bool `json:"is_disabled,omitempty"`

// 	// A flag to indicate if multiple instances of the discount can be generated. I.e. for newsletter discounts
// 	IsDynamic bool `json:"is_dynamic"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Represents a discount that can be applied to a cart for promotional purposes.
// 	ParentDiscount *Discount `json:"parent_discount,omitempty"`

// 	// The Discount that the discount was created from. This will always be a dynamic discount
// 	ParentDiscountId *string `json:"parent_discount_id,omitempty"`

// 	// The Regions in which the Discount can be used. Available if the relation `regions` is expanded.
// 	Regions *[]map[string]interface{} `json:"regions,omitempty"`

// 	// Holds the rules that governs how a Discount is calculated when applied to a Cart.
// 	Rule *DiscountRule `json:"rule,omitempty"`

// 	// The Discount Rule that governs the behaviour of the Discount
// 	RuleId *string `json:"rule_id,omitempty"`

// 	// The time at which the discount can be used.
// 	StartsAt *time.Time `json:"starts_at,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The number of times a discount has been used.
// 	UsageCount *int `json:"usage_count,omitempty"`

// 	// The maximum number of times that a discount can be used.
// 	UsageLimit *int `json:"usage_limit,omitempty"`

// 	// Duration the discount runs between
// 	ValidDuration *string `json:"valid_duration,omitempty"`
// }

// // Holds the rules that governs how a Discount is calculated when applied to a Cart.
// type DiscountRule struct {
// 	// The scope that the discount should apply to.
// 	Allocation *DiscountRuleAllocation `json:"allocation,omitempty"`

// 	// A set of conditions that can be used to limit when  the discount can be used. Available if the relation `conditions` is expanded.
// 	Conditions *[]map[string]interface{} `json:"conditions,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// A short description of the discount
// 	Description *string `json:"description,omitempty"`

// 	// The discount rule's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
// 	Type DiscountRuleType `json:"type"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value that the discount represents; this will depend on the type of the discount
// 	Value int `json:"value"`
// }

// // The scope that the discount should apply to.
// type DiscountRuleAllocation string

// // The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
// type DiscountRuleType string

// // Error defines model for error.
// type Error struct {
// 	// A slug code to indicate the type of the error.
// 	Code *string `json:"code,omitempty"`

// 	// Description of the error that occurred.
// 	Message *string `json:"message,omitempty"`

// 	// A slug indicating the type of the error.
// 	Type *string `json:"type,omitempty"`
// }

// // Fulfillments are created once store operators can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a provider, which is typically an external shipping aggregator, shipping partner og 3PL, most plugins will have asynchronous communications with these providers through webhooks in order to automatically update and synchronize the state of Fulfillments.
// type Fulfillment struct {
// 	// The date with timezone at which the Fulfillment was canceled.
// 	CanceledAt *time.Time `json:"canceled_at,omitempty"`

// 	// A claim order object. Available if the relation `claim_order` is expanded.
// 	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

// 	// The id of the Claim that the Fulfillment belongs to.
// 	ClaimOrderId *string `json:"claim_order_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// This contains all the data necessary for the Fulfillment provider to handle the fulfillment.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of the fulfillment in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// The Fulfillment Items in the Fulfillment - these hold information about how many of each Line Item has been fulfilled. Available if the relation `items` is expanded.
// 	Items *[]FulfillmentItem `json:"items,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Flag for describing whether or not notifications related to this should be send.
// 	NoNotification *bool `json:"no_notification,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The id of the Order that the Fulfillment belongs to.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// Represents a fulfillment provider plugin and holds its installation status.
// 	Provider *FulfillmentProvider `json:"provider,omitempty"`

// 	// The id of the Fulfillment Provider responsible for handling the fulfillment
// 	ProviderId string `json:"provider_id"`

// 	// The date with timezone at which the Fulfillment was shipped.
// 	ShippedAt *time.Time `json:"shipped_at,omitempty"`

// 	// A swap object. Available if the relation `swap` is expanded.
// 	Swap *map[string]interface{} `json:"swap,omitempty"`

// 	// The id of the Swap that the Fulfillment belongs to.
// 	SwapId *string `json:"swap_id,omitempty"`

// 	// The Tracking Links that can be used to track the status of the Fulfillment, these will usually be provided by the Fulfillment Provider. Available if the relation `tracking_links` is expanded.
// 	TrackingLinks *[]TrackingLink `json:"tracking_links,omitempty"`

// 	// The tracking numbers that can be used to track the status of the fulfillment.
// 	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Correlates a Line Item with a Fulfillment, keeping track of the quantity of the Line Item.
// type FulfillmentItem struct {
// 	// A fulfillment object. Available if the relation `fulfillment` is expanded.
// 	Fulfillment *map[string]interface{} `json:"fulfillment,omitempty"`

// 	// The id of the Fulfillment that the Fulfillment Item belongs to.
// 	FulfillmentId string `json:"fulfillment_id"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	Item *LineItem `json:"item,omitempty"`

// 	// The id of the Line Item that the Fulfillment Item references.
// 	ItemId string `json:"item_id"`

// 	// The quantity of the Line Item that is included in the Fulfillment.
// 	Quantity int `json:"quantity"`
// }

// // Represents a fulfillment provider plugin and holds its installation status.
// type FulfillmentProvider struct {
// 	// The id of the fulfillment provider as given by the plugin.
// 	Id *string `json:"id,omitempty"`

// 	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
// 	IsInstalled *bool `json:"is_installed,omitempty"`
// }

// // Gift Cards are redeemable and represent a value that can be used towards the payment of an Order.
// type GiftCard struct {
// 	// The remaining value on the Gift Card.
// 	Balance int `json:"balance"`

// 	// The unique code that identifies the Gift Card. This is used by the Customer to redeem the value of the Gift Card.
// 	Code string `json:"code"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The time at which the Gift Card can no longer be used.
// 	EndsAt *time.Time `json:"ends_at,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// Whether the Gift Card has been disabled. Disabled Gift Cards cannot be applied to carts.
// 	IsDisabled *bool `json:"is_disabled,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The id of the Order that the Gift Card was purchased in.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The id of the Region in which the Gift Card is available.
// 	RegionId string `json:"region_id"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value that the Gift Card represents.
// 	Value int `json:"value"`
// }

// // Gift Card Transactions are created once a Customer uses a Gift Card to pay for their Order
// type GiftCardTransaction struct {
// 	// The amount that was used from the Gift Card.
// 	Amount int `json:"amount"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// A gift card object. Available if the relation `gift_card` is expanded.
// 	GiftCard *map[string]interface{} `json:"gift_card,omitempty"`

// 	// The ID of the Gift Card that was used in the transaction.
// 	GiftCardId string `json:"gift_card_id"`

// 	// The gift card transaction's ID
// 	Id *string `json:"id,omitempty"`

// 	// Whether the transaction is taxable or not.
// 	IsTaxable *bool `json:"is_taxable,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The ID of the Order that the Gift Card was used to pay for.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// The tax rate of the transaction
// 	TaxRate *float32 `json:"tax_rate,omitempty"`
// }

// // Images holds a reference to a URL at which the image file can be found.
// type Image struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The image's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The URL at which the image file can be found.
// 	Url string `json:"url"`
// }

// // Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// type LineItem struct {
// 	// Available if the relation `adjustments` is expanded.
// 	Adjustments *[]LineItemAdjustment `json:"adjustments,omitempty"`

// 	// Flag to indicate if the Line Item should be included when doing discount calculations.
// 	AllowDiscounts *bool `json:"allow_discounts,omitempty"`

// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The ID of the Cart that the Line Item belongs to.
// 	CartId *string `json:"cart_id,omitempty"`

// 	// A claim order object. Available if the relation `claim_order` is expanded.
// 	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

// 	// The id of the Claim that the Line Item belongs to.
// 	ClaimOrderId *string `json:"claim_order_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// A more detailed description of the contents of the Line Item.
// 	Description *string `json:"description,omitempty"`

// 	// The total of discount of the line item
// 	DiscountTotal *int `json:"discount_total,omitempty"`

// 	// The quantity of the Line Item that has been fulfilled.
// 	FulfilledQuantity *int `json:"fulfilled_quantity,omitempty"`

// 	// The total of the gift card of the line item
// 	GiftCardTotal *int `json:"gift_card_total,omitempty"`

// 	// Flag to indicate if the Line Item has fulfillment associated with it.
// 	HasShipping *bool `json:"has_shipping,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// [EXPERIMENTAL] Indicates if the line item unit_price include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// Flag to indicate if the Line Item is a Gift Card.
// 	IsGiftcard *bool `json:"is_giftcard,omitempty"`

// 	// Is the item being returned
// 	IsReturn *bool `json:"is_return,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The ID of the Order that the Line Item belongs to.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// The original tax total amount of the line item
// 	OriginalTaxTotal *int `json:"original_tax_total,omitempty"`

// 	// The original total amount of the line item
// 	OriginalTotal *int `json:"original_total,omitempty"`

// 	// The quantity of the content in the Line Item.
// 	Quantity int `json:"quantity"`

// 	// The amount that can be refunded from the given Line Item. Takes taxes and discounts into consideration.
// 	Refundable *int `json:"refundable,omitempty"`

// 	// The quantity of the Line Item that has been returned.
// 	ReturnedQuantity *int `json:"returned_quantity,omitempty"`

// 	// The quantity of the Line Item that has been shipped.
// 	ShippedQuantity *int `json:"shipped_quantity,omitempty"`

// 	// Flag to indicate if new Line Items with the same variant should be merged or added as an additional Line Item.
// 	ShouldMerge *bool `json:"should_merge,omitempty"`

// 	// The subtotal of the line item
// 	Subtotal *int `json:"subtotal,omitempty"`

// 	// A swap object. Available if the relation `swap` is expanded.
// 	Swap *map[string]interface{} `json:"swap,omitempty"`

// 	// The id of the Swap that the Line Item belongs to.
// 	SwapId *string `json:"swap_id,omitempty"`

// 	// Available if the relation `tax_lines` is expanded.
// 	TaxLines *[]LineItemTaxLine `json:"tax_lines,omitempty"`

// 	// The total of tax of the line item
// 	TaxTotal *int `json:"tax_total,omitempty"`

// 	// A URL string to a small image of the contents of the Line Item.
// 	Thumbnail *string `json:"thumbnail,omitempty"`

// 	// The title of the Line Item, this should be easily identifiable by the Customer.
// 	Title string `json:"title"`

// 	// The total amount of the line item
// 	Total *int `json:"total,omitempty"`

// 	// The price of one unit of the content in the Line Item. This should be in the currency defined by the Cart/Order/Swap/Claim that the Line Item belongs to.
// 	UnitPrice bool `json:"unit_price"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// A product variant object. The Product Variant contained in the Line Item. Available if the relation `variant` is expanded.
// 	Variant *map[string]interface{} `json:"variant,omitempty"`

// 	// The id of the Product Variant contained in the Line Item.
// 	VariantId *string `json:"variant_id,omitempty"`
// }

// // Represents an Line Item Adjustment
// type LineItemAdjustment struct {
// 	// The adjustment amount
// 	Amount float32 `json:"amount"`

// 	// The line item's adjustment description
// 	Description string `json:"description"`

// 	// Represents a discount that can be applied to a cart for promotional purposes.
// 	Discount *Discount `json:"discount,omitempty"`

// 	// The ID of the discount associated with the adjustment
// 	DiscountId *string `json:"discount_id,omitempty"`

// 	// The invite's ID
// 	Id *string `json:"id,omitempty"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	Item *LineItem `json:"item,omitempty"`

// 	// The ID of the line item
// 	ItemId string `json:"item_id"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`
// }

// // Represents an Line Item Tax Line
// type LineItemTaxLine struct {
// 	// A code to identify the tax type by
// 	Code *string `json:"code,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The line item tax line's ID
// 	Id *string `json:"id,omitempty"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	Item *LineItem `json:"item,omitempty"`

// 	// The ID of the line item
// 	ItemId string `json:"item_id"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// A human friendly name for the tax
// 	Name string `json:"name"`

// 	// The numeric rate to charge tax by
// 	Rate float32 `json:"rate"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Money Amounts represents an amount that a given Product Variant can be purcased for. Each Money Amount either has a Currency or Region associated with it to indicate the pricing in a given Currency or, for fully region-based pricing, the given price in a specific Region. If region-based pricing is used the amount will be in the currency defined for the Reigon.
// type MoneyAmount struct {
// 	// The amount in the smallest currecny unit (e.g. cents 100 cents to charge $1) that the Product Variant will cost.
// 	Amount int `json:"amount"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// Currency
// 	Currency *Currency `json:"currency,omitempty"`

// 	// The 3 character currency code that the Money Amount is given in.
// 	CurrencyCode string `json:"currency_code"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The money amount's ID
// 	Id *string `json:"id,omitempty"`

// 	// The maximum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
// 	MaxQuantity *int `json:"max_quantity,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The minimum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
// 	MinQuantity *int `json:"min_quantity,omitempty"`

// 	// Price Lists represents a set of prices that overrides the default price for one or more product variants.
// 	PriceList *PriceList `json:"price_list,omitempty"`

// 	// The ID of the price list associated with the money amount
// 	PriceListId *string `json:"price_list_id,omitempty"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The region's ID
// 	RegionId *string `json:"region_id,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The Product Variant contained in the Line Item. Available if the relation `variant` is expanded.
// 	Variant *map[string]interface{} `json:"variant,omitempty"`

// 	// The id of the Product Variant contained in the Line Item.
// 	VariantId *string `json:"variant_id,omitempty"`
// }

// // MultipleErrors defines model for multiple_errors.
// type MultipleErrors struct {
// 	// Array of errors
// 	Errors  *[]Error `json:"errors,omitempty"`
// 	Message *string  `json:"message,omitempty"`
// }

// // Notifications a communications sent via Notification Providers as a reaction to internal events such as `order.placed`. Notifications can be used to show a chronological timeline for communications sent to a Customer regarding an Order, and enables resends.
// type Notification struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// A customer object. Available if the relation `customer` is expanded.
// 	Customer *map[string]interface{} `json:"customer,omitempty"`

// 	// The ID of the Customer that the Notification was sent to.
// 	CustomerId *string `json:"customer_id,omitempty"`

// 	// The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The name of the event that the notification was sent for.
// 	EventName *string `json:"event_name,omitempty"`

// 	// The notification's ID
// 	Id *string `json:"id,omitempty"`

// 	// Represents a notification provider plugin and holds its installation status.
// 	Provider *NotificationProvider `json:"provider,omitempty"`

// 	// The id of the Notification Provider that handles the Notification.
// 	ProviderId *string `json:"provider_id,omitempty"`

// 	// The resends that have been completed after the original Notification.
// 	Resends *[]NotificationResend `json:"resends,omitempty"`

// 	// The ID of the resource that the Notification refers to.
// 	ResourceId string `json:"resource_id"`

// 	// The type of resource that the Notification refers to.
// 	ResourceType string `json:"resource_type"`

// 	// The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
// 	To string `json:"to"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents a notification provider plugin and holds its installation status.
// type NotificationProvider struct {
// 	// The id of the notification provider as given by the plugin.
// 	Id string `json:"id"`

// 	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
// 	IsInstalled *bool `json:"is_installed,omitempty"`
// }

// // A resend of a Notification.
// type NotificationResend struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// A customer object. Available if the relation `customer` is expanded.
// 	Customer *map[string]interface{} `json:"customer,omitempty"`

// 	// The ID of the Customer that the Notification was sent to.
// 	CustomerId *string `json:"customer_id,omitempty"`

// 	// The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The name of the event that the notification was sent for.
// 	EventName *string `json:"event_name,omitempty"`

// 	// The notification resend's ID
// 	Id *string `json:"id,omitempty"`

// 	// The ID of the Notification that was originally sent.
// 	ParentId *string `json:"parent_id,omitempty"`

// 	// Notifications a communications sent via Notification Providers as a reaction to internal events such as `order.placed`. Notifications can be used to show a chronological timeline for communications sent to a Customer regarding an Order, and enables resends.
// 	ParentNotification *Notification `json:"parent_notification,omitempty"`

// 	// Represents a notification provider plugin and holds its installation status.
// 	Provider *NotificationProvider `json:"provider,omitempty"`

// 	// The ID of the Notification Provider that handles the Notification.
// 	ProviderId *string `json:"provider_id,omitempty"`

// 	// The ID of the resource that the Notification refers to.
// 	ResourceId *string `json:"resource_id,omitempty"`

// 	// The type of resource that the Notification refers to.
// 	ResourceType *string `json:"resource_type,omitempty"`

// 	// The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
// 	To *string `json:"to,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents an order
// type Order struct {
// 	// An address.
// 	BillingAddress *Address `json:"billing_address,omitempty"`

// 	// The ID of the billing address associated with the order
// 	BillingAddressId *string `json:"billing_address_id,omitempty"`

// 	// The date the order was canceled on.
// 	CanceledAt *time.Time `json:"canceled_at,omitempty"`

// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The ID of the cart associated with the order
// 	CartId *string `json:"cart_id,omitempty"`

// 	// The claims associated with the order. Available if the relation `claims` is expanded.
// 	Claims *[]map[string]interface{} `json:"claims,omitempty"`

// 	// Currency
// 	Currency *Currency `json:"currency,omitempty"`

// 	// The 3 character currency code that is used in the order
// 	CurrencyCode string `json:"currency_code"`

// 	// A customer object. Available if the relation `customer` is expanded.
// 	Customer *map[string]interface{} `json:"customer,omitempty"`

// 	// The ID of the customer associated with the order
// 	CustomerId string `json:"customer_id"`

// 	// The total of discount
// 	DiscountTotal *int `json:"discount_total,omitempty"`

// 	// The discounts used in the order. Available if the relation `discounts` is expanded.
// 	Discounts *[]map[string]interface{} `json:"discounts,omitempty"`

// 	// The order's display ID
// 	DisplayId *int `json:"display_id,omitempty"`

// 	// A draft order object. Available if the relation `draft_order` is expanded.
// 	DraftOrder *map[string]interface{} `json:"draft_order,omitempty"`

// 	// The ID of the draft order this order is associated with.
// 	DraftOrderId *string `json:"draft_order_id,omitempty"`

// 	// [EXPERIMENTAL] Order edits done on the order. Available if the relation `edits` is expanded.
// 	Edits *[]OrderEdit `json:"edits,omitempty"`

// 	// The email associated with the order
// 	Email openapi_types.Email `json:"email"`

// 	// The ID of an external order.
// 	ExternalId *string `json:"external_id,omitempty"`

// 	// The order's fulfillment status
// 	FulfillmentStatus *OrderFulfillmentStatus `json:"fulfillment_status,omitempty"`

// 	// The fulfillments used in the order. Available if the relation `fulfillments` is expanded.
// 	Fulfillments *[]Fulfillment `json:"fulfillments,omitempty"`

// 	// The total of gift cards with taxes
// 	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

// 	// The total of gift cards
// 	GiftCardTotal *int `json:"gift_card_total,omitempty"`

// 	// The gift card transactions used in the order. Available if the relation `gift_card_transactions` is expanded.
// 	GiftCardTransactions *[]GiftCardTransaction `json:"gift_card_transactions,omitempty"`

// 	// The gift cards used in the order. Available if the relation `gift_cards` is expanded.
// 	GiftCards *[]map[string]interface{} `json:"gift_cards,omitempty"`

// 	// The order's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the processing of the order in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// The line items that belong to the order. Available if the relation `items` is expanded.
// 	Items *[]LineItem `json:"items,omitempty"`

// 	// Flag for describing whether or not notifications related to this should be send.
// 	NoNotification *bool `json:"no_notification,omitempty"`

// 	// The total amount paid
// 	PaidTotal *int `json:"paid_total,omitempty"`

// 	// The order's payment status
// 	PaymentStatus *OrderPaymentStatus `json:"payment_status,omitempty"`

// 	// The payments used in the order. Available if the relation `payments` is expanded.
// 	Payments *[]Payment `json:"payments,omitempty"`

// 	// The amount that can be refunded
// 	RefundableAmount *int `json:"refundable_amount,omitempty"`

// 	// The total amount refunded if the order is returned.
// 	RefundedTotal *int `json:"refunded_total,omitempty"`

// 	// The refunds associated with the order. Available if the relation `refunds` is expanded.
// 	Refunds *[]map[string]interface{} `json:"refunds,omitempty"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The region's ID
// 	RegionId string `json:"region_id"`

// 	// The returns associated with the order. Available if the relation `returns` is expanded.
// 	Returns *[]map[string]interface{} `json:"returns,omitempty"`

// 	// A sales channel object. Available if the relation `sales_channel` is expanded.
// 	SalesChannel *map[string]interface{} `json:"sales_channel,omitempty"`

// 	// The ID of the sales channel this order is associated with.
// 	SalesChannelId *string `json:"sales_channel_id,omitempty"`

// 	// An address.
// 	ShippingAddress *Address `json:"shipping_address,omitempty"`

// 	// The ID of the shipping address associated with the order
// 	ShippingAddressId *string `json:"shipping_address_id,omitempty"`

// 	// The shipping methods used in the order. Available if the relation `shipping_methods` is expanded.
// 	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

// 	// The total of shipping
// 	ShippingTotal *int `json:"shipping_total,omitempty"`

// 	// The order's status
// 	Status *OrderStatus `json:"status,omitempty"`

// 	// The subtotal of the order
// 	Subtotal *int `json:"subtotal,omitempty"`

// 	// The swaps associated with the order. Available if the relation `swaps` is expanded.
// 	Swaps *[]map[string]interface{} `json:"swaps,omitempty"`

// 	// The order's tax rate
// 	TaxRate *float32 `json:"tax_rate,omitempty"`

// 	// The total of tax
// 	TaxTotal *int `json:"tax_total,omitempty"`

// 	// The total amount of the order
// 	Total *int `json:"total,omitempty"`
// }

// // The order's fulfillment status
// type OrderFulfillmentStatus string

// // The order's payment status
// type OrderPaymentStatus string

// // The order's status
// type OrderStatus string

// // Order edit keeps track of order items changes.
// type OrderEdit struct {
// 	// Line item changes array.
// 	Changes []OrderItemChange `json:"changes"`

// 	// The date with timezone at which the edit was confirmed.
// 	ConfirmedAt *time.Time `json:"confirmed_at,omitempty"`

// 	// The unique identifier of the user or customer who confirmed the order edit.
// 	ConfirmedBy *string `json:"confirmed_by,omitempty"`

// 	// The unique identifier of the user or customer who created the order edit.
// 	CreatedBy string `json:"created_by"`

// 	// The date with timezone at which the edit was declined.
// 	DeclinedAt *time.Time `json:"declined_at,omitempty"`

// 	// The unique identifier of the user or customer who declined the order edit.
// 	DeclinedBy *string `json:"declined_by,omitempty"`

// 	// An optional note why  the order edit is declined.
// 	DeclinedReason *string `json:"declined_reason,omitempty"`

// 	// The difference between the total amount of the order and total amount of edited order.
// 	DifferenceDue *int `json:"difference_due,omitempty"`

// 	// The total of discount
// 	DiscountTotal *int `json:"discount_total,omitempty"`

// 	// The order edit's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional note with additional details about the order edit.
// 	InternalNote *string `json:"internal_note,omitempty"`

// 	// Computed line items from the changes.
// 	Items *[]LineItem `json:"items,omitempty"`

// 	// Represents an order
// 	Order Order `json:"order"`

// 	// The ID of the order that is edited
// 	OrderId string `json:"order_id"`

// 	// The date with timezone at which the edit was requested.
// 	RequestedAt *time.Time `json:"requested_at,omitempty"`

// 	// The unique identifier of the user or customer who requested the order edit.
// 	RequestedBy *string `json:"requested_by,omitempty"`

// 	// The subtotal for line items computed from changes.
// 	Subtotal *int `json:"subtotal,omitempty"`

// 	// The total of tax
// 	TaxTotal *int `json:"tax_total,omitempty"`

// 	// The total amount of the edited order.
// 	Total *int `json:"total,omitempty"`
// }

// // Represents an order edit item change
// type OrderItemChange struct {
// 	// The order item change's ID
// 	Id *string `json:"id,omitempty"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	LineItem *LineItem `json:"line_item,omitempty"`

// 	// The ID of the cloned line item.
// 	LineItemId *string `json:"line_item_id,omitempty"`

// 	// Order edit keeps track of order items changes.
// 	OrderEdit *OrderEdit `json:"order_edit,omitempty"`

// 	// The ID of the order edit
// 	OrderEditId string `json:"order_edit_id"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	OriginalLineItem *LineItem `json:"original_line_item,omitempty"`

// 	// The ID of the original line item in the order
// 	OriginalLineItemId *string `json:"original_line_item_id,omitempty"`

// 	// The order's status
// 	Type OrderItemChangeType `json:"type"`
// }

// // The order's status
// type OrderItemChangeType string

// // Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
// type Payment struct {
// 	// The amount that the Payment has been authorized for.
// 	Amount int `json:"amount"`

// 	// The amount of the original Payment amount that has been refunded back to the Customer.
// 	AmountRefunded *int `json:"amount_refunded,omitempty"`

// 	// The date with timezone at which the Payment was canceled.
// 	CanceledAt *time.Time `json:"canceled_at,omitempty"`

// 	// The date with timezone at which the Payment was captured.
// 	CapturedAt *time.Time `json:"captured_at,omitempty"`

// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The id of the Cart that the Payment Session is created for.
// 	CartId *string `json:"cart_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// Currency
// 	Currency *Currency `json:"currency,omitempty"`

// 	// The 3 character ISO currency code that the Payment is completed in.
// 	CurrencyCode string `json:"currency_code"`

// 	// The data required for the Payment Provider to identify, modify and process the Payment. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn't hold any state.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The payment's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of a payment in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The ID of the Order that the Payment is used for.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// The id of the Payment Provider that is responsible for the Payment
// 	ProviderId string `json:"provider_id"`

// 	// A swap object. Available if the relation `swap` is expanded.
// 	Swap *map[string]interface{} `json:"swap,omitempty"`

// 	// The ID of the Swap that the Payment is used for.
// 	SwapId *string `json:"swap_id,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Represents a Payment Provider plugin and holds its installation status.
// type PaymentProvider struct {
// 	// The id of the payment provider as given by the plugin.
// 	Id string `json:"id"`

// 	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
// 	IsInstalled *bool `json:"is_installed,omitempty"`
// }

// // Payment Sessions are created when a Customer initilizes the checkout flow, and can be used to hold the state of a payment flow. Each Payment Session is controlled by a Payment Provider, who is responsible for the communication with external payment services. Authorized Payment Sessions will eventually get promoted to Payments to indicate that they are authorized for capture/refunds/etc.
// type PaymentSession struct {
// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The id of the Cart that the Payment Session is created for.
// 	CartId string `json:"cart_id"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The data required for the Payment Provider to identify, modify and process the Payment Session. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn't hold any state.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The payment session's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of a cart in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// A flag to indicate if the Payment Session has been selected as the method that will be used to complete the purchase.
// 	IsSelected *bool `json:"is_selected,omitempty"`

// 	// The id of the Payment Provider that is responsible for the Payment Session
// 	ProviderId string `json:"provider_id"`

// 	// Indicates the status of the Payment Session. Will default to `pending`, and will eventually become `authorized`. Payment Sessions may have the status of `requires_more` to indicate that further actions are to be completed by the Customer.
// 	Status PaymentSessionStatus `json:"status"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Indicates the status of the Payment Session. Will default to `pending`, and will eventually become `authorized`. Payment Sessions may have the status of `requires_more` to indicate that further actions are to be completed by the Customer.
// type PaymentSessionStatus string

// // Price Lists represents a set of prices that overrides the default price for one or more product variants.
// type PriceList struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The Customer Groups that the Price List applies to. Available if the relation `customer_groups` is expanded.
// 	CustomerGroups *[]map[string]interface{} `json:"customer_groups,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The price list's description
// 	Description string `json:"description"`

// 	// The date with timezone that the Price List stops being valid.
// 	EndsAt *time.Time `json:"ends_at,omitempty"`

// 	// The price list's ID
// 	Id *string `json:"id,omitempty"`

// 	// [EXPERIMENTAL] Does the price list prices include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// The price list's name
// 	Name string `json:"name"`

// 	// The Money Amounts that are associated with the Price List. Available if the relation `prices` is expanded.
// 	Prices *[]interface{} `json:"prices,omitempty"`

// 	// The date with timezone that the Price List starts being valid.
// 	StartsAt *time.Time `json:"starts_at,omitempty"`

// 	// The status of the Price List
// 	Status *PriceListStatus `json:"status,omitempty"`

// 	// The type of Price List. This can be one of either `sale` or `override`.
// 	Type *PriceListType `json:"type,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // The status of the Price List
// type PriceListStatus string

// // The type of Price List. This can be one of either `sale` or `override`.
// type PriceListType string

// // Products are a grouping of Product Variants that have common properties such as images and descriptions. Products can have multiple options which define the properties that Product Variants differ by.
// type Product struct {
// 	// A product collection object. Available if the relation `collection` is expanded.
// 	Collection *map[string]interface{} `json:"collection,omitempty"`

// 	// The Product Collection that the Product belongs to
// 	CollectionId *string `json:"collection_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// A short description of the Product.
// 	Description *string `json:"description,omitempty"`

// 	// Whether the Product can be discounted. Discounts will not apply to Line Items of this Product when this flag is set to `false`.
// 	Discountable *bool `json:"discountable,omitempty"`

// 	// The external ID of the product
// 	ExternalId *string `json:"external_id,omitempty"`

// 	// A unique identifier for the Product (e.g. for slug structure).
// 	Handle *string `json:"handle,omitempty"`

// 	// The height of the Product Variant. May be used in shipping rate calculations.
// 	Height *float32 `json:"height,omitempty"`

// 	// The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	HsCode *string `json:"hs_code,omitempty"`

// 	// The product's ID
// 	Id *string `json:"id,omitempty"`

// 	// Images of the Product. Available if the relation `images` is expanded.
// 	Images *[]Image `json:"images,omitempty"`

// 	// Whether the Product represents a Gift Card. Products that represent Gift Cards will automatically generate a redeemable Gift Card code once they are purchased.
// 	IsGiftcard *bool `json:"is_giftcard,omitempty"`

// 	// The length of the Product Variant. May be used in shipping rate calculations.
// 	Length *float32 `json:"length,omitempty"`

// 	// The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	Material *string `json:"material,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	MidCode *string `json:"mid_code,omitempty"`

// 	// The Product Options that are defined for the Product. Product Variants of the Product will have a unique combination of Product Option Values. Available if the relation `options` is expanded.
// 	Options *[]ProductOption `json:"options,omitempty"`

// 	// The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	OriginCountry *string `json:"origin_country,omitempty"`

// 	// Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
// 	Profile *ShippingProfile `json:"profile,omitempty"`

// 	// The ID of the Shipping Profile that the Product belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
// 	ProfileId string `json:"profile_id"`

// 	// The sales channels the product is associated with. Available if the relation `sales_channels` is expanded.
// 	SalesChannels *[]map[string]interface{} `json:"sales_channels,omitempty"`

// 	// The status of the product
// 	Status *ProductStatus `json:"status,omitempty"`

// 	// An optional subtitle that can be used to further specify the Product.
// 	Subtitle *string `json:"subtitle,omitempty"`

// 	// The Product Tags assigned to the Product. Available if the relation `tags` is expanded.
// 	Tags *[]ProductTag `json:"tags,omitempty"`

// 	// A URL to an image file that can be used to identify the Product.
// 	Thumbnail *string `json:"thumbnail,omitempty"`

// 	// A title that can be displayed for easy identification of the Product.
// 	Title string `json:"title"`

// 	// Product Type can be added to Products for filtering and reporting purposes.
// 	Type *ProductType `json:"type,omitempty"`

// 	// The Product type that the Product belongs to
// 	TypeId *string `json:"type_id,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The Product Variants that belong to the Product. Each will have a unique combination of Product Option Values. Available if the relation `variants` is expanded.
// 	Variants *[]ProductVariant `json:"variants,omitempty"`

// 	// The weight of the Product Variant. May be used in shipping rate calculations.
// 	Weight *float32 `json:"weight,omitempty"`

// 	// The width of the Product Variant. May be used in shipping rate calculations.
// 	Width *float32 `json:"width,omitempty"`
// }

// // The status of the product
// type ProductStatus string

// // Product Collections represents a group of Products that are related.
// type ProductCollection struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// A unique string that identifies the Product Collection - can for example be used in slug structures.
// 	Handle *string `json:"handle,omitempty"`

// 	// The product collection's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The Products contained in the Product Collection. Available if the relation `products` is expanded.
// 	Products *[]map[string]interface{} `json:"products,omitempty"`

// 	// The title that the Product Collection is identified by.
// 	Title string `json:"title"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Product Options define properties that may vary between different variants of a Product. Common Product Options are "Size" and "Color", but Medusa doesn't limit what Product Options that can be defined.
// type ProductOption struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The product option's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// A product object. Available if the relation `product` is expanded.
// 	Product *map[string]interface{} `json:"product,omitempty"`

// 	// The ID of the Product that the Product Option is defined for.
// 	ProductId string `json:"product_id"`

// 	// The title that the Product Option is defined by (e.g. "Size").
// 	Title string `json:"title"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The Product Option Values that are defined for the Product Option. Available if the relation `values` is expanded.
// 	Values *[]ProductOptionValue `json:"values,omitempty"`
// }

// // A value given to a Product Variant's option set. Product Variant have a Product Option Value for each of the Product Options defined on the Product.
// type ProductOptionValue struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The product option value's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// Product Options define properties that may vary between different variants of a Product. Common Product Options are "Size" and "Color", but Medusa doesn't limit what Product Options that can be defined.
// 	Option *ProductOption `json:"option,omitempty"`

// 	// The ID of the Product Option that the Product Option Value is defined for.
// 	OptionId string `json:"option_id"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value that the Product Variant has defined for the specific Product Option (e.g. if the Product Option is "Size" this value could be "Small", "Medium" or "Large").
// 	Value string `json:"value"`

// 	// Product Variants represent a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations.
// 	Variant *ProductVariant `json:"variant,omitempty"`

// 	// The ID of the Product Variant that the Product Option Value is defined for.
// 	VariantId string `json:"variant_id"`
// }

// // Product Tags can be added to Products for easy filtering and grouping.
// type ProductTag struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The product tag's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value that the Product Tag represents
// 	Value string `json:"value"`
// }

// // Product Type can be added to Products for filtering and reporting purposes.
// type ProductType struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The product type's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value that the Product Type represents.
// 	Value string `json:"value"`
// }

// // Product Variants represent a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations.
// type ProductVariant struct {
// 	// Whether the Product Variant should be purchasable when `inventory_quantity` is 0.
// 	AllowBackorder *bool `json:"allow_backorder,omitempty"`

// 	// A generic field for a GTIN number that can be used to identify the Product Variant.
// 	Barcode *string `json:"barcode,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// An EAN barcode number that can be used to identify the Product Variant.
// 	Ean *string `json:"ean,omitempty"`

// 	// The height of the Product Variant. May be used in shipping rate calculations.
// 	Height *float32 `json:"height,omitempty"`

// 	// The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	HsCode *string `json:"hs_code,omitempty"`

// 	// The product variant's ID
// 	Id *string `json:"id,omitempty"`

// 	// The current quantity of the item that is stocked.
// 	InventoryQuantity int `json:"inventory_quantity"`

// 	// The length of the Product Variant. May be used in shipping rate calculations.
// 	Length *float32 `json:"length,omitempty"`

// 	// Whether Medusa should manage inventory for the Product Variant.
// 	ManageInventory *bool `json:"manage_inventory,omitempty"`

// 	// The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	Material *string `json:"material,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	MidCode *string `json:"mid_code,omitempty"`

// 	// The Product Option Values specified for the Product Variant. Available if the relation `options` is expanded.
// 	Options *[]ProductOptionValue `json:"options,omitempty"`

// 	// The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
// 	OriginCountry *string `json:"origin_country,omitempty"`

// 	// The Money Amounts defined for the Product Variant. Each Money Amount represents a price in a given currency or a price in a specific Region. Available if the relation `prices` is expanded.
// 	Prices *[]MoneyAmount `json:"prices,omitempty"`

// 	// A product object. Available if the relation `product` is expanded.
// 	Product *map[string]interface{} `json:"product,omitempty"`

// 	// The ID of the Product that the Product Variant belongs to.
// 	ProductId string `json:"product_id"`

// 	// The unique stock keeping unit used to identify the Product Variant. This will usually be a unqiue identifer for the item that is to be shipped, and can be referenced across multiple systems.
// 	Sku *string `json:"sku,omitempty"`

// 	// A title that can be displayed for easy identification of the Product Variant.
// 	Title string `json:"title"`

// 	// A UPC barcode number that can be used to identify the Product Variant.
// 	Upc *string `json:"upc,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The ranking of this variant
// 	VariantRank *float32 `json:"variant_rank,omitempty"`

// 	// The weight of the Product Variant. May be used in shipping rate calculations.
// 	Weight *float32 `json:"weight,omitempty"`

// 	// The width of the Product Variant. May be used in shipping rate calculations.
// 	Width *float32 `json:"width,omitempty"`
// }

// // Regions hold settings for how Customers in a given geographical location shop. The is, for example, where currencies and tax rates are defined. A Region can consist of multiple countries to accomodate common shopping settings across countries.
// type Region struct {
// 	// Whether taxes should be automated in this region.
// 	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

// 	// The countries that are included in the Region. Available if the relation `countries` is expanded.
// 	Countries *[]Country `json:"countries,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// Currency
// 	Currency *Currency `json:"currency,omitempty"`

// 	// The 3 character currency code that the Region uses.
// 	CurrencyCode string `json:"currency_code"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The Fulfillment Providers that can be used to fulfill orders in the Region. Available if the relation `payment_providers` is expanded.
// 	FulfillmentProviders *[]FulfillmentProvider `json:"fulfillment_providers,omitempty"`

// 	// Whether the gift cards are taxable or not in this region.
// 	GiftCardsTaxable *bool `json:"gift_cards_taxable,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// [EXPERIMENTAL] Does the prices for the region include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The name of the region as displayed to the customer. If the Region only has one country it is recommended to write the country name.
// 	Name string `json:"name"`

// 	// The Payment Providers that can be used to process Payments in the Region. Available if the relation `payment_providers` is expanded.
// 	PaymentProviders *[]PaymentProvider `json:"payment_providers,omitempty"`

// 	// The tax code used on purchases in the Region. This may be used by other systems for accounting purposes.
// 	TaxCode *string `json:"tax_code,omitempty"`

// 	// The tax service used to calculate taxes
// 	TaxProvider *TaxProvider `json:"tax_provider,omitempty"`

// 	// The ID of the tax provider used in this region
// 	TaxProviderId *string `json:"tax_provider_id,omitempty"`

// 	// The tax rate that should be charged on purchases in the Region.
// 	TaxRate float32 `json:"tax_rate"`

// 	// The tax rates that are included in the Region. Available if the relation `tax_rates` is expanded.
// 	TaxRates *[]TaxRate `json:"tax_rates,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Return orders hold information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can be used as part of a Swap.
// type Return struct {
// 	// A claim order object. Available if the relation `claim_order` is expanded.
// 	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

// 	// The ID of the Claim that the Return is a part of.
// 	ClaimOrderId *string `json:"claim_order_id,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The return's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of the return in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// The Return Items that will be shipped back to the warehouse. Available if the relation `items` is expanded.
// 	Items *[]ReturnItem `json:"items,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// When set to true, no notification will be sent related to this return.
// 	NoNotification *bool `json:"no_notification,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The ID of the Order that the Return is made from.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// The date with timezone at which the return was received.
// 	ReceivedAt *time.Time `json:"received_at,omitempty"`

// 	// The amount that should be refunded as a result of the return.
// 	RefundAmount int `json:"refund_amount"`

// 	// Data about the return shipment as provided by the Fulfilment Provider that handles the return shipment.
// 	ShippingData *map[string]interface{} `json:"shipping_data,omitempty"`

// 	// The Shipping Method that will be used to send the Return back. Can be null if the Customer facilitates the return shipment themselves. Available if the relation `shipping_method` is expanded.
// 	ShippingMethod *[]ShippingMethod `json:"shipping_method,omitempty"`

// 	// Status of the Return.
// 	Status *ReturnStatus `json:"status,omitempty"`

// 	// A swap object. Available if the relation `swap` is expanded.
// 	Swap *map[string]interface{} `json:"swap,omitempty"`

// 	// The ID of the Swap that the Return is a part of.
// 	SwapId *string `json:"swap_id,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Status of the Return.
// type ReturnStatus string

// // Correlates a Line Item with a Return, keeping track of the quantity of the Line Item that will be returned.
// type ReturnItem struct {
// 	// Whether the Return Item was requested initially or received unexpectedly in the warehouse.
// 	IsRequested *bool `json:"is_requested,omitempty"`

// 	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
// 	Item *LineItem `json:"item,omitempty"`

// 	// The id of the Line Item that the Return Item references.
// 	ItemId string `json:"item_id"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// An optional note with additional details about the Return.
// 	Note *string `json:"note,omitempty"`

// 	// The quantity of the Line Item that is included in the Return.
// 	Quantity *int `json:"quantity,omitempty"`

// 	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
// 	Reason *ReturnReason `json:"reason,omitempty"`

// 	// The ID of the reason for returning the item.
// 	ReasonId *string `json:"reason_id,omitempty"`

// 	// The quantity that was received in the warehouse.
// 	RecievedQuantity *int `json:"recieved_quantity,omitempty"`

// 	// The quantity that was originally requested to be returned.
// 	RequestedQuantity *int `json:"requested_quantity,omitempty"`

// 	// The id of the Return that the Return Item belongs to.
// 	ReturnId string `json:"return_id"`

// 	// Return orders hold information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can be used as part of a Swap.
// 	ReturnOrder *Return `json:"return_order,omitempty"`
// }

// // A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
// type ReturnReason struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// A description of the Reason.
// 	Description *string `json:"description,omitempty"`

// 	// The cart's ID
// 	Id *string `json:"id,omitempty"`

// 	// A text that can be displayed to the Customer as a reason.
// 	Label string `json:"label"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
// 	ParentReturnReason *ReturnReason `json:"parent_return_reason,omitempty"`

// 	// The ID of the parent reason.
// 	ParentReturnReasonId *string `json:"parent_return_reason_id,omitempty"`

// 	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
// 	ReturnReasonChildren *ReturnReason `json:"return_reason_children,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The value to identify the reason by.
// 	Value string `json:"value"`
// }

// // Shipping Methods represent a way in which an Order or Return can be shipped. Shipping Methods are built from a Shipping Option, but may contain additional details, that can be necessary for the Fulfillment Provider to handle the shipment.
// type ShippingMethod struct {
// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The id of the Cart that the Shipping Method is used on.
// 	CartId *string `json:"cart_id,omitempty"`

// 	// A claim order object. Available if the relation `claim_order` is expanded.
// 	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

// 	// The id of the Claim that the Shipping Method is used on.
// 	ClaimOrderId *string `json:"claim_order_id,omitempty"`

// 	// Additional data that the Fulfillment Provider needs to fulfill the shipment. This is used in combination with the Shipping Options data, and may contain information such as a drop point id.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The shipping method's ID
// 	Id *string `json:"id,omitempty"`

// 	// [EXPERIMENTAL] Indicates if the shipping method price include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The id of the Order that the Shipping Method is used on.
// 	OrderId *string `json:"order_id,omitempty"`

// 	// The amount to charge for the Shipping Method. The currency of the price is defined by the Region that the Order that the Shipping Method belongs to is a part of.
// 	Price int `json:"price"`

// 	// The id of the Return that the Shipping Method is used on.
// 	ReturnId *string `json:"return_id,omitempty"`

// 	// A return object. Available if the relation `return_order` is expanded.
// 	ReturnOrder *map[string]interface{} `json:"return_order,omitempty"`

// 	// Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
// 	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

// 	// The id of the Shipping Option that the Shipping Method is built from.
// 	ShippingOptionId string `json:"shipping_option_id"`

// 	// A swap object. Available if the relation `swap` is expanded.
// 	Swap *map[string]interface{} `json:"swap,omitempty"`

// 	// The id of the Swap that the Shipping Method is used on.
// 	SwapId *string `json:"swap_id,omitempty"`

// 	// Available if the relation `tax_lines` is expanded.
// 	TaxLines *[]ShippingMethodTaxLine `json:"tax_lines,omitempty"`
// }

// // Shipping Method Tax Line
// type ShippingMethodTaxLine struct {
// 	// A code to identify the tax type by
// 	Code *string `json:"code,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The line item tax line's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// A human friendly name for the tax
// 	Name string `json:"name"`

// 	// The numeric rate to charge tax by
// 	Rate float32 `json:"rate"`

// 	// Shipping Methods represent a way in which an Order or Return can be shipped. Shipping Methods are built from a Shipping Option, but may contain additional details, that can be necessary for the Fulfillment Provider to handle the shipment.
// 	ShippingMethod *ShippingMethod `json:"shipping_method,omitempty"`

// 	// The ID of the line item
// 	ShippingMethodId string `json:"shipping_method_id"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
// type ShippingOption struct {
// 	// The amount to charge for shipping when the Shipping Option price type is `flat_rate`.
// 	Amount *int `json:"amount,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The data needed for the Fulfillment Provider to identify the Shipping Option.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The shipping option's ID
// 	Id *string `json:"id,omitempty"`

// 	// [EXPERIMENTAL] Does the shipping option price include tax
// 	IncludesTax *bool `json:"includes_tax,omitempty"`

// 	// Flag to indicate if the Shipping Option can be used for Return shipments.
// 	IsReturn *bool `json:"is_return,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The name given to the Shipping Option - this may be displayed to the Customer.
// 	Name string `json:"name"`

// 	// The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
// 	PriceType ShippingOptionPriceType `json:"price_type"`

// 	// Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
// 	Profile *ShippingProfile `json:"profile,omitempty"`

// 	// The ID of the Shipping Profile that the shipping option belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
// 	ProfileId string `json:"profile_id"`

// 	// Represents a fulfillment provider plugin and holds its installation status.
// 	Provider *FulfillmentProvider `json:"provider,omitempty"`

// 	// The id of the Fulfillment Provider, that will be used to process Fulfillments from the Shipping Option.
// 	ProviderId string `json:"provider_id"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The region's ID
// 	RegionId string `json:"region_id"`

// 	// The requirements that must be satisfied for the Shipping Option to be available for a Cart. Available if the relation `requirements` is expanded.
// 	Requirements *[]ShippingOptionRequirement `json:"requirements,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
// type ShippingOptionPriceType string

// // A requirement that a Cart must satisfy for the Shipping Option to be available to the Cart.
// type ShippingOptionRequirement struct {
// 	// The amount to compare the Cart subtotal to.
// 	Amount int `json:"amount"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The shipping option requirement's ID
// 	Id *string `json:"id,omitempty"`

// 	// Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
// 	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

// 	// The id of the Shipping Option that the hipping option requirement belongs to
// 	ShippingOptionId string `json:"shipping_option_id"`

// 	// The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
// 	Type ShippingOptionRequirementType `json:"type"`
// }

// // The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
// type ShippingOptionRequirementType string

// // Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
// type ShippingProfile struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The shipping profile's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The name given to the Shipping profile - this may be displayed to the Customer.
// 	Name string `json:"name"`

// 	// The Products that the Shipping Profile defines Shipping Options for. Available if the relation `products` is expanded.
// 	Products *[]map[string]interface{} `json:"products,omitempty"`

// 	// The Shipping Options that can be used to fulfill the Products in the Shipping Profile. Available if the relation `shipping_options` is expanded.
// 	ShippingOptions *[]ShippingOption `json:"shipping_options,omitempty"`

// 	// The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
// 	Type ShippingProfileType `json:"type"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
// type ShippingProfileType string

// // Swaps can be created when a Customer wishes to exchange Products that they have purchased to different Products. Swaps consist of a Return of previously purchased Products and a Fulfillment of new Products, the amount paid for the Products being returned will be used towards payment for the new Products. In the case where the amount paid for the the Products being returned exceed the amount to be paid for the new Products, a Refund will be issued for the difference.
// type Swap struct {
// 	// The new Line Items to ship to the Customer. Available if the relation `additional_items` is expanded.
// 	AdditionalItems *[]LineItem `json:"additional_items,omitempty"`

// 	// If true, swaps can be completed with items out of stock
// 	AllowBackorder *bool `json:"allow_backorder,omitempty"`

// 	// The date with timezone at which the Swap was canceled.
// 	CanceledAt *time.Time `json:"canceled_at,omitempty"`

// 	// A cart object. Available if the relation `cart` is expanded.
// 	Cart *map[string]interface{} `json:"cart,omitempty"`

// 	// The id of the Cart that the Customer will use to confirm the Swap.
// 	CartId *string `json:"cart_id,omitempty"`

// 	// The date with timezone at which the Swap was confirmed by the Customer.
// 	ConfirmedAt *time.Time `json:"confirmed_at,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// The difference that is paid or refunded as a result of the Swap. May be negative when the amount paid for the returned items exceed the total of the new Products.
// 	DifferenceDue *int `json:"difference_due,omitempty"`

// 	// The status of the Fulfillment of the Swap.
// 	FulfillmentStatus SwapFulfillmentStatus `json:"fulfillment_status"`

// 	// The Fulfillments used to send the new Line Items. Available if the relation `fulfillments` is expanded.
// 	Fulfillments *[]Fulfillment `json:"fulfillments,omitempty"`

// 	// The swap's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of the swap in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// If set to true, no notification will be sent related to this swap
// 	NoNotification *bool `json:"no_notification,omitempty"`

// 	// An order object. Available if the relation `order` is expanded.
// 	Order *map[string]interface{} `json:"order,omitempty"`

// 	// The ID of the Order where the Line Items to be returned where purchased.
// 	OrderId string `json:"order_id"`

// 	// Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
// 	Payment *Payment `json:"payment,omitempty"`

// 	// The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
// 	PaymentStatus SwapPaymentStatus `json:"payment_status"`

// 	// A return order object. The Return that is issued for the return part of the Swap. Available if the relation `return_order` is expanded.
// 	ReturnOrder *map[string]interface{} `json:"return_order,omitempty"`

// 	// An address.
// 	ShippingAddress *Address `json:"shipping_address,omitempty"`

// 	// The Address to send the new Line Items to - in most cases this will be the same as the shipping address on the Order.
// 	ShippingAddressId *string `json:"shipping_address_id,omitempty"`

// 	// The Shipping Methods used to fulfill the additional items purchased. Available if the relation `shipping_methods` is expanded.
// 	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // The status of the Fulfillment of the Swap.
// type SwapFulfillmentStatus string

// // The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
// type SwapPaymentStatus string

// // The tax service used to calculate taxes
// type TaxProvider struct {
// 	// The id of the tax provider as given by the plugin.
// 	Id *string `json:"id,omitempty"`

// 	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
// 	IsInstalled *bool `json:"is_installed,omitempty"`
// }

// // A Tax Rate can be used to associate a certain rate to charge on products within a given Region
// type TaxRate struct {
// 	// A code to identify the tax type by
// 	Code *string `json:"code,omitempty"`

// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The tax rate's ID
// 	Id *string `json:"id,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// A human friendly name for the tax
// 	Name string `json:"name"`

// 	// The count of products
// 	ProductCount *int `json:"product_count,omitempty"`

// 	// The count of product types
// 	ProductTypeCount *int `json:"product_type_count,omitempty"`

// 	// The product types that belong to this tax rate. Available if the relation `product_types` is expanded.
// 	ProductTypes *[]map[string]interface{} `json:"product_types,omitempty"`

// 	// The products that belong to this tax rate. Available if the relation `products` is expanded.
// 	Products *[]map[string]interface{} `json:"products,omitempty"`

// 	// The numeric rate to charge
// 	Rate *float32 `json:"rate,omitempty"`

// 	// A region object. Available if the relation `region` is expanded.
// 	Region *map[string]interface{} `json:"region,omitempty"`

// 	// The id of the Region that the rate belongs to
// 	RegionId string `json:"region_id"`

// 	// The count of shipping options
// 	ShippingOptionCount *int `json:"shipping_option_count,omitempty"`

// 	// The shipping options that belong to this tax rate. Available if the relation `shipping_options` is expanded.
// 	ShippingOptions *[]map[string]interface{} `json:"shipping_options,omitempty"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`
// }

// // Tracking Link holds information about tracking numbers for a Fulfillment. Tracking Links can optionally contain a URL that can be visited to see the status of the shipment.
// type TrackingLink struct {
// 	// The date with timezone at which the resource was created.
// 	CreatedAt *time.Time `json:"created_at,omitempty"`

// 	// The date with timezone at which the resource was deleted.
// 	DeletedAt *time.Time `json:"deleted_at,omitempty"`

// 	// Fulfillments are created once store operators can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a provider, which is typically an external shipping aggregator, shipping partner og 3PL, most plugins will have asynchronous communications with these providers through webhooks in order to automatically update and synchronize the state of Fulfillments.
// 	Fulfillment *Fulfillment `json:"fulfillment,omitempty"`

// 	// The id of the Fulfillment that the Tracking Link references.
// 	FulfillmentId string `json:"fulfillment_id"`

// 	// The tracking link's ID
// 	Id *string `json:"id,omitempty"`

// 	// Randomly generated key used to continue the completion of a process in case of failure.
// 	IdempotencyKey *string `json:"idempotency_key,omitempty"`

// 	// An optional key-value map with additional details
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The tracking number given by the shipping carrier.
// 	TrackingNumber string `json:"tracking_number"`

// 	// The date with timezone at which the resource was updated.
// 	UpdatedAt *time.Time `json:"updated_at,omitempty"`

// 	// The URL at which the status of the shipment can be tracked.
// 	Url *string `json:"url,omitempty"`
// }

// // N400Error defines model for 400_error.
// type N400Error interface{}

// // N500Error defines model for 500_error.
// type N500Error = Error

// // InvalidRequestError defines model for invalid_request_error.
// type InvalidRequestError = Error

// // InvalidStateError defines model for invalid_state_error.
// type InvalidStateError = Error

// // NotFoundError defines model for not_found_error.
// type NotFoundError = Error

// // PostAuthJSONBody defines parameters for PostAuth.
// type PostAuthJSONBody struct {
// 	// The Customer's email.
// 	Email string `json:"email"`

// 	// The Customer's password.
// 	Password string `json:"password"`
// }

// // PostCartJSONBody defines parameters for PostCart.
// type PostCartJSONBody struct {
// 	// An optional object to provide context to the Cart. The `context` field is automatically populated with `ip` and `user_agent`
// 	Context *map[string]interface{} `json:"context,omitempty"`

// 	// The 2 character ISO country code to create the Cart in.
// 	CountryCode *string `json:"country_code,omitempty"`

// 	// An optional array of `variant_id`, `quantity` pairs to generate Line Items from.
// 	Items *[]struct {
// 		// The quantity of the Product Variant to add
// 		Quantity int `json:"quantity"`

// 		// The id of the Product Variant to generate a Line Item from.
// 		VariantId string `json:"variant_id"`
// 	} `json:"items,omitempty"`

// 	// The ID of the Region to create the Cart in.
// 	RegionId *string `json:"region_id,omitempty"`

// 	// [EXPERIMENTAL] The ID of the Sales channel to create the Cart in.
// 	SalesChannelId *string `json:"sales_channel_id,omitempty"`
// }

// // PostCartsCartJSONBody defines parameters for PostCartsCart.
// type PostCartsCartJSONBody struct {
// 	// The Address to be used for billing purposes.
// 	BillingAddress *interface{} `json:"billing_address,omitempty"`

// 	// An optional object to provide context to the Cart.
// 	Context *map[string]interface{} `json:"context,omitempty"`

// 	// The 2 character ISO country code to create the Cart in.
// 	CountryCode *string `json:"country_code,omitempty"`

// 	// The ID of the Customer to associate the Cart with.
// 	CustomerId *string `json:"customer_id,omitempty"`

// 	// An array of Discount codes to add to the Cart.
// 	Discounts *[]struct {
// 		// The code that a Discount is identifed by.
// 		Code string `json:"code"`
// 	} `json:"discounts,omitempty"`

// 	// An email to be used on the Cart.
// 	Email *openapi_types.Email `json:"email,omitempty"`

// 	// An array of Gift Card codes to add to the Cart.
// 	GiftCards *[]struct {
// 		// The code that a Gift Card is identified by.
// 		Code string `json:"code"`
// 	} `json:"gift_cards,omitempty"`

// 	// The id of the Region to create the Cart in.
// 	RegionId *string `json:"region_id,omitempty"`

// 	// The ID of the Sales channel to update the Cart with.
// 	SalesChannelId *string `json:"sales_channel_id,omitempty"`

// 	// The Address to be used for shipping.
// 	ShippingAddress *interface{} `json:"shipping_address,omitempty"`
// }

// // PostCartsCartLineItemsJSONBody defines parameters for PostCartsCartLineItems.
// type PostCartsCartLineItemsJSONBody struct {
// 	// An optional key-value map with additional details about the Line Item.
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The quantity of the Product Variant to add to the Line Item.
// 	Quantity int `json:"quantity"`

// 	// The id of the Product Variant to generate the Line Item from.
// 	VariantId string `json:"variant_id"`
// }

// // PostCartsCartLineItemsItemJSONBody defines parameters for PostCartsCartLineItemsItem.
// type PostCartsCartLineItemsItemJSONBody struct {
// 	// The quantity to set the Line Item to.
// 	Quantity int `json:"quantity"`
// }

// // PostCartsCartPaymentSessionJSONBody defines parameters for PostCartsCartPaymentSession.
// type PostCartsCartPaymentSessionJSONBody struct {
// 	// The ID of the Payment Provider.
// 	ProviderId string `json:"provider_id"`
// }

// // PostCartsCartPaymentSessionUpdateJSONBody defines parameters for PostCartsCartPaymentSessionUpdate.
// type PostCartsCartPaymentSessionUpdateJSONBody struct {
// 	// The data to update the payment session with.
// 	Data map[string]interface{} `json:"data"`
// }

// // PostCartsCartShippingMethodJSONBody defines parameters for PostCartsCartShippingMethod.
// type PostCartsCartShippingMethodJSONBody struct {
// 	// Used to hold any data that the shipping method may need to process the fulfillment of the order. Look at the documentation for your installed fulfillment providers to find out what to send.
// 	Data *map[string]interface{} `json:"data,omitempty"`

// 	// ID of the shipping option to create the method from
// 	OptionId string `json:"option_id"`
// }

// // GetCollectionsParams defines parameters for GetCollections.
// type GetCollectionsParams struct {
// 	// The number of collections to skip before starting to collect the collections set
// 	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

// 	// The number of collections to return
// 	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

// 	// Date comparison for when resulting collections were created.
// 	CreatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"created_at,omitempty" json:"created_at,omitempty"`

// 	// Date comparison for when resulting collections were updated.
// 	UpdatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
// }

// // PostCustomersJSONBody defines parameters for PostCustomers.
// type PostCustomersJSONBody struct {
// 	// The email of the customer.
// 	Email openapi_types.Email `json:"email"`

// 	// The Customer's first name.
// 	FirstName string `json:"first_name"`

// 	// The Customer's last name.
// 	LastName string `json:"last_name"`

// 	// The Customer's password.
// 	Password string `json:"password"`

// 	// The Customer's phone number.
// 	Phone *string `json:"phone,omitempty"`
// }

// // PostCustomersCustomerJSONBody defines parameters for PostCustomersCustomer.
// type PostCustomersCustomerJSONBody struct {
// 	// The Address to be used for billing purposes.
// 	BillingAddress *interface{} `json:"billing_address,omitempty"`

// 	// The email of the customer.
// 	Email *string `json:"email,omitempty"`

// 	// The Customer's first name.
// 	FirstName *string `json:"first_name,omitempty"`

// 	// The Customer's last name.
// 	LastName *string `json:"last_name,omitempty"`

// 	// Metadata about the customer.
// 	Metadata *map[string]interface{} `json:"metadata,omitempty"`

// 	// The Customer's password.
// 	Password *string `json:"password,omitempty"`

// 	// The Customer's phone number.
// 	Phone *string `json:"phone,omitempty"`
// }

// // PostCustomersCustomerAddressesJSONBody defines parameters for PostCustomersCustomerAddresses.
// type PostCustomersCustomerAddressesJSONBody struct {
// 	// The Address to add to the Customer.
// 	Address interface{} `json:"address"`
// }

// // PostCustomersCustomerAddressesAddressJSONBody defines parameters for PostCustomersCustomerAddressesAddress.
// type PostCustomersCustomerAddressesAddressJSONBody interface{}

// // GetCustomersCustomerOrdersParams defines parameters for GetCustomersCustomerOrders.
// type GetCustomersCustomerOrdersParams struct {
// 	// Query used for searching orders.
// 	Q *string `form:"q,omitempty" json:"q,omitempty"`

// 	// Id of the order to search for.
// 	Id *string `form:"id,omitempty" json:"id,omitempty"`

// 	// Status to search for.
// 	Status *[]string `form:"status,omitempty" json:"status,omitempty"`

// 	// Fulfillment status to search for.
// 	FulfillmentStatus *[]string `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

// 	// Payment status to search for.
// 	PaymentStatus *[]string `form:"payment_status,omitempty" json:"payment_status,omitempty"`

// 	// Display id to search for.
// 	DisplayId *string `form:"display_id,omitempty" json:"display_id,omitempty"`

// 	// to search for.
// 	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

// 	// to search for.
// 	Email *string `form:"email,omitempty" json:"email,omitempty"`

// 	// to search for.
// 	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

// 	// The 3 character ISO currency code to set prices based on.
// 	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`

// 	// to search for.
// 	TaxRate *string `form:"tax_rate,omitempty" json:"tax_rate,omitempty"`

// 	// Date comparison for when resulting collections were created.
// 	CreatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"created_at,omitempty" json:"created_at,omitempty"`

// 	// Date comparison for when resulting collections were updated.
// 	UpdatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

// 	// Date comparison for when resulting collections were canceled.
// 	CanceledAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"canceled_at,omitempty" json:"canceled_at,omitempty"`

// 	// How many orders to return.
// 	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

// 	// The offset in the resulting orders.
// 	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

// 	// (Comma separated string) Which fields should be included in the resulting orders.
// 	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

// 	// (Comma separated string) Which relations should be expanded in the resulting orders.
// 	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`
// }

// // PostCustomersResetPasswordJSONBody defines parameters for PostCustomersResetPassword.
// type PostCustomersResetPasswordJSONBody struct {
// 	// The email of the customer.
// 	Email openapi_types.Email `json:"email"`

// 	// The Customer's password.
// 	Password string `json:"password"`

// 	// The reset password token
// 	Token string `json:"token"`
// }

// // PostCustomersCustomerPasswordTokenJSONBody defines parameters for PostCustomersCustomerPasswordToken.
// type PostCustomersCustomerPasswordTokenJSONBody struct {
// 	// The email of the customer.
// 	Email openapi_types.Email `json:"email"`
// }

// // GetOrdersParams defines parameters for GetOrders.
// type GetOrdersParams struct {
// 	// The display id given to the Order.
// 	DisplayId float32 `form:"display_id" json:"display_id"`

// 	// The email associated with this order.
// 	Email openapi_types.Email `form:"email" json:"email"`

// 	// The shipping address associated with this order.
// 	ShippingAddress *struct {
// 		// The postal code of the shipping address
// 		PostalCode *string `json:"postal_code,omitempty"`
// 	} `form:"shipping_address,omitempty" json:"shipping_address,omitempty"`
// }

// // GetProductsParams defines parameters for GetProducts.
// type GetProductsParams struct {
// 	// Query used for searching products by title, description, variant's title, variant's sku, and collection's title
// 	Q *string `form:"q,omitempty" json:"q,omitempty"`

// 	// product IDs to search for.
// 	Id *interface{} `form:"id,omitempty" json:"id,omitempty"`

// 	// Collection IDs to search for
// 	CollectionId *[]string `form:"collection_id,omitempty" json:"collection_id,omitempty"`

// 	// Tag IDs to search for
// 	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

// 	// title to search for.
// 	Title *string `form:"title,omitempty" json:"title,omitempty"`

// 	// description to search for.
// 	Description *string `form:"description,omitempty" json:"description,omitempty"`

// 	// handle to search for.
// 	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

// 	// Search for giftcards using is_giftcard=true.
// 	IsGiftcard *bool `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

// 	// type to search for.
// 	Type *string `form:"type,omitempty" json:"type,omitempty"`

// 	// Date comparison for when resulting products were created.
// 	CreatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"created_at,omitempty" json:"created_at,omitempty"`

// 	// Date comparison for when resulting products were updated.
// 	UpdatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

// 	// How many products to skip in the result.
// 	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

// 	// Limit the number of products returned.
// 	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

// 	// (Comma separated) Which fields should be expanded in each order of the result.
// 	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

// 	// (Comma separated) Which fields should be included in each order of the result.
// 	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
// }

// // PostProductsSearchParams defines parameters for PostProductsSearch.
// type PostProductsSearchParams struct {
// 	// The query to run the search with.
// 	Q string `form:"q" json:"q"`

// 	// How many products to skip in the result.
// 	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

// 	// Limit the number of products returned.
// 	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
// }

// // GetProductsProductParams defines parameters for GetProductsProduct.
// type GetProductsProductParams struct {
// 	// The ID of the customer's cart.
// 	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

// 	// The ID of the region the customer is using. This is helpful to ensure correct prices are retrieved for a region.
// 	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

// 	// The 3 character ISO currency code to set prices based on. This is helpful to ensure correct prices are retrieved for a currency.
// 	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`
// }

// // GetRegionsParams defines parameters for GetRegions.
// type GetRegionsParams struct {
// 	// How many regions to skip in the result.
// 	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

// 	// Limit the number of regions returned.
// 	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

// 	// Date comparison for when resulting regions were created.
// 	CreatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"created_at,omitempty" json:"created_at,omitempty"`

// 	// Date comparison for when resulting regions were updated.
// 	UpdatedAt *struct {
// 		// filter by dates greater than this date
// 		Gt *openapi_types.Date `json:"gt,omitempty"`

// 		// filter by dates greater than or equal to this date
// 		Gte *openapi_types.Date `json:"gte,omitempty"`

// 		// filter by dates less than this date
// 		Lt *openapi_types.Date `json:"lt,omitempty"`

// 		// filter by dates less than or equal to this date
// 		Lte *openapi_types.Date `json:"lte,omitempty"`
// 	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
// }

// // PostReturnsJSONBody defines parameters for PostReturns.
// type PostReturnsJSONBody struct {
// 	// The items to include in the Return.
// 	Items []struct {
// 		// The ID of the Line Item from the Order.
// 		ItemId string `json:"item_id"`

// 		// A note to add to the item returned.
// 		Note *string `json:"note,omitempty"`

// 		// The quantity to return.
// 		Quantity int `json:"quantity"`

// 		// The ID of the return reason.
// 		ReasonId *string `json:"reason_id,omitempty"`
// 	} `json:"items"`

// 	// The ID of the Order to create the Return from.
// 	OrderId string `json:"order_id"`

// 	// If the Return is to be handled by the store operator the Customer can choose a Return Shipping Method. Alternatvely the Customer can handle the Return themselves.
// 	ReturnShipping *struct {
// 		// The ID of the Shipping Option to create the Shipping Method from.
// 		OptionId string `json:"option_id"`
// 	} `json:"return_shipping,omitempty"`
// }

// // GetShippingOptionsParams defines parameters for GetShippingOptions.
// type GetShippingOptionsParams struct {
// 	// Whether return Shipping Options should be included. By default all Shipping Options are returned.
// 	IsReturn *bool `form:"is_return,omitempty" json:"is_return,omitempty"`

// 	// A comma separated list of Product ids to filter Shipping Options by.
// 	ProductIds *string `form:"product_ids,omitempty" json:"product_ids,omitempty"`

// 	// the Region to retrieve Shipping Options from.
// 	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`
// }

// // PostSwapsJSONBody defines parameters for PostSwaps.
// type PostSwapsJSONBody struct {
// 	// The items to exchange the returned items to.
// 	AdditionalItems []struct {
// 		// The quantity to send of the variant.
// 		Quantity int `json:"quantity"`

// 		// The ID of the Product Variant to send.
// 		VariantId string `json:"variant_id"`
// 	} `json:"additional_items"`

// 	// The ID of the Order to create the Swap for.
// 	OrderId string `json:"order_id"`

// 	// The items to include in the Return.
// 	ReturnItems []struct {
// 		// The ID of the Line Item from the Order.
// 		ItemId string `json:"item_id"`

// 		// The note to add to the item being swapped.
// 		Note *string `json:"note,omitempty"`

// 		// The quantity to swap.
// 		Quantity int `json:"quantity"`

// 		// The ID of the reason of this return.
// 		ReasonId *string `json:"reason_id,omitempty"`
// 	} `json:"return_items"`

// 	// The ID of the Shipping Option to create the Shipping Method from.
// 	ReturnShippingOption *string `json:"return_shipping_option,omitempty"`
// }

// // GetVariantsParams defines parameters for GetVariants.
// type GetVariantsParams struct {
// 	// A comma separated list of Product Variant ids to filter by.
// 	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

// 	// A comma separated list of Product Variant relations to load.
// 	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

// 	// How many product variants to skip in the result.
// 	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

// 	// Maximum number of Product Variants to return.
// 	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

// 	// product variant title to search for.
// 	Title *interface{} `form:"title,omitempty" json:"title,omitempty"`

// 	// Filter by available inventory quantity
// 	InventoryQuantity *interface{} `form:"inventory_quantity,omitempty" json:"inventory_quantity,omitempty"`
// }

// // GetVariantsVariantParams defines parameters for GetVariantsVariant.
// type GetVariantsVariantParams struct {
// 	// The id of the Cart to set prices based on.
// 	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

// 	// The id of the Region to set prices based on.
// 	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

// 	// The 3 character ISO currency code to set prices based on.
// 	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`
// }

// // PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
// type PostAuthJSONRequestBody PostAuthJSONBody

// // PostCartJSONRequestBody defines body for PostCart for application/json ContentType.
// type PostCartJSONRequestBody PostCartJSONBody

// // PostCartsCartJSONRequestBody defines body for PostCartsCart for application/json ContentType.
// type PostCartsCartJSONRequestBody PostCartsCartJSONBody

// // PostCartsCartLineItemsJSONRequestBody defines body for PostCartsCartLineItems for application/json ContentType.
// type PostCartsCartLineItemsJSONRequestBody PostCartsCartLineItemsJSONBody

// // PostCartsCartLineItemsItemJSONRequestBody defines body for PostCartsCartLineItemsItem for application/json ContentType.
// type PostCartsCartLineItemsItemJSONRequestBody PostCartsCartLineItemsItemJSONBody

// // PostCartsCartPaymentSessionJSONRequestBody defines body for PostCartsCartPaymentSession for application/json ContentType.
// type PostCartsCartPaymentSessionJSONRequestBody PostCartsCartPaymentSessionJSONBody

// // PostCartsCartPaymentSessionUpdateJSONRequestBody defines body for PostCartsCartPaymentSessionUpdate for application/json ContentType.
// type PostCartsCartPaymentSessionUpdateJSONRequestBody PostCartsCartPaymentSessionUpdateJSONBody

// // PostCartsCartShippingMethodJSONRequestBody defines body for PostCartsCartShippingMethod for application/json ContentType.
// type PostCartsCartShippingMethodJSONRequestBody PostCartsCartShippingMethodJSONBody

// // PostCustomersJSONRequestBody defines body for PostCustomers for application/json ContentType.
// type PostCustomersJSONRequestBody PostCustomersJSONBody

// // PostCustomersCustomerJSONRequestBody defines body for PostCustomersCustomer for application/json ContentType.
// type PostCustomersCustomerJSONRequestBody PostCustomersCustomerJSONBody

// // PostCustomersCustomerAddressesJSONRequestBody defines body for PostCustomersCustomerAddresses for application/json ContentType.
// type PostCustomersCustomerAddressesJSONRequestBody PostCustomersCustomerAddressesJSONBody

// // PostCustomersCustomerAddressesAddressJSONRequestBody defines body for PostCustomersCustomerAddressesAddress for application/json ContentType.
// type PostCustomersCustomerAddressesAddressJSONRequestBody PostCustomersCustomerAddressesAddressJSONBody

// // PostCustomersResetPasswordJSONRequestBody defines body for PostCustomersResetPassword for application/json ContentType.
// type PostCustomersResetPasswordJSONRequestBody PostCustomersResetPasswordJSONBody

// // PostCustomersCustomerPasswordTokenJSONRequestBody defines body for PostCustomersCustomerPasswordToken for application/json ContentType.
// type PostCustomersCustomerPasswordTokenJSONRequestBody PostCustomersCustomerPasswordTokenJSONBody

// // PostReturnsJSONRequestBody defines body for PostReturns for application/json ContentType.
// type PostReturnsJSONRequestBody PostReturnsJSONBody

// // PostSwapsJSONRequestBody defines body for PostSwaps for application/json ContentType.
// type PostSwapsJSONRequestBody PostSwapsJSONBody

// // ServerInterface represents all server handlers.
// type ServerInterface interface {
// 	// Customer Log out
// 	// (DELETE /auth)
// 	DeleteAuth(ctx echo.Context) error
// 	// Get Current Customer
// 	// (GET /auth)
// 	GetAuth(ctx echo.Context) error
// 	// Customer Login
// 	// (POST /auth)
// 	PostAuth(ctx echo.Context) error
// 	// Check if email exists
// 	// (GET /auth/{email})
// 	GetAuthEmail(ctx echo.Context, email openapi_types.Email) error
// 	// Create a Cart
// 	// (POST /carts)
// 	PostCart(ctx echo.Context) error
// 	// Get a Cart
// 	// (GET /carts/{id})
// 	GetCartsCart(ctx echo.Context, id string) error
// 	// Update a Cart
// 	// (POST /carts/{id})
// 	PostCartsCart(ctx echo.Context, id string) error
// 	// Complete a Cart
// 	// (POST /carts/{id}/complete)
// 	PostCartsCartComplete(ctx echo.Context, id string) error
// 	// Remove Discount
// 	// (DELETE /carts/{id}/discounts/{code})
// 	DeleteCartsCartDiscountsDiscount(ctx echo.Context, id string, code string) error
// 	// Add a Line Item
// 	// (POST /carts/{id}/line-items)
// 	PostCartsCartLineItems(ctx echo.Context, id string) error
// 	// Delete a Line Item
// 	// (DELETE /carts/{id}/line-items/{line_id})
// 	DeleteCartsCartLineItemsItem(ctx echo.Context, id string, lineId string) error
// 	// Update a Line Item
// 	// (POST /carts/{id}/line-items/{line_id})
// 	PostCartsCartLineItemsItem(ctx echo.Context, id string, lineId string) error
// 	// Select a Payment Session
// 	// (POST /carts/{id}/payment-session)
// 	PostCartsCartPaymentSession(ctx echo.Context, id string) error
// 	// Create Payment Sessions
// 	// (POST /carts/{id}/payment-sessions)
// 	PostCartsCartPaymentSessions(ctx echo.Context, id string) error
// 	// Delete a Payment Session
// 	// (DELETE /carts/{id}/payment-sessions/{provider_id})
// 	DeleteCartsCartPaymentSessionsSession(ctx echo.Context, id string, providerId string) error
// 	// Update a Payment Session
// 	// (POST /carts/{id}/payment-sessions/{provider_id})
// 	PostCartsCartPaymentSessionUpdate(ctx echo.Context, id string, providerId string) error
// 	// Refresh a Payment Session
// 	// (POST /carts/{id}/payment-sessions/{provider_id}/refresh)
// 	PostCartsCartPaymentSessionsSession(ctx echo.Context, id string, providerId string) error
// 	// Add a Shipping Method
// 	// (POST /carts/{id}/shipping-methods)
// 	PostCartsCartShippingMethod(ctx echo.Context, id string) error
// 	// Calculate Cart Taxes
// 	// (POST /carts/{id}/taxes)
// 	PostCartsCartTaxes(ctx echo.Context, id string) error
// 	// List Collections
// 	// (GET /collections)
// 	GetCollections(ctx echo.Context, params GetCollectionsParams) error
// 	// Get a Collection
// 	// (GET /collections/{id})
// 	GetCollectionsCollection(ctx echo.Context, id string) error
// 	// Create a Customer
// 	// (POST /customers)
// 	PostCustomers(ctx echo.Context) error
// 	// Get a Customer
// 	// (GET /customers/me)
// 	GetCustomersCustomer(ctx echo.Context) error
// 	// Update Customer
// 	// (POST /customers/me)
// 	PostCustomersCustomer(ctx echo.Context) error
// 	// Add a Shipping Address
// 	// (POST /customers/me/addresses)
// 	PostCustomersCustomerAddresses(ctx echo.Context) error
// 	// Delete an Address
// 	// (DELETE /customers/me/addresses/{address_id})
// 	DeleteCustomersCustomerAddressesAddress(ctx echo.Context, addressId string) error
// 	// Update a Shipping Address
// 	// (POST /customers/me/addresses/{address_id})
// 	PostCustomersCustomerAddressesAddress(ctx echo.Context, addressId string) error
// 	// List Orders
// 	// (GET /customers/me/orders)
// 	GetCustomersCustomerOrders(ctx echo.Context, params GetCustomersCustomerOrdersParams) error
// 	// Get Payment Methods
// 	// (GET /customers/me/payment-methods)
// 	GetCustomersCustomerPaymentMethods(ctx echo.Context) error
// 	// Reset Password
// 	// (POST /customers/password-reset)
// 	PostCustomersResetPassword(ctx echo.Context) error
// 	// Request Password Reset
// 	// (POST /customers/password-token)
// 	PostCustomersCustomerPasswordToken(ctx echo.Context) error
// 	// Get Gift Card by Code
// 	// (GET /gift-cards/{code})
// 	GetGiftCardsCode(ctx echo.Context, code string) error
// 	// Look Up an Order
// 	// (GET /orders)
// 	GetOrders(ctx echo.Context, params GetOrdersParams) error
// 	// Get by Cart ID
// 	// (GET /orders/cart/{cart_id})
// 	GetOrdersOrderCartId(ctx echo.Context, cartId string) error
// 	// Get an Order
// 	// (GET /orders/{id})
// 	GetOrdersOrder(ctx echo.Context, id string) error
// 	// List Products
// 	// (GET /products)
// 	GetProducts(ctx echo.Context, params GetProductsParams) error
// 	// Search Products
// 	// (POST /products/search)
// 	PostProductsSearch(ctx echo.Context, params PostProductsSearchParams) error
// 	// Get a Product
// 	// (GET /products/{id})
// 	GetProductsProduct(ctx echo.Context, id string, params GetProductsProductParams) error
// 	// List Regions
// 	// (GET /regions)
// 	GetRegions(ctx echo.Context, params GetRegionsParams) error
// 	// Get a Region
// 	// (GET /regions/{id})
// 	GetRegionsRegion(ctx echo.Context, id string) error
// 	// List Return Reasons
// 	// (GET /return-reasons)
// 	GetReturnReasons(ctx echo.Context) error
// 	// Get a Return Reason
// 	// (GET /return-reasons/{id})
// 	GetReturnReasonsReason(ctx echo.Context, id string) error
// 	// Create Return
// 	// (POST /returns)
// 	PostReturns(ctx echo.Context) error
// 	// Get Shipping Options
// 	// (GET /shipping-options)
// 	GetShippingOptions(ctx echo.Context, params GetShippingOptionsParams) error
// 	// List for Cart
// 	// (GET /shipping-options/{cart_id})
// 	GetShippingOptionsCartId(ctx echo.Context, cartId string) error
// 	// Create a Swap
// 	// (POST /swaps)
// 	PostSwaps(ctx echo.Context) error
// 	// Get by Cart ID
// 	// (GET /swaps/{cart_id})
// 	GetSwapsSwapCartId(ctx echo.Context, cartId string) error
// 	// Get Product Variants
// 	// (GET /variants)
// 	GetVariants(ctx echo.Context, params GetVariantsParams) error
// 	// Get a Product Variant
// 	// (GET /variants/{variant_id})
// 	GetVariantsVariant(ctx echo.Context, variantId string, params GetVariantsVariantParams) error
// }

// // ServerInterfaceWrapper converts echo contexts to parameters.
// type ServerInterfaceWrapper struct {
// 	Handler ServerInterface
// }

// // DeleteAuth converts echo context to params.
// func (w *ServerInterfaceWrapper) DeleteAuth(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.DeleteAuth(ctx)
// 	return err
// }

// // GetAuth converts echo context to params.
// func (w *ServerInterfaceWrapper) GetAuth(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetAuth(ctx)
// 	return err
// }

// // PostAuth converts echo context to params.
// func (w *ServerInterfaceWrapper) PostAuth(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostAuth(ctx)
// 	return err
// }

// // GetAuthEmail converts echo context to params.
// func (w *ServerInterfaceWrapper) GetAuthEmail(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "email" -------------
// 	var email openapi_types.Email

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "email", runtime.ParamLocationPath, ctx.Param("email"), &email)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetAuthEmail(ctx, email)
// 	return err
// }

// // PostCart converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCart(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCart(ctx)
// 	return err
// }

// // GetCartsCart converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCartsCart(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCartsCart(ctx, id)
// 	return err
// }

// // PostCartsCart converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCart(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCart(ctx, id)
// 	return err
// }

// // PostCartsCartComplete converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartComplete(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartComplete(ctx, id)
// 	return err
// }

// // DeleteCartsCartDiscountsDiscount converts echo context to params.
// func (w *ServerInterfaceWrapper) DeleteCartsCartDiscountsDiscount(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "code" -------------
// 	var code string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.DeleteCartsCartDiscountsDiscount(ctx, id, code)
// 	return err
// }

// // PostCartsCartLineItems converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartLineItems(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartLineItems(ctx, id)
// 	return err
// }

// // DeleteCartsCartLineItemsItem converts echo context to params.
// func (w *ServerInterfaceWrapper) DeleteCartsCartLineItemsItem(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "line_id" -------------
// 	var lineId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "line_id", runtime.ParamLocationPath, ctx.Param("line_id"), &lineId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter line_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.DeleteCartsCartLineItemsItem(ctx, id, lineId)
// 	return err
// }

// // PostCartsCartLineItemsItem converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartLineItemsItem(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "line_id" -------------
// 	var lineId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "line_id", runtime.ParamLocationPath, ctx.Param("line_id"), &lineId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter line_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartLineItemsItem(ctx, id, lineId)
// 	return err
// }

// // PostCartsCartPaymentSession converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartPaymentSession(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartPaymentSession(ctx, id)
// 	return err
// }

// // PostCartsCartPaymentSessions converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartPaymentSessions(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartPaymentSessions(ctx, id)
// 	return err
// }

// // DeleteCartsCartPaymentSessionsSession converts echo context to params.
// func (w *ServerInterfaceWrapper) DeleteCartsCartPaymentSessionsSession(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "provider_id" -------------
// 	var providerId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, ctx.Param("provider_id"), &providerId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.DeleteCartsCartPaymentSessionsSession(ctx, id, providerId)
// 	return err
// }

// // PostCartsCartPaymentSessionUpdate converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartPaymentSessionUpdate(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "provider_id" -------------
// 	var providerId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, ctx.Param("provider_id"), &providerId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartPaymentSessionUpdate(ctx, id, providerId)
// 	return err
// }

// // PostCartsCartPaymentSessionsSession converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartPaymentSessionsSession(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Path parameter "provider_id" -------------
// 	var providerId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, ctx.Param("provider_id"), &providerId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartPaymentSessionsSession(ctx, id, providerId)
// 	return err
// }

// // PostCartsCartShippingMethod converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartShippingMethod(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartShippingMethod(ctx, id)
// 	return err
// }

// // PostCartsCartTaxes converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCartsCartTaxes(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCartsCartTaxes(ctx, id)
// 	return err
// }

// // GetCollections converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCollections(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetCollectionsParams
// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// ------------- Optional query parameter "created_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "updated_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCollections(ctx, params)
// 	return err
// }

// // GetCollectionsCollection converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCollectionsCollection(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCollectionsCollection(ctx, id)
// 	return err
// }

// // PostCustomers converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomers(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomers(ctx)
// 	return err
// }

// // GetCustomersCustomer converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCustomersCustomer(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCustomersCustomer(ctx)
// 	return err
// }

// // PostCustomersCustomer converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomersCustomer(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomersCustomer(ctx)
// 	return err
// }

// // PostCustomersCustomerAddresses converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomersCustomerAddresses(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomersCustomerAddresses(ctx)
// 	return err
// }

// // DeleteCustomersCustomerAddressesAddress converts echo context to params.
// func (w *ServerInterfaceWrapper) DeleteCustomersCustomerAddressesAddress(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "address_id" -------------
// 	var addressId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "address_id", runtime.ParamLocationPath, ctx.Param("address_id"), &addressId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address_id: %s", err))
// 	}

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.DeleteCustomersCustomerAddressesAddress(ctx, addressId)
// 	return err
// }

// // PostCustomersCustomerAddressesAddress converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomersCustomerAddressesAddress(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "address_id" -------------
// 	var addressId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "address_id", runtime.ParamLocationPath, ctx.Param("address_id"), &addressId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address_id: %s", err))
// 	}

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomersCustomerAddressesAddress(ctx, addressId)
// 	return err
// }

// // GetCustomersCustomerOrders converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCustomersCustomerOrders(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetCustomersCustomerOrdersParams
// 	// ------------- Optional query parameter "q" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
// 	}

// 	// ------------- Optional query parameter "id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Optional query parameter "status" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
// 	}

// 	// ------------- Optional query parameter "fulfillment_status" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "fulfillment_status", ctx.QueryParams(), &params.FulfillmentStatus)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_status: %s", err))
// 	}

// 	// ------------- Optional query parameter "payment_status" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "payment_status", ctx.QueryParams(), &params.PaymentStatus)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_status: %s", err))
// 	}

// 	// ------------- Optional query parameter "display_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "display_id", ctx.QueryParams(), &params.DisplayId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter display_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "cart_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "cart_id", ctx.QueryParams(), &params.CartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "email" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
// 	}

// 	// ------------- Optional query parameter "region_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "region_id", ctx.QueryParams(), &params.RegionId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "currency_code" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "currency_code", ctx.QueryParams(), &params.CurrencyCode)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency_code: %s", err))
// 	}

// 	// ------------- Optional query parameter "tax_rate" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "tax_rate", ctx.QueryParams(), &params.TaxRate)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tax_rate: %s", err))
// 	}

// 	// ------------- Optional query parameter "created_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "updated_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "canceled_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "canceled_at", ctx.QueryParams(), &params.CanceledAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter canceled_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "fields" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
// 	}

// 	// ------------- Optional query parameter "expand" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCustomersCustomerOrders(ctx, params)
// 	return err
// }

// // GetCustomersCustomerPaymentMethods converts echo context to params.
// func (w *ServerInterfaceWrapper) GetCustomersCustomerPaymentMethods(ctx echo.Context) error {
// 	var err error

// 	ctx.Set(Cookie_authScopes, []string{""})

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetCustomersCustomerPaymentMethods(ctx)
// 	return err
// }

// // PostCustomersResetPassword converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomersResetPassword(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomersResetPassword(ctx)
// 	return err
// }

// // PostCustomersCustomerPasswordToken converts echo context to params.
// func (w *ServerInterfaceWrapper) PostCustomersCustomerPasswordToken(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostCustomersCustomerPasswordToken(ctx)
// 	return err
// }

// // GetGiftCardsCode converts echo context to params.
// func (w *ServerInterfaceWrapper) GetGiftCardsCode(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "code" -------------
// 	var code string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetGiftCardsCode(ctx, code)
// 	return err
// }

// // GetOrders converts echo context to params.
// func (w *ServerInterfaceWrapper) GetOrders(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetOrdersParams
// 	// ------------- Required query parameter "display_id" -------------

// 	err = runtime.BindQueryParameter("form", true, true, "display_id", ctx.QueryParams(), &params.DisplayId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter display_id: %s", err))
// 	}

// 	// ------------- Required query parameter "email" -------------

// 	err = runtime.BindQueryParameter("form", false, true, "email", ctx.QueryParams(), &params.Email)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
// 	}

// 	// ------------- Optional query parameter "shipping_address" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "shipping_address", ctx.QueryParams(), &params.ShippingAddress)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shipping_address: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetOrders(ctx, params)
// 	return err
// }

// // GetOrdersOrderCartId converts echo context to params.
// func (w *ServerInterfaceWrapper) GetOrdersOrderCartId(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "cart_id" -------------
// 	var cartId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "cart_id", runtime.ParamLocationPath, ctx.Param("cart_id"), &cartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetOrdersOrderCartId(ctx, cartId)
// 	return err
// }

// // GetOrdersOrder converts echo context to params.
// func (w *ServerInterfaceWrapper) GetOrdersOrder(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetOrdersOrder(ctx, id)
// 	return err
// }

// // GetProducts converts echo context to params.
// func (w *ServerInterfaceWrapper) GetProducts(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetProductsParams
// 	// ------------- Optional query parameter "q" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
// 	}

// 	// ------------- Optional query parameter "id" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// ------------- Optional query parameter "collection_id" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "collection_id", ctx.QueryParams(), &params.CollectionId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "tags" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
// 	}

// 	// ------------- Optional query parameter "title" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
// 	}

// 	// ------------- Optional query parameter "description" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
// 	}

// 	// ------------- Optional query parameter "handle" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "handle", ctx.QueryParams(), &params.Handle)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handle: %s", err))
// 	}

// 	// ------------- Optional query parameter "is_giftcard" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "is_giftcard", ctx.QueryParams(), &params.IsGiftcard)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_giftcard: %s", err))
// 	}

// 	// ------------- Optional query parameter "type" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
// 	}

// 	// ------------- Optional query parameter "created_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "updated_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// ------------- Optional query parameter "expand" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
// 	}

// 	// ------------- Optional query parameter "fields" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetProducts(ctx, params)
// 	return err
// }

// // PostProductsSearch converts echo context to params.
// func (w *ServerInterfaceWrapper) PostProductsSearch(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params PostProductsSearchParams
// 	// ------------- Required query parameter "q" -------------

// 	err = runtime.BindQueryParameter("form", true, true, "q", ctx.QueryParams(), &params.Q)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
// 	}

// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostProductsSearch(ctx, params)
// 	return err
// }

// // GetProductsProduct converts echo context to params.
// func (w *ServerInterfaceWrapper) GetProductsProduct(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetProductsProductParams
// 	// ------------- Optional query parameter "cart_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "cart_id", ctx.QueryParams(), &params.CartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "region_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "region_id", ctx.QueryParams(), &params.RegionId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "currency_code" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "currency_code", ctx.QueryParams(), &params.CurrencyCode)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency_code: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetProductsProduct(ctx, id, params)
// 	return err
// }

// // GetRegions converts echo context to params.
// func (w *ServerInterfaceWrapper) GetRegions(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetRegionsParams
// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// ------------- Optional query parameter "created_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
// 	}

// 	// ------------- Optional query parameter "updated_at" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetRegions(ctx, params)
// 	return err
// }

// // GetRegionsRegion converts echo context to params.
// func (w *ServerInterfaceWrapper) GetRegionsRegion(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetRegionsRegion(ctx, id)
// 	return err
// }

// // GetReturnReasons converts echo context to params.
// func (w *ServerInterfaceWrapper) GetReturnReasons(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetReturnReasons(ctx)
// 	return err
// }

// // GetReturnReasonsReason converts echo context to params.
// func (w *ServerInterfaceWrapper) GetReturnReasonsReason(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "id" -------------
// 	var id string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetReturnReasonsReason(ctx, id)
// 	return err
// }

// // PostReturns converts echo context to params.
// func (w *ServerInterfaceWrapper) PostReturns(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostReturns(ctx)
// 	return err
// }

// // GetShippingOptions converts echo context to params.
// func (w *ServerInterfaceWrapper) GetShippingOptions(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetShippingOptionsParams
// 	// ------------- Optional query parameter "is_return" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "is_return", ctx.QueryParams(), &params.IsReturn)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_return: %s", err))
// 	}

// 	// ------------- Optional query parameter "product_ids" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "product_ids", ctx.QueryParams(), &params.ProductIds)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_ids: %s", err))
// 	}

// 	// ------------- Optional query parameter "region_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "region_id", ctx.QueryParams(), &params.RegionId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetShippingOptions(ctx, params)
// 	return err
// }

// // GetShippingOptionsCartId converts echo context to params.
// func (w *ServerInterfaceWrapper) GetShippingOptionsCartId(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "cart_id" -------------
// 	var cartId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "cart_id", runtime.ParamLocationPath, ctx.Param("cart_id"), &cartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetShippingOptionsCartId(ctx, cartId)
// 	return err
// }

// // PostSwaps converts echo context to params.
// func (w *ServerInterfaceWrapper) PostSwaps(ctx echo.Context) error {
// 	var err error

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.PostSwaps(ctx)
// 	return err
// }

// // GetSwapsSwapCartId converts echo context to params.
// func (w *ServerInterfaceWrapper) GetSwapsSwapCartId(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "cart_id" -------------
// 	var cartId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "cart_id", runtime.ParamLocationPath, ctx.Param("cart_id"), &cartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetSwapsSwapCartId(ctx, cartId)
// 	return err
// }

// // GetVariants converts echo context to params.
// func (w *ServerInterfaceWrapper) GetVariants(ctx echo.Context) error {
// 	var err error

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetVariantsParams
// 	// ------------- Optional query parameter "ids" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
// 	}

// 	// ------------- Optional query parameter "expand" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
// 	}

// 	// ------------- Optional query parameter "offset" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
// 	}

// 	// ------------- Optional query parameter "limit" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
// 	}

// 	// ------------- Optional query parameter "title" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "title", ctx.QueryParams(), &params.Title)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
// 	}

// 	// ------------- Optional query parameter "inventory_quantity" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "inventory_quantity", ctx.QueryParams(), &params.InventoryQuantity)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inventory_quantity: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetVariants(ctx, params)
// 	return err
// }

// // GetVariantsVariant converts echo context to params.
// func (w *ServerInterfaceWrapper) GetVariantsVariant(ctx echo.Context) error {
// 	var err error
// 	// ------------- Path parameter "variant_id" -------------
// 	var variantId string

// 	err = runtime.BindStyledParameterWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, ctx.Param("variant_id"), &variantId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter variant_id: %s", err))
// 	}

// 	// Parameter object where we will unmarshal all parameters from the context
// 	var params GetVariantsVariantParams
// 	// ------------- Optional query parameter "cart_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "cart_id", ctx.QueryParams(), &params.CartId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "region_id" -------------

// 	err = runtime.BindQueryParameter("form", true, false, "region_id", ctx.QueryParams(), &params.RegionId)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
// 	}

// 	// ------------- Optional query parameter "currency_code" -------------

// 	err = runtime.BindQueryParameter("form", false, false, "currency_code", ctx.QueryParams(), &params.CurrencyCode)
// 	if err != nil {
// 		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency_code: %s", err))
// 	}

// 	// Invoke the callback with all the unmarshalled arguments
// 	err = w.Handler.GetVariantsVariant(ctx, variantId, params)
// 	return err
// }

// // This is a simple interface which specifies echo.Route addition functions which
// // are present on both echo.Echo and echo.Group, since we want to allow using
// // either of them for path registration
// type EchoRouter interface {
// 	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// 	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
// }

// // RegisterHandlers adds each server route to the EchoRouter.
// func RegisterHandlers(router EchoRouter, si ServerInterface) {
// 	RegisterHandlersWithBaseURL(router, si, "")
// }

// // Registers handlers, and prepends BaseURL to the paths, so that the paths
// // can be served under a prefix.
// func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

// 	wrapper := ServerInterfaceWrapper{
// 		Handler: si,
// 	}

// 	router.DELETE(baseURL+"/auth", wrapper.DeleteAuth)
// 	router.GET(baseURL+"/auth", wrapper.GetAuth)
// 	router.POST(baseURL+"/auth", wrapper.PostAuth)
// 	router.GET(baseURL+"/auth/:email", wrapper.GetAuthEmail)
// 	router.POST(baseURL+"/carts", wrapper.PostCart)
// 	router.GET(baseURL+"/carts/:id", wrapper.GetCartsCart)
// 	router.POST(baseURL+"/carts/:id", wrapper.PostCartsCart)
// 	router.POST(baseURL+"/carts/:id/complete", wrapper.PostCartsCartComplete)
// 	router.DELETE(baseURL+"/carts/:id/discounts/:code", wrapper.DeleteCartsCartDiscountsDiscount)
// 	router.POST(baseURL+"/carts/:id/line-items", wrapper.PostCartsCartLineItems)
// 	router.DELETE(baseURL+"/carts/:id/line-items/:line_id", wrapper.DeleteCartsCartLineItemsItem)
// 	router.POST(baseURL+"/carts/:id/line-items/:line_id", wrapper.PostCartsCartLineItemsItem)
// 	router.POST(baseURL+"/carts/:id/payment-session", wrapper.PostCartsCartPaymentSession)
// 	router.POST(baseURL+"/carts/:id/payment-sessions", wrapper.PostCartsCartPaymentSessions)
// 	router.DELETE(baseURL+"/carts/:id/payment-sessions/:provider_id", wrapper.DeleteCartsCartPaymentSessionsSession)
// 	router.POST(baseURL+"/carts/:id/payment-sessions/:provider_id", wrapper.PostCartsCartPaymentSessionUpdate)
// 	router.POST(baseURL+"/carts/:id/payment-sessions/:provider_id/refresh", wrapper.PostCartsCartPaymentSessionsSession)
// 	router.POST(baseURL+"/carts/:id/shipping-methods", wrapper.PostCartsCartShippingMethod)
// 	router.POST(baseURL+"/carts/:id/taxes", wrapper.PostCartsCartTaxes)
// 	router.GET(baseURL+"/collections", wrapper.GetCollections)
// 	router.GET(baseURL+"/collections/:id", wrapper.GetCollectionsCollection)
// 	router.POST(baseURL+"/customers", wrapper.PostCustomers)
// 	router.GET(baseURL+"/customers/me", wrapper.GetCustomersCustomer)
// 	router.POST(baseURL+"/customers/me", wrapper.PostCustomersCustomer)
// 	router.POST(baseURL+"/customers/me/addresses", wrapper.PostCustomersCustomerAddresses)
// 	router.DELETE(baseURL+"/customers/me/addresses/:address_id", wrapper.DeleteCustomersCustomerAddressesAddress)
// 	router.POST(baseURL+"/customers/me/addresses/:address_id", wrapper.PostCustomersCustomerAddressesAddress)
// 	router.GET(baseURL+"/customers/me/orders", wrapper.GetCustomersCustomerOrders)
// 	router.GET(baseURL+"/customers/me/payment-methods", wrapper.GetCustomersCustomerPaymentMethods)
// 	router.POST(baseURL+"/customers/password-reset", wrapper.PostCustomersResetPassword)
// 	router.POST(baseURL+"/customers/password-token", wrapper.PostCustomersCustomerPasswordToken)
// 	router.GET(baseURL+"/gift-cards/:code", wrapper.GetGiftCardsCode)
// 	router.GET(baseURL+"/orders", wrapper.GetOrders)
// 	router.GET(baseURL+"/orders/cart/:cart_id", wrapper.GetOrdersOrderCartId)
// 	router.GET(baseURL+"/orders/:id", wrapper.GetOrdersOrder)
// 	router.GET(baseURL+"/products", wrapper.GetProducts)
// 	router.POST(baseURL+"/products/search", wrapper.PostProductsSearch)
// 	router.GET(baseURL+"/products/:id", wrapper.GetProductsProduct)
// 	router.GET(baseURL+"/regions", wrapper.GetRegions)
// 	router.GET(baseURL+"/regions/:id", wrapper.GetRegionsRegion)
// 	router.GET(baseURL+"/return-reasons", wrapper.GetReturnReasons)
// 	router.GET(baseURL+"/return-reasons/:id", wrapper.GetReturnReasonsReason)
// 	router.POST(baseURL+"/returns", wrapper.PostReturns)
// 	router.GET(baseURL+"/shipping-options", wrapper.GetShippingOptions)
// 	router.GET(baseURL+"/shipping-options/:cart_id", wrapper.GetShippingOptionsCartId)
// 	router.POST(baseURL+"/swaps", wrapper.PostSwaps)
// 	router.GET(baseURL+"/swaps/:cart_id", wrapper.GetSwapsSwapCartId)
// 	router.GET(baseURL+"/variants", wrapper.GetVariants)
// 	router.GET(baseURL+"/variants/:variant_id", wrapper.GetVariantsVariant)

// }

// // Base64 encoded, gzipped, json marshaled Swagger object
// var swaggerSpec = []string{

// 	"H4sIAAAAAAAC/+z9eVPbyLo4jr+V/vncX2VOFZgtIYFbpz6XACEkISGYyTKTlGmktt0nsuTplgDPVN77",
// 	"t/rpRS2ptRkTHOLzx5xg9d5PP/vyT8eLxpMoJGHMO7v/dMgNHk8CAv/2cYwvMSd9wljExC88GY8xm3Z2",
// 	"OwfqGzqEbyudKxwkRLTxIp90djt4QlW/lc6YcI6H4te9EMGPKPK8hBEfXY9oQNAI8xENh2iCOb+OmN9Z",
// 	"6cTTieiQW8P37ysdnwxwEsTOVclPpYtKwm9hdB26F6Y+2gtkxO+ma8n2Fkuh4RUOqN/HbJiMSehc07Fs",
// 	"g/ZUm+Li0lV4mMXdOIpxgMYJj9ElQT4Z0JD49irIzYR4MfH7PMYxySxEHFfVIsS1VS1gQBmP+yEeE7MA",
// 	"jHjMaDhMV2BPBrOPkyCmk0BdEs9OfaI+ymm5Pa9u/uctl7Bi9z+g3IuSMDa9OYlRHCF/GuIx9dIxwiju",
// 	"4yCIronf+f7VBoZTFl1Rn/iIkb8SIkaJ/CnyojDGNOQSQHgXnQZEvABvRLxvKB4RJFaDcCj6xWwKP6kR",
// 	"4JisCV139DaK0Z78XHVFs+3v+0oBcFxr+N20QT3R5g6A9ftKhxE+iUIusczj9fV0JeKMSRiLf+LJJKAe",
// 	"jmkUrv2XR2EeO2VAYPefzv8wMujsdv61liK0Nd1+zfE+3HBbOUq+ffZOa7sX718cBvdGZAw7iELybgCv",
// 	"wTWMbMfX9OqrWxWW+vW7xJ3cY3QiDrWz29kPqEFIKGIo/1S/r3SezHg7Gm/XHkoewTvwe3X/TGsHTm4M",
// 	"Gzkk7ngxtUOVPLHsNTe43OJV9Qi7Ikw9R9ilFzFGvLjvMeKTMKY44Lk7islNvDYJMIXbSRegjgyeO07i",
// 	"UcTo3/Bo1T6KH9RrVljYsbzfOWHIjwhHYRQjckN5LADKrBLZq7QuSaHHtiBmkXT3SCsuhHlN4xES3dD5",
// 	"Ye8c4YAR7E/larlF5/1ETmzB5C1vT5PfM0VPDvPAmkPIrU+hnLE5T4mQoGCDgAJ2h7PAYRSPCNPfu+hz",
// 	"lKAxnhbpl2wvfpho2njsk/EkiknoTVdfk6l1fu8TwqZnSRgStifP+IwAqfQP53yeNo1SyHgQJaE/y0mm",
// 	"R3YYxjSeyi1TH22gayzhGsbOElj50+13JIj/CzFWupvEfoP3+7Kp3H/as4tOBMkPoiGiIQKWzcJygIiw",
// 	"7zPCJTHIjLgXIvVNwMyERRPCYkrsTv0NRzf5CQU0JGgjs6eNx4+3ttBrMh4ThvajhMXFna2YsTdrxt7M",
// 	"jN1LaEzQ1vaOa0iPxtPiaPvi18wYURKP0BGJBgNGpleUXDsHi8YTHLrGkx+Q4Ikz4+558INjpCSMmWOk",
// 	"PaQ+oejyv8SLu2jvCtMAXwYE0YF68AE8EXShml6I2yc3Exz6GWlIjmBN15e4KD+nQECbyBthhr2YMHTc",
// 	"eyeRcCQn1CuiIRKsEUOeYBvsbfIY/owJC3FwEHkOmOoRISUEQHYGMDwAV8KCzm5nFMcTvru2RsLuNf1G",
// 	"J8SnuBux4Zr4a+24966/tbG9vbrRx8FkhFc3//VuMKAexUEw7WPO6TAkPmyuTwIyBkn5u+vUGcGC8uPY",
// 	"fQi+wFUSj9Ix+TsKCcKxEIC9kTp5HiXMI4Bu1GBiE4OIjcWYgqciq6Kv884THkdjwhyXXnHFqlPhjmlM",
// 	"xtwJP6qHBiAXPKgfMGN4ai+tT/3ikMcHBhD00PGIco0i0CUJonDIURxlYMJLeH9942izd7S1/urZ/rMn",
// 	"vcd7T/Zfnmz2Nt72Nl0H5JOAzO161GDNryeVaouzvxDfHK+bhZFrqOpT1GjXHkn8Jk7r2R/7Ox96G58+",
// 	"HG483jk5ern56un7Xu+la5IAly73DXat9iMNgjF3DTUmMdZCWoESRPBvHKBvZLoKQiYa44liT3yfqq8+",
// 	"iTENMrv6Rwignd3O9YgKudIBh5NRFDrWfyp+Rm+T8SVh9oAb2xubzza3Hm9tPX62vunYyCTiMQ5K0Nwp",
// 	"fET74qM16NPN9Z0t11iCjQo910D6i326r0kYJ963qet8k4k/P7yjBmsK2OLYaSzB1QDezaoe8thX0Cc+",
// 	"CEyAmWORZ2TCCBd4FWGUcCABQMKzvMElDQIaDvsWY1HFalnT5no68ZA4KdVOv6FHHB0flDykl8+ebH0+",
// 	"/bzzfOfxsydPDz7vbHw++lhG1W+HeMRhSJqgh2pBFQTPeFMysfpo8C/MA9N6OBSyW5D4BNFwEKGAfiPo",
// 	"+FTIdHBBeEhCQP7Wc6STzm5nd1ewZqJNH9qolzHG4VkSilWuPe1u7nQ3nQ92YSlogeyhWYhqcb9VhPHc",
// 	"IolFSPzZ6J+vhPA+KAzdK5C6xGiAdGN7x8/W1y3tb0yGhNnj8lZ8j+nVnPHRXdowPmSMacle4RPCnEce",
// 	"xUYg18/QPlY5iONIh3QQ9z3M/H6Mbxqdq+ghxve5mg7fkAxNdR6xNU+rOZoP3O7y0m7Nb8+sqs31lb5K",
// 	"zGLHi8QstmjD9vmLTx9Pj54cfj58tvFpe8vNyRkVSv8bcchrZzj0o3EwRUMSEgZw8o1MBQr2URwBAqdh",
// 	"QpQcBdRBHFE0QFiicxqCOCV+GWAaJIx0a2WpNwSzEI0jRtAouhbzJFxOYa1XrKMoYfmRx7tj4icc/5d3",
// 	"vWi8hv0rHHrEX7vE3jcS+msTPBUi1Fp0RZiQhP9lDboqDsElWpXdazmQQI9y+KhiHAIakr5o6YKJ+2Nm",
// 	"5bnVLV43S3v0U63NzLhfDQWo31ICNcb+eillL0p9h0cl7hLri828sAmeKilm/8nHx5t/vP387PHmxubj",
// 	"o6enT852qublhHMqNX4NDs80L47AK9ePdCvNfKAoNDi9Mfw5VpGHQkYGSeiLA+rjMVBK57LkNxSPcAws",
// 	"3aV4IaJnVif4bNNNW3XberyvJtId9HOMmC94xQKRo1xhJ44YiRMWSliqphaMDNUV5pG7/NKENZMt6xkz",
// 	"2a4UXOXnIglgZCgAdOPoyYfN7fOdl88+r588fvX2cOvz0d7jIxeAchwQ3vdGOAxJ4NobNECqQZMtZkas",
// 	"32mmeemGs6s4PkjlBcrz99t17nNEJ5PZhLd81/JFqoZzFd/M7GMSjyKf10ytWoklSBLd+vXnJnS9ftOk",
// 	"CT+mG2c0HevuB8+Ty4oh9VdbXsxx6M5Rm3KnMb6pRQJNMVHZEkswnfzFtp/of62U83+iE6CtMBl3dv+0",
// 	"uvBrPBE9GR7EfUCCnZSSBDT81lnpeAGm487XxdXn7Muzyylz4ESrTAz7Sp2fMjlZLY5P+STA0xLd4rll",
// 	"EAAXIDwR3ZlAL2gQMaS6Z8hF5zjGwbSpqtSaooAhNtZ3XKPwyGU0ur1hg/4chg2x/6272T/+oQewNeMB",
// 	"lMNqKN5UIJjhLNjSECWTidpzDljP9958dgFrmIwrTGhhMiaMejhIz1m8B+ugM9NsPVv/MSer1jXjyS4c",
// 	"UyeZG8Ggauh1Mjiz83ywkL8SyogviIbELfqNWUCgoG4lizC/WvhZYeAiilYfQMHImBCsHWhaf8nj53II",
// 	"3HK9dQODarzs4STcv+sH/nhz4+m/9ryYXhE4uBIUJpXZvC+YjMIS/jz8dHp4dnxy+PZ8781XdBARntkU",
// 	"mjDqEW5U4pJTUZNcRlFAcFiNJ64ZjWMSSuRg7J3mCiz3jB46iIIAMyczOh1fRmXcGXwzqiEa+uDCVHE5",
// 	"/1M+RT/E4kBLMBF8m8+EudegIF/tM78adcD2G0iPMP8I9JdKxX7G8mSa/XjDk6Xnz9mg5mGBuleryv2a",
// 	"HSo08NaZaxV7vc69yoyfG3TQzqo/ZFEy4dWjItko6y2ROkhUUknZdTaNqLFTwSAukXSEeR97XqqKUnLU",
// 	"AAec5GWojyMCboeZbYwwRzhEahAUMRRGsRPL/ghjWYX7Q7NrXkB3CBBE22nRZZfGZpZQafxa2FhKfDRy",
// 	"hwytBAvc1mUjrzwi7fZf7D7bA7JIQv4A7lnat6mvxHoZ8mooYoG8qi+2FVtih2ZEVqKyIve5EB4ANWiY",
// 	"S426RLxGyZfZWCMHAX63bnf3S3nrsLQ8JweuHrJJSzPqvWHUCr1Ahs/PgXy62Q/Hp06zlRA3+kIkKrM3",
// 	"iQYgMylYxIy4nQmaQ6U16WxILh1gwfFcUYpQh3SkLqgE2aXsj3FQqUZ2xmfEtsBBGIKUmZSRXsjQExaN",
// 	"IwWLk4RNIk4c7vFu4XwPJSH9KyFZidxMvioVGtc0CMT8ILBdTnMutxGsa5rpmfWxXz847u0v5YucfBH6",
// 	"vHRq0Sk7mbkTAQthhAQBARYebuX2yFWPX0Sr4kt/fePF+ufD3snHjfWTo5cfX73+o3dwcPJ2/cNb5yS8",
// 	"71MukIVjNpuHNwFWgoe/JCREul9XfIN/maVxsfcwinNPQTyEDPZVkoOD/ed9HerqeAmDAA8z6gg6QDoW",
// 	"EtGQxzj0CNeoOXMflyR1s+mi4y7pwlsKyTUPSBwTlu6h0ULv0VWEkTDu20iqCm+bdsWupQqLgwxmyxyl",
// 	"9YrRgEXjLjo36AcH13jKZUi3ukQ3tlHg2kbNIfW3JQTzTH5ENLRe40Hu9uEN1muaW7BtWSV2E6aNJQFp",
// 	"emF9aKw61V/VWRIQeV/D6IqwUOoRLskIX9EoYfpNHDjvgyUGe3x4vbP98sOnp28fb+wcbu2/euqkCjwW",
// 	"L3pW3NgaI94ne7HSSTgekn5R/bG+4rbkXBJ53HRMMnyCQaB68+YGnjjt1nLegI5pybbH+IaOk3FhTsk0",
// 	"lp657SngmlcF0ycMx07zzYH6kr1YloRie/E1IWEGuk63Pm+fPD4439h8ubV+8qTXVE9skQKLnbMAOMfI",
// 	"2Zgu+4gKO3gZBb58IOI7z76bUXSNcPqwwJ0p8JJA8t4jEmaZvH3l/5ELdQyCyCs5P1Doe9GEOPArH0VJ",
// 	"4Gt2LbI9EKR3hMRH4kTSE9ZfXAECktg48RcnyiijG2U4Wa36B/iT+y5/ydWRhnr8GfyxTedWIWm/MM+a",
// 	"mc9x56OIxcj6Nc8s5cQCdEqYR8J4Fj4VHpeDWW1Nbe6N10o9hwoUbjoheZq6op/ExYDeEP9Cu7Qozhge",
// 	"FyN+4hEVay/E/MspwgjaK++mFXQxkWeOh0SOkf4t+8vHGjF0MWCE9LUeUzY23mpXUeKNCOM2DoGJBLIy",
// 	"IwrAsgfJYpZMuwUjyyZpTXFiCQZF7MqM/P6/ltjskwkJjTevfbOuR7HhoJk5Agaf9QIdtAuYtXICZjg/",
// 	"k+egmZ6AB8lQagnyFlt7TzBo1/3MVI6EAsEvoguZRgtO2JFLKx3T/YLUWtUaBbA2XaXlwnam8gyZLEa5",
// 	"4zTpPQZJMKBBoB3sc+G56UcOirbUudsjiMcRI0gcPo4jBtItmjAiBCn5hhPmjbCglMMo8nkXZYYD6CJX",
// 	"JIwTHARTSOcknpl466GPRlHgQwCegHZxtvgySmIdlhEz7H2D9jBYbmh7pfGIRclwhLBO38FW1COj4MdI",
// 	"PZgdh0j7aljetMMhI0OxuZX0xwlmcSgYyiHaOn2zgsYRj9EkSIY0VJsa4SuCMJ+G3ohFYZRA+OI4CVUG",
// 	"Dm50lNzkFAHFulzoNbkcRdE3ENikTUlwUkkciXOQi5XYAI5Jz0L/lmcO2VQEnNgH4tCm4dAjwS2wkzW8",
// 	"ZATUgC0sDgGmY+Ui6lL7i89Zo1olH5WO1iD4MG1cKjtSX7+2fViJwZf2zi0D9AKqB51Mwbn08FL53HAQ",
// 	"pOnbQuIJJMemRpFq71VDqgDHEQ79QAKchT+yQbEulmFB7TLOoLZBEkg1zNn5yfv9vafb55/e7p0/23h9",
// 	"+uqPsxc/OKYtd9IPPLjtPAd6x6KZ2HMeJlcVFq0gFmMcTsUxEeyN0BsaEhgtVTeoU60R024RU2dd2+KF",
// 	"1oVRP4xiOqBl4viLAA8lqw4/XwoKeK0U4NJRBdkDcHlmOgCEci2zQ7LGMKthKVUflxGFsDk9aEgJmtKA",
// 	"d5IQ19OAFH/IoQUGOX/V+3y+c7K996H35O3jw5O3L3obh687Zakx1N6bwpTpY/VvsCN7C6catavslFQc",
// 	"qbh0wPOaA7U5RXujYxwmbg2L4ufmxmSo8ZpjfIhGcTHY13jSKKLsGk8aBJJd40mDE++JSWdhI4DZpeEQ",
// 	"4mdK0OW5aiNQ3De3rkryzJpJTLgDElYUPgU2NuGGMTeZ75Tx1AU8lQeZ3cJsiDQzhguLmgZS5atOasKI",
// 	"EPX8zm7MEuLSSut+SlXc7vRy/I/ZSYmwt5BeATbasCTyF5kHnxMgbWyQFSMllXNERzFJGzjCFiGWZCwL",
// 	"hN8IAVFLnrk66L8SLJMTqr/NEEXpplKm3cswUg2QgNW8HhdkzqEVEnZiBjiiMgozA4eqbqZxDgDx/w32",
// 	"kV5n+S4YGRBGQk86d9iRUGSsM3QdfTzffr55dPrkRe/T2ae3L94eOc3zGhTcyyoFFLk4aoIZfAdLmTUB",
// 	"1SqzctedHpi1SPeLghVVPitzCU5qX+1+M3AJblJJYbQrHNGYS8eAQMG6RG3FB1UPAc4JMUdDekVCTTbk",
// 	"AroNuQfK+2pxdV4YamPU7Ca9WhkMEaMrwjiNwi46VZoa4zuW+qKkneXvsRYxxfpTzQ6wtQNKAl/nH78A",
// 	"TvYiszFJbPK87Xc3LGgaWg0PNqdnMsEUT+aIDmK0D6luxD4Y8QkZA2qT+dkVmCBsa4Kz1O4aetvpL6IB",
// 	"wqFkg4vgcYkD7EzoJoPLxpiGoHOH6ZQm2ayyW6c/XqkIzLK9v+TrhlTLA6rCmNJZpCsG5RknsH3LCUye",
// 	"E/ysFjqoWGhn6+zF+erJy8391c+PP/+x+unk7eOlh9itPMTMQd+Vi5hbzwMvSdCfT6+fnz5//3nz7OnZ",
// 	"88Pzx6+eHq5/ev/HrdzD0i1V+YdZD7bcQay72I5XCy+yp1chYDk1TeTp0Sxi+wKF8qb7l35fWbev9BAo",
// 	"TzMNdW+ZyeVnsXSmu09Nnd2W1kvlfiMnXTGUz74Xi98zMxYJe0rAs3nmGA459tzKuHQD52kzh2EOp4Qt",
// 	"4SBvpT3jSNB0reGnTL6TootOw9xKcGVc+Tu2J+z3Sh0reChH2jzUJC9f/ftNr7rsCacJja1by5y14m0t",
// 	"WOnemqSVLCY9Bms2BxH11IQ7e08Pe6/3Xn062ny5frj9YuPk49O9Ehoa4xtIdFZJQq1pwWIr+yjd88+l",
// 	"Tk4vtpI2aY2Teqa3J08xvukzVcPFwYjhG8SU0Th34O6cRCoWMY8ZM4C9ohGICxna2KsCMWZwoYCYsdP/",
// 	"4lj8zJVEi1M1g3RA/P3sTRZlwChoQAOiZR6oY9FdsHi8xbSUwuEVXz8dA8vw9PHO8xefz7bPn706//Bx",
// 	"u3f0cev11uH2Qjmt3bOzNCuJyG8DpmaqhNFa1a6Y0XqD8FiKb04+re8rnVT5VzQfazUat3QIio8GpJmE",
// 	"NM7qzk0qOOkIDEwHlIyLkriLPo5IiKxRBRuT8uXxiCily5DEyIsmNM0qxwhPAvCMUmkWQykzZr2JDCYA",
// 	"gpl1EAp9dAbpF3nXXsIYTxEOeCS6a44KnHsnLPII52LK3jWeyBHAMcRZyeW/CY/HpG1qZqvfLdO39tOh",
// 	"XKYHqMTWr8gf/cIRSpRVpaZmXaNMhYPyI3FGlhu0dA4XfGozYu3Ok78nwwWbOAJh1kBNDxmL6+k0QK0h",
// 	"0+nuyzTyMyRC/lndoMoOY+E0YJUe3+ANIwkJ8V2e36ryFHdandKLfxcS1KN/zy//u54PyjJRaSqozg9p",
// 	"HFn6tzKPOBxj5pwmPc6IFa33OcI89ceeAXOJDdrWinzsOG0oVbTTMs5g5WqVuOtY7ZfrDZsDBbrcl/70",
// 	"dVm8KO+Lm3HLxPVHSzOqhm7TmFaZCNnB2UsdPpVIRtAVnTJ5qQu9lbxZT8hmETMjRoc0xEFdTQbdDiRP",
// 	"V+ra5rggnbLJdE2nKsvm2w6vKsqhlTVuwrFRnnzcrRqpyW2equGk4TWdFZ3jb4TLuhfAvaaxNzSUzqec",
// 	"+kQGLzZJSS5f4pyITfNc6NqnbD7zWh5lddMKfrc/Jsylg3ChxpBc26KFyUvC8ZigK8woTiMaLwmCkX0U",
// 	"MSU1qZxgKSpyA1Ap9muX0LrVO1hgr7rGXKnAUWLT7SQ00+u28pkeyOnG1jxpeHuMGY+S8WXozAy4B1oI",
// 	"eURSaOdjHARKFdGOH9aO49JnfHWSXAbUW4WReJdvdUmyek14vLrRxWP8dxTia+lW7kWDASGr42TYnUDi",
// 	"9mplh1FsuC3McUAK61zJuyUTzGkwNY4DcPE594Ds3k5gT2gflopOkqFzXe2ytbd6fylDV5UiKRogIUuJ",
// 	"xrUkSTpH2DJ9NgmsKm5vzgWzeA14ijXx/NYaiobujVk4674NiYCTXQ9jwiI/8WKDtjWSE4s6Vd8+qG8q",
// 	"tiY101jHXIFa1ND1eFE1bIAaW6wsA+B6Bm0FPjn7tPlh6/RD72zz46fPpy+eb9eqHeWzzICq2yPOLKGo",
// 	"lMw4IjpVW5U+cBbzg/bSPq0Mnaabeq6llSS0TaRG4XBuP/VH3J7AbphJmgpNxJ3JLnCY3So9Q5ukN7XZ",
// 	"blIZwmgmXMnWsH3At0u9VAbW4RWNHbaHgGIpp7w+fPzp8/75y97+682jg8PTx0/PDjfu3gk2PSAnDp9F",
// 	"8L8nwTWfnt14smZBs2jYK3lnZc85p5x2MEWN3/U5voG/GmeLMwHgktpLcgZy6HQiyH7m6mJ8s76xeCrN",
// 	"MkhMNT5iQ+Iv12uJA4PXD84+bfReb799//7Zhw+fHr98/2z5XG6fA3MPjZIxDtGAURL6gaqKoSNqc5V+",
// 	"OgKCD9VfLs+yUrO9Kj4hTfdCfh9hNpSwnAXjDReVWqDgkxTPwGaLme6dz70UudiS1TgKybS0TNyJ+Ir2",
// 	"xlIJwjIoxlaxYKVLKbBTUvUySZgHFstBxLroEHsjZI+MCAVfFkjyjXTWfiHnKwe9ov65kKFC0HwhlNHQ",
// 	"LMYaaAWAa5AEwVT5G65ewoJUtxVLH6TVwEK4mxCPDqin1tFFxwNnd+MzHaeqJ51Qs0xO0NB+RuhQapNa",
// 	"e5epoUEEJTyWc3jhVAo0v5HusIs8uK6N9XX1r/QZ/M/Gv1N5JH9xsHov4nGTfF/3nZY5rWJSnabervkg",
// 	"/91vVs/EXF7qRC/WnYFhqgM58t6yC1PlZDH9ZQABKYguEuMx1rzxy7MX79++fNJ79n799PWzx58//+Gm",
// 	"dPimRu+pk94Z/af7PqVzuSyccDyQGhFJHCmHwBdOZCxoWTdIHKEmobmILqdO+96I9JiGdWdGw8U8Myur",
// 	"dKv80+lfDdiwNJ+2U7CzIThbkVbGHn7a2n/96tP+0ZMPnz788ezpy53X++s7Hzs/Q72reRQxXVCN1VIv",
// 	"VZY9M0MbXcKs/XiLfGaGoxTYReVX7kM+LV5MR5b+noN6xrDMSyIbNLQgmLRdxQwiVnoyXcnzVIftiyMQ",
// 	"TNRl5E/T5D9y6i46DQjmRHrmpdmAZLBgzKYKIGCEypxjJzrZ9KHeU/70cqcFCUiqso+8zaQWwfk8WuCC",
// 	"eEUxstuZYEoONjTEiPIeB65apfgCT0GOeOKNRCtpb+9OAuwR/6KLsvPmMgFwmQNVJvcKoiFUJhRPFCRa",
// 	"8HF0LFN6QeqwDEaGmPmQY0xFVa7AgZNQvEIhjXAS+ry7oFVCmtTpaFIGpIGPmi5A0MBZzwRzavqdAQtI",
// 	"ICJvonvLEkllmbXUy6mZHwopolZ5uJzwLQGaxlAgFiuQqc/BBaDfb1a/A9qm+wmd+3HHKKjH1IZbtocv",
// 	"EmfxVdzTk60PO5+391+f7B89P9k4Xf/0dH/z2dmn26TTsSeeNZ9OyRVJb4PQD1RAst0se2qchENGfTfr",
// 	"BNigjJmBj3qqKyI9G1T+MOIjPIhVLI1xhcmvohHtyZySnNVdoF9imAYv1iAj94sBB+75+CaZRdUnrb3F",
// 	"otyG4DLbkixyWI+srCICVkoeHMrafXqgFXSZWDlcUQRaJ1O8y5A6Qbiw4ARiQdAYon5OoCfs/9SfXS8a",
// 	"dxavSrfNz2XvNQt8cPYWZ2cfcJE3yTAiOcakadaNDH78IWk33DM2ybshnm8Zvilm3lAcpSuD0oIm4nBk",
// 	"3shonf0y0KhIxlFKJ1yo0SnocsilPEC4gIKXbN6Szfv12Dy1nVJu78X658Pzx0+Odt6+PF1/9sf29v7h",
// 	"4/evn/ec3J4s4FMPQZljNpHVmjkKprDf7q2ZT7mcvIDblMP6MfxryaHMn39dsoRLlvDuWEInHT+TdLia",
// 	"iqdyTEnURtb1JHImy7j7KunpA8kXSXcp7fUqb1c7vVGKeDNdJgs8ksihIbexSBGfMGmzM5012LOsxC58",
// 	"K5+7Pu6zTVHdYlhpo9pB92KOptm0J8WbWBgr9EIzzmYBDcG7Pb88S6Brzi/cZQetCFS3Kyo5oKTykE2/",
// 	"GSpvtalFTfkkwNPSC4KFPuJItcsxwpvOA2F4EJfHjMPn5rGG1mj18GY1buIzbK0EpHX5T1pAc06HZuJT",
// 	"153nIl9lbCO0Rb5gLKKmAAB9ZovkkQcgBnBduawm7zwbxaBVvEBDNOUornNRiK7mAuySNpFO3FkYzE4w",
// 	"KvVQWRtiGMV9EwreWakAYDuoWo2U1tbKDzPBLKaCcc386m6hgvQ6Jvgv89WKCbb+qTmRjlH78L5KJfS1",
// 	"+hRKsIzdoiWisbveuoaEC96s+PuGsWMm/l4HJuIbwucc55/O0WZgK7Fdi4xkba/EPeFsl1OasKr0mup2",
// 	"NvNuWpCyQn67JrSsjobllDiziOVzLaJjpe1RFEkRoAdfPsd41yt1gozE0wmU6kHqFgVvMsEAeQhazIIz",
// 	"E0wb4DTlmSwaNwnTVFdaSlXVOOWvSefedhJT1RtfYxpTCJX18CROWIE6ysQAHZVWgPizkEe1khJY019b",
// 	"Yi3dbTYoU73dFmidP6HfNI1pLo1C5no319fLszSQ5nBjcjTQDCriLZIfyCFKHQHg44waBNW7TYF30aFV",
// 	"gfeH6AEqL6/0SuDjzFcCvdtciejQ5ko4DgjveyMchsSZEgAaINWgUXIHe8QGWR7s5g0kyux62suUOnPU",
// 	"DLrafNcmqzWVRO9aW2sWNybxKCpDEWY9qlVLjJ2fZDbMnRvFCZa6SRM5wyQDKwvOtlOXOGjxhIS+7F5O",
// 	"igskOO1kHK0ENWbeiF7NQmHbpWspgExVqpYyWJB5LGfCTNC3OV6yE8M0wUrVCYv1nejExdVZilvlU6lP",
// 	"n9IurUfxnpzMRMFJPdXprhg1UErR8jp1y5FFJ3PPmbzkOkzCMNBbFTaRKtKgABdPy28pDAvShEC9Q+Ly",
// 	"TJYfShLHQlyyaoLgolvq2iC4Uw7gtExE4YCy8S1MkLBxMGLpoVqYsMzsl9PKQjWmPA3TIAIW14il2vnr",
// 	"UZQuwWIUxfoqE2zOaWpTN7t2Yp94Qtabw5Hrkdrk9VRzz2fXerhW22YEcyc/a0W0hZE4gtEU5UYWuNPe",
// 	"tcOYMlDpi/t+WX2LtA26JPE1IaouQBkmAh/E/FexGkg85ucSHZUJPndl5qlULsEyHRom0la9pCJA+uJi",
// 	"mlydOwZRFRguQku6tGOdFzm+jqTaSCLQ51klTKe5Xmc/Gk8ScVeWcsfk+7Pw8u21NMa0VIuX22ShjNIs",
// 	"lIJzALhz6wtbGB1VYNI8sJAZqjkaSmefDx4y4zVBRA15xkHEbIjxNBQB6FhgU8tM3iMj1RJJ5RgqA6Ar",
// 	"xilLcysZ8plnpNChYJTc3JQx/hXZkyY+RIoIpFxRY+fvlBlTPR1YkXot0WIm739jtJFm3WjgfRBEoY26",
// 	"bl0ENMvKNjfWpn81RllEgkGe7LTAUiZR7WwHXezeaO0q2idNDFTqQTPD+Ze7TZYKzSr7k6mTysg4uiL6",
// 	"L+n255CO87nlZKhH9h4LTxcSxuzrp+V8wTmRQmuUC3s61fptq3amSRGDk3gUMfq3FqB1ghatvJdKjhVk",
// 	"BlGqZq2tX7Gc5pjREXdnLsgFAdZqbpPm1lpk3o27JO2JHDI1H1TNm4c3Pb29LCvTr9KCX0I97ag80aY7",
// 	"HUsjr8QKaq8XZ7srtvFVlLc2p+nlYD+Vq6RVECJTHENvrEc4V7W6tCipQG7B0qj9AF/G4967svQ6+rgo",
// 	"tyI1Fze7TnUkjMbOJpBF7y4Tw6JS7q2gceTTwRSEUWWgtzt10fl0Qj1wao+Nm7t0b5cwqjCKLPgVCohU",
// 	"aMS4OxnLqQRG6QivixKFiIwn8VQPph5JYcl+RHj4SM6DcDgFckbqA2/KHo5aU5Fbm+Cp5CZevT3fPjg8",
// 	"/Hjw4u3eq8efPh6cv3x9eOc+Egr8VM0TbM7ugfhILKtAlFWBsFBQwh2cwUzuOy0i5otIQmkGGOGTKORU",
// 	"nEkOozQsHb8AGerTY89mqC859UUOsjbZn/LZc+zLthjw9K5ybLfls6GdYxpGVhdg5S6DqjUGbBVPXQ6M",
// 	"v1w0df6ySgEhG6uo3aUkzS4VwzSHma17DMXnrAQ7EDEb0L9V2KKuOogGQXS9YgoGWll9gMyDzT5WxVBT",
// 	"Uig6qdSeLjY3CmMWwQFfTh2wugKavRK8lkkVJN+zg4thV9QjvIv2UjmucBpwk1YFxCEBCB5HyjnOCKDZ",
// 	"7KISLU3hMLNiopZP1pRr0BqJPYfZ72cWSW4XzHW/he1+IEuuT/CBs+Z6TQ4WHUKhdtY3Pr3tnZ1sfu5t",
// 	"7fXe7rx88vpo68UfP5xDh6f1UFyYeZ+TgHgxcWbMGJTUnMs/7bSgkxpM0GzIXwnqNxXlr6A1PWQpeEti",
// 	"qyrPZqBIUmiHv/Ddcrl6W025XcupKVM/z9QE1HQt4fllmZf9URyOYk2A+CsPpwtJLfPU5ZJ40Zigi5Rk",
// 	"XHSLNGmMp5q5sBdwYTyiBCxeFCnSIGEyVl0FdwjiFMuqvEZZ4qrRo/TM6aIEuTKeWplZRXNIpmi5an3N",
// 	"vHnTb5F5c00YszBpYMLBlaWwVcKUaQaskIE2x45B4tg3lOeSpwP3GA1kYlnFkAqUwKivIFFDmUw9K2Af",
// 	"wvaYxEy5WjsLmwOxP2RRUuZcZ/jQI2hk5yLXp5ZJKNwgFljN1yLGW68BOrYKWb3XZNq1FXTSlMWPeGnd",
// 	"nFMJfgK6PhyfmsPgzoDK0OdtNuu6TR5HE67KlF7hgM4he3hmn3mOpG365VbVZA8i9VSt7NDqPdeVkC3P",
// 	"OJTZDjSzNyQuSd6ZW60EX5zjZus4GAHY5dma3ld1ZArMVv7SopC8G3R2/6w2HORyBddZGexX3vn+1eUV",
// 	"HWMWzwFQxSizQarLfRpivJ3O0zmOwyzBptRgeeiouHKnZ3RqZ9YzcgzFUsrz9djXLBNwSfkCyMxAV+SA",
// 	"UIULQXcuNH26sLkINY3+5lzcAnEC6kXZa7Cpv336ecKfyx4P9NdF8OGD5MawpCoqsjKX0dtORupF47HM",
// 	"TagouEk7JKtBylq06US8i8xE4tpgEJ04WinsuTpBWW5ER3rq8WHuwoqkryS6nDr4iSgQQkNJbJLmR9JW",
// 	"jdQapnUD5YZpWypP6O3sp4solDdJiy1mKYUXBbrOxPMXe3+sH3zY/vBsa+PVp48v158fLWLJ/oXlPvYQ",
// 	"H0UsU6wvl9Q+q1U6vCJsKiBoyPB4DE4xl4THqjZUZRW/tPxzQ22xBgOF6/Q4xO+iA5MhBcS4MJLM51TI",
// 	"VFaJ4khVtdAjgU5VqoWFGE55A8Vwg+wURhVkF6GQOMdxHjL5nOsqip6VRoxWG5BVgsSvPEiGiMcs8eKE",
// 	"kX/ndH+m6KxzAYQORyWgKL+V1DXoohM8NfoGGqbRV1Czy8OBl0h0wa2TTONWRrzCzeAlZuMoBFVtb8rB",
// 	"GTDySaOVXE7RCytVR5ouP47QBHOueGXB6skno5Lnm+V7mDFKGO+2Y2ZhSQ5OlkV+WtLh+d7W5rOtnfXn",
// 	"T/Y+vdreWH/hnAMoh0PhISlK7kVWhrlDj9ni2KCvM0sC7w/pIPYwy9p7VPh5/RPOiNNHdBCjfcx8izAC",
// 	"7k+90UwT9cBxEkfi3jxlCJAaRkge6hMyhqMwfRTghJDeUBkCtDLMdz/xgITDeFSSeAC+3dGTGOOYMFrm",
// 	"OKy/SvOOuDBO3aRSVx6hHI0xPJuVH/hE7rEWkl+BUk5wmAwwIEjG0bFCq8oyZWVj0/hWKVitXguAfhSD",
// 	"WM1FvVNcpJEV83XrDOoosJG5HabmU6zpkReNL2mINW+QnRN9EDfKq70+JrdIRqPQbF8O4o7toEMa9oEh",
// 	"YCVBC+qjeKGW62K+jB7mCqsLHuPHXfGERQMqAb5RmLFun3Zt4rShl3Iqu1Sx291Ca65hQulCNXyZdhkI",
// 	"zFmi1dEZT2I1hkb+uay7E0M7t3YO3/b+eHLy4fGrvbOnW0+fnzhFeDvgviw02A6y5zaH5gqzb5wNoE3E",
// 	"sCvtQKOEBrfQUKRcqFYB6J5CXoy4NCcklwHlIxXY/V9puSqL6JbCdxWW162ckKDNILJU5zQvZxRVJXhY",
// 	"g/nO8RAukA5DYmyzTRglMfTtMFKMh85Y71Eyvgyd+fL20O9nb6BwUiiVBSh9ibmTytRzto7IyHwJo84T",
// 	"K7khVLwUlZ9RUQmC+dSQQg/XSoInYDpF+yBqoBO3qKFVXY2OU7RVfWrVBqAYa6wwiKcTqVze2Xt62Hu9",
// 	"9+rT0ebL9cPtFxsnH5/uLWwZPN6oDp4zH5Z5AeDjcxdEXa/xdm9IF/xzvKPrCjH1+i7F1Gvql8kC8OlO",
// 	"ps2HBMEzztD3jO5T4/WC4lN+SLWe/SpdYFEJl7N8KkPbICeoCQ5TZSlbNGPm/eraanU7sqlT7nBoRFcB",
// 	"VQN2lsgsA14ZDVCei0rGY8JWrctvr9mwFMQOJUd7Jey9SYlqP9XolBerdhZvpMbIJgdqzhSWa+IbJZVx",
// 	"k3qwG6XEvgS0KE/hz1dGhPR2ewA+VvsFdxqRR1HEkNkduJGljSEtvBlNqnGmFniUySZvrhnjKbrCbGry",
// 	"WOjUFqkfiPR9M5R6X9qV8uMLXPul06N/ky8d0AN96exHQcS+dKSnoeLDtAdhQMdUHLJlMXKJZkp+W2Lv",
// 	"NvhQgoQjOn0Sm7rn75//8eH1/uGnV5uPn/e2T/c/bS0iKqxCRg1sgappvSFQP6Z69YRh7PM4S3GklNs6",
// 	"re5tFe7tcWdxHZdTZY/RzzNnhRE/LqJsIVj7JupEJQXUKhVV8xppQQw1Dw1gH4Yq0sNyBlpDoIM8vJtU",
// 	"k4ZU6ehchOMVyfcq9VxQITknJTzi6n0jTorqWC2kuS5CSeleQf7IUiJflwuwpPYlim+H4uUtOhH9FTZs",
// 	"78uzp73tw/2D9a2zF9sfNzYPeq8WCtenHEw7/boC8eY4W0FpGcqU0FuFwNsT0AXAoe6J5R2W2udGmBfQ",
// 	"qFSGUi9/bpK40EEJGTJMITg0yHk9nSn8S6c3xkEgmMQvnRPi02T8pYMihr503mA2LBKrQPxaoYuaQaGj",
// 	"/tkCkPQpzQ5Jek7DDZx92vywdfqhd7b58dPn0xfPt2tlCXm59jPIbKWUisjV1dGSlHzZauRSKQPU2zqY",
// 	"yPdV4JuWWI3edkCDmDBZfd83jmxL1N8G9cd46FBzxBjyZz97vXlyfnK0s7H97MXm86frvY3zvQ+vF4u3",
// 	"/9lw4jkeWtrGrK87lr80eamOB3mOh+XvUJltMmaH8vc3nZDq95d9eoxMIhaLvyYJm0Sc8OUjbPUIpxPi",
// 	"eoWtDTjLV9j0FQoIT59hlpzuB1E8csaMNX6KMrdZ2VtUNr8891D6Ho3Ny8pcZvmuQLoyw09l/Qw0mYZU",
// 	"xMOEKVMMko5WN3ScjJG0xpQ7gOOMUyoIazSXSiEdAhtxuLACY3tzoAccBNF1/xJ736yEK20d7jQnldaO",
// 	"UR5wsB7wg72g4RUJ44hN+38lOIxpPAX5fN3tIneJmdvTak/641FP5VoQSBGjo/Pjt/osmtq3jSVt6cKd",
// 	"C+fC7qTMh3tvkbqXuZ710kN4nh7CWuFfpGuzSCsrneK7LfF5UylVdCt9UpA4Uwdt8zjyvuUq9ZRkULxH",
// 	"J9kQD0nf7LtxFIGyjSgkKIdBZpiCHrP4JCz8t/TUXXrqzs1TV6vWFavi0Kmb9f8Yv9oyrfqD8K5tGmlb",
// 	"Zt8wdwHOVHafrLeMjAemoXF0NakygSWyPhsW9QxqoNwqdrdFxG7hcn8+c6CGJstZ+ba2QP4tqcx0DyQS",
// 	"KsgIWEtCGjfjrGSkLvjeJVwnGQEPvL9oGuZlRXllCLPMDqLqA2cSfDGiamT4CHss4jyNJuXAF+V9gUaU",
// 	"xasbm1s/2F/UpqeWVXSMg8Ct0vecHrOn+3fC4y6Eh2ef4fBbhp1Zd3l1i1am5Cso+6WY7HJeXHpNZvCM",
// 	"k1126Ck+mCMtUVVYho2yso8SmXOZxYuTOKYCQ4nHMoquTQYVblOIIYmGDE9G1MMBCiL1jvgomkjFBOUr",
// 	"tv/fihDdmWbtPaqizXXhMG6b6btoT5EXeCteFHKVU9mgC0m3ZcoWhD0vGkcA9irEXSwDrsLsReEb08+h",
// 	"vdCRen1ZgbtxwK9obakr1DjaGQ/SSwGpdDLnZkFV/Am1fRmoLmajfP0aEGIzymy0WHNQrlpfDz1veEnO",
// 	"cAWeCc+7ry5OnvB71ftYVfJNZtESEC9hoJ0xODIaC7SLvAX853Oc3r70fyZdanlxeYFKWmcPsGrPQ7I1",
// 	"OYSuuN0EqZRxqR5m8TwK7d4igRE3PKMqNFyXxOje5P7y7Enii2YK1C7EGzFMpopk0XmEuuh4YCONKAym",
// 	"4E4h3pwRQFUiQkHASKjMddeMxjrvpGwmps7ltfi9U14lvO7t5TMiut+dTkNq0tb+8JfnSlLsqlRajtMF",
// 	"owEoHDYVhSauvrAbkH3GWSE/krF/UkaRdgIPriRvL3XEAd5kEmtX7TLTNte3geQptmjyZKfVhA2uKFte",
// 	"eXlXzZ1JqEhZHEEeh9XH2KQSLDB+1TPfju8xk8wGdeZwHNC2eNmm8hnhzeotmeFMA0JOVFAAYmqouyQE",
// 	"Wc9ckl6QE2ydlqzBaCWwUUZHk3zxmvKR5NY5CWXFoRWEIfAPTgmS4I50YTydHtaU40dnqny7jZowRxNI",
// 	"bT1AGFL7OzwWAkzH/bL6Dwg+Ny8CYY3WIJVU2rjB492HlVj8JRw3BeWc3OMC2hbLS/qL1bs4De0tef70",
// 	"0+n+yYtnZ3+sf954svH2jw+bH35w8ubYLPTBJHB2R2udp/BkvU39xJSeLlMD7BozMooSTqoT9ojBZsOs",
// 	"8txLa57eH88X9cMoVQsW5/84UlkgxEkJPh6FEbK7pOdKQMke4FhzhECIxb4zxFE5RhQZ34UvWpPiKDAH",
// 	"Dlg0vn3RGkY8Qq9uhdFgVbKIrByrTQ3ZQRL6/aYF/lKOyJTSwxxyO/EkiLNIJm+ndhqqTaIUN/Qf4Bhb",
// 	"5Y7VVkUnWeSPa/7PpOSWwrUj67mM9+WuceqT95tlypTu7oMyCVZOKvK+AzNgAZPAQl20L4l8mASBBmrD",
// 	"SAywRwMam1zq+UOIR2TMSXBVkwQgt4XZ0Fj+HBomQTGVhQuJUHqZJChnKeCoJCh2Tw3ddjZ1rANG7Tzq",
// 	"P1NJpqZ8zwKx31mckWG2gZV2MNvwu2G2TQ3afIlxJsmHOAvDWWtXQTn4ijHuxUzQb3Wmeb+ZtHfmERru",
// 	"uliYifdTUGuju7L4jGwdb1kFCEyJUFtVwi5KQnIzgcQ9wVQLdin34VZuta3YW1mjN60OkTuk/G6M7ZLf",
// 	"ulzyPbI3cyq0f1YkaZ1j5FNfBnJ/E3Kc891W+33VwC3lDiVAkba6CCsjmNdHlKn3qBqbbg2wmGwImiE5",
// 	"iMyV4aqvzSRL9OnZ5tH+/ofN1733Lw+ev+z19l4+OX9fwhJRIliihocn37jF/zgfVt156WL6bSfVpYeD",
// 	"qV1BP8rjm7rpJWKsfbTqhTpfbJmjRXspVC3HcOT1MOSgEnpHKUIq0ApYdxnBMPgsC6UOOn6WAuP1aJqW",
// 	"wU7zxqV6lT19ZKqTrV+JwqzcSLXoYReJkTNY9AnzCsKyTGddms7akcha3kkOzVrqNSaWPMZDYAIba2dK",
// 	"rEBt0VKAL4kzU1xMbuIS95tcjXEtLRV3eSC3hYZR5PPFykOBGYFq7LlH2IquuAZpQGVkN+vAyjCVGtEb",
// 	"0cBnpP36Fj0UKOc1pahvPhdQ6dsoiZuVEF3EyvIZluLl9Nhq5eKcTJwNBrrGlh8qDpW6JWIaCavXpBR2",
// 	"XVQYTOCDy4QGMehiEM7nOJVpd8Z4qhNGOR7DSublhsQjnGPL49xlrYeanaBPkFHhlh7hpylQmddW6JrA",
// 	"ecQ0S3HKxbZBWCeStUFUH0nDKph7FoThGKejOwEpJMTntqtHBp6kaVYvg2bC0dLCQoXEvmJe6YZqg75t",
// 	"vdJlUDDyWTRBk4iGMaL+7FUsjSugRARFasvHhgU9ONs8fLr/+UPv4OXJk52t90ebt3a5SKsNKvDJrcc4",
// 	"dFe7XiyKBjqF0JwGuumjna16OvVItQo4UoZwgxxz65GOkKkr/cCq45XNxmR5h5jN1ew1lW4K2jKz8U23",
// 	"lnlm6aolRsiLTXnMp1S3DcDIHqmB5lGT4WZ5ZPLNiyM0OKoc1qk8s5RG59zdI+OH9fTo86fH7z+93Ts7",
// 	"e7//cePts/MFra1vnUBGkdsSVGJ80w9o6HIHqfHvgF5zUd/39XC1Kboc4KERhsU95o6gyD86zAelS6pj",
// 	"JdE5vgEp3FFSyx37LB1ac5x0jG9khurLaQY0Y3yzvvHzOCCII1NBKfgG/nKR4Dgw7+3g7NNG7/X22/fv",
// 	"n3348Onxy/fPFktx6/RF3EOjZIxDVcIqkN6BhhhJqp7uVwDIofrLhaxLvcDCZAxB8tITzBA9cbJZKNlw",
// 	"OXo5ZKKWJrX8m6iXk831347nWiAjk+MM1JUp4CjHOzZmqEZAGQToIKIlCEjz2XORZfVgMp1gaFe4cIue",
// 	"BauyKpVGkOWuDS5iehVgRqAxDNp11QHRBmSxyjCKMxl0hNTIpSDNCRNrFMxXTMaTQECDeHx5uVzJLT7l",
// 	"MQ1lDuMx/iaY8xhNIi7Ljot3BVox+jcB5eoV9RMcFIX8PD6x5BhHTEsDR4YMF2sEBXOKecZGsq9AIyhH",
// 	"F4MAx+BmeNGE87xn9a8Tdat5MQifVgxtmaYjQy9zp1MvMS5mEiNz7WWJgluzprOFCOTW0VBOBWt16rZa",
// 	"lXHmRYCHGfMFdbPvthlkkKItrYrg3Z8qVsEkdXVtdVW6pimP91JdfVZUOY14/AJ/I6gX49DHzC8VoUvS",
// 	"lNk1gkU7GQxvQiaNwTdF6fDcaVjEiKDsdD1G7UdkISmV+OyG+DocJWLoQk9M/AsNEM7XL6BCeVgp0PRw",
// 	"YAd5aj8dMyG44ujBBZFOj9Bus2iFtfLv8CctsNU08KIssKs2+CKVfl3wsuL2edPhNFaXCiDOnMAYhwkO",
// 	"3LqWYYldUUUoNdKyDBsVSZbt+uXe30MnDWkfZ6Y4YDihsrnSFqp8QcKBY+M4pjyToKSgogGnhDTXmUz/",
// 	"JRi8mlNKp7yl3kGpD6wRf45QkxQAMugm+2Ay+N8lnpSlMG+gj7NPzAny5rMJRMFMwYYEjGljsNB0UMDF",
// 	"rAx2NJ5AKKc2O/HkMo5iHOR9U0ryV/0UTKN96i4GkpnHv7P3/PH++duDsxe9s4+9s9cfD5zKzUXS4pZv",
// 	"tax0W2uOuZ5PirMIb0UybpLechNBJVlLTXQU6Pk2GD8Si41x0EUXYxr2NTBeZLGpVdF/TENIMpmCreLO",
// 	"ciJTzVNaESCpjMQXY3xjzaw3EVspLbOzmbdj8lc2nNXmy+ztdlY69hqyzFmuYUPljK0OjmX60KJbcH65",
// 	"ZxYuq8OFeVJR4P/KtTTz4NYG9dza0t2rMdpUd+bAlW353J9L7lT7nk3wPJDifUEKKWH/m1RPK9qstDyk",
// 	"sVLhcQwidkcF1drU183iBl4ThtPkYcf2udDQeSrNwmpuleHPQcsL0f6NqGV+7Ssa2i6UmuhiBV2YdB0X",
// 	"UhkAcHdhkw2tU7JSe0DAtWiYpRtpy0W2Jig2vpQzT99UGTmy9A1uI3TvGk9MtLbC3FKP4wwKJzfeCIdD",
// 	"x6ucSoKl8wwAuKYV6QzpQWrCNFeUjpGRGiZyRaOEB1NrIDMVDn2EMxJ8NEAhuTYtVuACFD8/wbSQaJGj",
// 	"SwKZv5Tjc17mv4ZsLiqo13S2p+iiY/ncIBBZ5soqm7RqYnLjEeLbXSU7lBkguzdxUIMkTBdNOU8srk6f",
// 	"tkcc8o8hIP2K6GMxn50bQCbALCD6KsSSn2g2xJKJC8qjlNbpy48HKgaYZ4BdRpmrkuwqoUGUAFBBQkZ3",
// 	"HjAVsDczegD3C2CT1Egt0mgtrlumhSogGSVRQf0DysZm27f30JQDzuX09VDarctmYxpex68cI2FwTd8v",
// 	"8wFP2xg5FLAbxF6Vh2EDpOicjSEZ4phekdTO6UK0BqvKR2zhVimYqpEzeNyd+MZS5tjKZjs6uCAnZGKB",
// 	"c9QpA/qKSwmjuK8GB6d3+9/K0G5HBhfDhjOcTH60qhRv9ZndeDHiO0sUKhGMPdWtU7e5UH+prHaNJw75",
// 	"7BpPtCvJs+3PO0c7mwdbnw/Odj5vf9h+un0PeUzA4e+BZDFZ3OQfx4NbpP4ANvlnzvuR8qRZVs4K7FRt",
// 	"DIs9By9sCUEN88PZme+ao1adBC9DJ6AKhvogZEZCIcYdosA14yqpjfItUvRDUQ6cxKOI0b9NdmkM+E42",
// 	"yiNtQXM6Kx18jWksSxZ5eBInTOJrzVBkcbdFKDXR60BcmQyyt3/M/LMG46ulzOzKnYHQ85wLOQRvZEQL",
// 	"1U1n8UqPf/6+4Nj3GeG1hEI3c3QtfSl78nsFdROfVgWCHkc8BizNJVbQKAOQOB6DO1nGAK/m1qVx4Slm",
// 	"n5VoYfG7p593nu88fvbk6cHnnY3PRx8rTSvS7483SuDCndoi2xMNdpo+/hbpV/id5V9ZIK2Lg/EroCsL",
// 	"KduKGUk78soY8asjxaQ7myIXJNhLVX7GLUUmsC6mAKmV1DL5JnGumNgkSIa0sfcC5X0a8hgDr9km34ic",
// 	"Rrp0qv5ab6mLCF0RxsEb6BTaWrHTYYSCKBwSZnWWv8dachHbgTcKSih4srJWmGIELoCMX7jcwdISBeB6",
// 	"rZ1CivfoSvvp9sbeA1/eM5lePqPANW6yCCOPMIhwy/lrRyYDgHQitXK5m7SQy8gBnXi0yPXHNypC/uD5",
// 	"3sfXz1++fHX2+uX63of1zdefnp/9auECuriAV+7/4EmGaGDAruMSh+2Cim1GA2CrH5LXV+1UGEHa8Q2/",
// 	"rgGhiZ1HztTe2CNNFc0tPtUGrUlGdX6L7dyt2aptoElthMkCub7ZoZPZaE7YU4mrSHvHuLxbQJN3k3PX",
// 	"cT+dZjbF/FCzQ1xze2EhxjHnktMCAhfZoe5rlms4k/7BOY4ha8Zg2PsmjjCguiJPZkPqs5BGvkHiZu7I",
// 	"3KwHUYWKVI5zW4PXRZmRpLlDE7HASimBfj97kzEyX1FOY638U6JORgCvSBjxC6vCbZVlO+2mLWi081w2",
// 	"6CoLNWW57wZJICXPs/OT9/t7T7fPP73dO3+28fr01R9nL1qxXXo+AcQO3kv83NKoc4cqV2x8uJc619tx",
// 	"qgZ5KXJeDRyqilpG0MyXUsw8sLOXW0/XN7afrT95vP928WqpweW6phUoNDOPG2FqDAsHlJs4YbSW+uRP",
// 	"v4A6bGpkYwSHEJuhQmIiTryE0XjaE0hKC5TRN0r6OHHVW/udg/AKTRAnnOtamST0QZ8qhE0PnqlKLMi7",
// 	"X8Iv4b/+9S/0Ur6jd5dAgsDsKsfpyXFEu+MBmkbJIwb6eV86TchhUDxiUTIcIYwuWXTNCVtBCRctXvXQ",
// 	"fkDB1zZi6rc4igIuk1yeRjwe43BFoYjMygsFwagHdJKTODU66hIxgusJouEQtBfdmtXKZXi/n71ZEW2U",
// 	"VztRPmxq+uMDoweR65LKl2AKo59HyI8A26+o89XDi2P80z7tzDq//vavGA/X9pJ4tCboNLAQa+IYxE//",
// 	"Bk8aqHsKnQQUK+7sYvXqYlfMfHFxcYn56EvoJSxAq1doddUUj1td1Ys4fdc7R4801pMIbzVhAaA8HkeM",
// 	"rIk1PkJfvnwJV1dHBPuEoUf7URiTMF49n07ILsKTSaBMM2v/5VGoWwtEt8rwNXr0z5cQoS8dMsY0+NLZ",
// 	"RV86CSfs/xT+EpN96azINmJX1xHzZTOeTAjjxGMk/tL5En5/BBuDk4VC4xiqZGjlrrlZKWgTNqYCYWKO",
// 	"rkkQaJUvI3wShZx00eco0eAzoKHpqIfFGrjVtjkd0wAzzXhnj7lH4lXZfFdQtFDwyJz6/+H//629zefJ",
// 	"s+ff8OnOq98HL5MddvRk52hj+wSvv/9jsH30343ux/Mnj3c+/fVp6+np22fh+jvi/RWe7P/1dOcZefPf",
// 	"P/afHJ8/ndKD/ecvT0/+15zAfjSZWo7oeBAThi6suS/QbwKj6lyyF/97gRTXQULfgiEaSzO+AmAaIp5c",
// 	"cgEhYF5Tr0Gd3iAKguiahkMXlLlA7OiwDsI00PO1MVmThU+KAFc82X849S2A+AgmsQv4FaSb9GiiQe5c",
// 	"gP0ST9qLJpT43S8hVIHs7CrMqYP9xd+mW4rl8YS+JlPAzcqb9q1snUWGgrn6/h1idAeRg+KfHqcMH8gB",
// 	"shj5I4564lwGLApjcVWQJot30V4QpH+CAnXCiIyxBMp5Ic/zQmFrtJdiF4WazxWWty8Vhzmkr6/DQnqa",
// 	"byrsD6b6kqyvb3n/v9VVdEYOIm/1OBRcxy6Sv/cUeTogA8gGEIUcPhC0uir/AacfUI+EHHgZdfQnx+cF",
// 	"vmxI41FyCbCjuTP1j7XLILpcG2MeE7b25nj/8G3v0Kpe21GF3q2T3Ts97qx0lNa6s9vZ6K5312WVbhLi",
// 	"Ce3sdrbgp5XOBMcjIKxrKUkVUoajcgDhMYum3PK+fMRzB6wol+AiDG4H2n4Ag4prA1FVoimYd3N9vTjX",
// 	"u9ditY/lJ5fYYoZYe7y+3ieMRUz22KjvkYTatEp82elxfSfwZYmS0Lcn26nvR8MrHFAfjDPE6ru52byv",
// 	"gum095MmB/MkPRiLlers/pljov78+v3rSocn4zFmU/HSNUPxJhqiKAFHZDzkgtmD+/sqkEPm2rWN5WbV",
// 	"i3zSA8rHYSKV4LUj6DhkxwyH4CRMoAqy5P3E51IUe3D45vD8cCY6Xo5WO9+/fl/pDImDYT8iMbdNP8HU",
// 	"Ir22H14WvI9IXAHbnuQpwNk1x1CI36QILv6V01yo6epLk6p2378DTl4+pUV5SkckRvvKhqiBZx7PycgU",
// 	"6Zt6ha9wD67dflh0PIlYrKivDBD/0vm/HH1Z/S8XHKgXhTxG8if0H/A+kP1++wddYk5+Z8EuOjk8+L23",
// 	"13++t//68O1BHwSIMb45I1AbeBdtoe///hKurZkYasttXj6kL6Gcoiv23B2SWJHc3/79JeyKU/jtt39S",
// 	"oeb7v9F/FE0FTlssMgpIN4iGv5nimNT/9/9+Cb+L/3S+r8wB69QzdrOhnEnEHTjnTTS0iSpUyFbyKrws",
// 	"mU9I8OZXlECAJmVaVdJFvcTzCOeDJLBpsfElE0IdNhJlygfbfsWPuBZai5hNC2Ydk9D/eeRPb4HVQFJy",
// 	"qyys9UCrrtudS0pRtUPoht1aHYZckjX014Ka6bvs8yvhdhp6EWPEi/seI2CmxwH/dZC8kx+ioRN9/6x4",
// 	"2sbENgn6DXAtPItd9Civ0HgE+gz9WFwNBDJeHGz+IzVBzXRBjbRBgmR8X5Fy2do/MOh3AcVOvnV/RLxv",
// 	"kKs5Exun8llLbTcMAVWjOR2GxEfJpJSTPTQokeExiaH6858uhCsHBUs78b6JBZAbymUQA6gdhICZKh00",
// 	"qk3Rr+R1UjxptM+6aR53f50rIpardVZpBA8xuT/ZStVPd3pqzRU7/1r41QCOddQPFs3K7f1WxJn//rHM",
// 	"61phAS25WYGaPMzk23EztvtgLec6dY7yGEwRki58H/opqlI13qQnMJS9DyPtW9OnssiiqVAZq1I0Rk1u",
// 	"pfo0Iw4o47F2pklTeqihpcex1DiWjUrGk3iqtNAyhVwUQn+MxClmLC+m9yNumWZ82KQE8DTEI3az2+Kw",
// 	"5sZuQ7ebuNoqK7lclVgMUtOpbpnMReCMf6G+XCgnVspzxqlJNJGp6pTmlk4uYPMX4qj6eEjC+CJr4KWT",
// 	"zm5nd3ejs9JJ2wBiYNHYbfMFjyQ2rSjWvwmuX9gTd3bce4dUD+N4Kj050nBR7WhcZXXvEYIwClRwuBiJ",
// 	"F+3rJOxe0290QnyKuxEbrom/1o577/pbG9vbqxt9HExGeHXzX+8GA+rJSAvMJUWG/fRJoNKVtSjQbN8m",
// 	"OCmBZeAKM4rBDHuxgi50obULNMGUQUCBdluw4wx0UnkzUxag2pXfUzGN6INcCfgZ+77TbyxdbJ27iWNQ",
// 	"sxG7jpjeSV3pHjOvVVzwq8vtsNpzL4120p57ZWBWdMbDAeF9b4TDkATOCXLpTnNZGEV3pLo3nvb7/KVa",
// 	"FQVeKdGKNk5+KdVkBFOT70EGPQFKXDJTDZgpefGS4lpMFPz5EJgoYDm6EjqyKkMB55UCpqBh9yFcwpLz",
// 	"XNPaP9QvF+fk3q8M7+SU0yCPuLrnWjktmx2hRDqjfqVodreS2O2Qx1LYaoQfjkj84JEDU4/nN5UuZAGw",
// 	"RANPEYMUaqwFv4OHYDli0BLE/WOGeYgvlzQIcqG3OJy+G8BemgXhuvashjWhsceO9KFfV6rjdO3c7nq8",
// 	"ScImERdigUwJMy/RaykwzSwwaSG8AdtuFKeZaEizYyHPussWUg6n5ZbLjDh2oJrJg1CiUP6aS6Su8nuT",
// 	"9yMzFJsZKNeRlRB/Wi8EwfgumafEXLcXpppfq9azvZM6Ra6VCa/m4I7oIBbD+nd3cukU6dHR255d60iv",
// 	"OcqLNQKi9DNvANuu5AfzwMCF7AS3RcF6wO7iCbZL3rQRbyo5mwfPnsqnp5nTFVRta82bUhdbypUM7A8x",
// 	"pGaNpOnsazp5YoVdQrUAz3Cj2Tbu34jHZJK63k8IE6SM+F2T5iebmodyhOOYjCegrwp9RAcyNOs6Yt/E",
// 	"V00sVtA1QZyOJ8FUp60xtgYoKpMwsDlKCJHWD51ASOrZlasdzBLpSmRhFKMpibXKDGYZ428E8YQB6+ZH",
// 	"iEeqkmwuCM3T6dDtjaZBZHEwVUFaqXlEXevFsRUU9ppML5RFJTYtYSFwikY7G4XEStwDsFUjwei7aiLJ",
// 	"SIrpL6Jyo6ZumMnML7MNqmDz45jL+H6fTEjomww+8BuYX+DwQqKocQ7Kga5jjritV3UCkWg1CbBH/Ezj",
// 	"YjCtSd5URQhlo+8OMaT1Ei+TWL8ebp6HTDzFy2vDN6DS9Wv7CAWjAKJ4ymVgmScPXnkMvhSXhIRWwtbq",
// 	"82uyQpmTp7jCr6Vh6XUprAHE1EKmduYweVMqe6tKw/zVaSdw5K1VyKPi+laq7i8tVwQ2VDt8CV1GvsqZ",
// 	"o0PCLZtsDNUgVaCkwY868kAgoZSrza8tvacG84Xk2jJEqLRZS0augRFCnfLDN0OojS6QprEVp2Z4JTcn",
// 	"ZfQaa/+I6/peFR10RsaRtFcYJQTcSZmaUgYEGTKvO3H9j/vSXDqF1SSkfyUkq8ApmQ6UAUsjyoPGbxLW",
// 	"kQWqDxS/yceu95mKrGJzC4DrGgWHVeAzN9YLaEhWU2WiU4I8UgINz/ibKElJOrflnVQgpMP3ISbZ0lxW",
// 	"Sz9ibPDKaY8OjZbUzrarisUtkIFnjmlDdB4ie8POZE7zcGHSd+iaae5OTdk7vJVb091Htiwp0N1ToD3f",
// 	"tzHPw6VAgUaA2uUnqzZNgRziKjSY76KNn1BvalGeualQ0wOSetR/0h++W8Eo+uBEo41SzWq6vrV/ZP44",
// 	"v6FMkEVeTYUCQ/0UjC+OQJBOlMH/jtnUOS1FgoeNkCXk/mo4WT78FCcrYP8JRQMXamvsiJViN5Wc1Cdc",
// 	"vPSUlVQWFlMMp9uQ7f8VEd88pIqGHD6khoudIlKelc9x10uG+oH6HvxS+DvviqDerGKuHww3baH0efHV",
// 	"zRhmZZxaVcapcn1SjwQEyogaFwOdiEwXc1F/CnwE1eks7yddG9Rd16uBl7CaU03ZhN5YPpOL5zOsC2E0",
// 	"8IvTp60ra9SrVezBl7j/QeB++fiKb+/hUgBOcm8+p1axgHwXPZJpX39GT7Q8Ap6fXsU6IalYkYdU4ZaW",
// 	"X0p92HwOHGVCfYK9kcZeJpi9gMdM5fV9GYkuHYxbkQG+jCpbYtB2Uad5gH3o8ae5B/PTeoEUsGQjBLb2",
// 	"j4UEv1dnjtXetnnuNgq1LlhXVU44GSSBTGSkfbtGmENpBJfeJKcyzl1JC5b2HlQoeayd1o1Io0DyJyb5",
// 	"fqsSiGOVNo+6xLy/ht75l+FdJeiXsa+aWf0JVdAF/Gr47mZa6DymKHhJ4Bi34gDl0AuKOzVtmFiS+7xR",
// 	"4TyUETWO/9lQvJwzcz4qz2gZsioJmGKpi3hYeuhfBp9L8K/D50oxIUB9V/7z+0PQR2gcPy+1hPjpS2cX",
// 	"/fO9sR4iy8avMTJghI/KtRNnsoGT5MQRIqGMOoNi7TIQPUR8GnppQj7wTlyVFR4htgaKCkHoWEg8wjlm",
// 	"03aqip+MzZeVDVVcSTmTr65iyeYvyYJ6dL8SXVDQ/xMw+nMhARrxupG2Tm6wOibxKPIrlMd7vi8wc0+n",
// 	"VziBDvlcGRWoVfeUHZugVDj244MFswK6Ge/flYZlFAU+wuFUceG6ZqnJSiHPGY3xFIVEdtH1OiGnrFXw",
// 	"VGF5iKXsojdR9E3XIvMjLxFNJMAMIoamUcIQDXmMg4D4mWEmRnUfR7JmW5TE6BpWJmtbOX3ZVfVml6kz",
// 	"NXPmCx1nVUxqr+KZ15o/0+mWAscD8iTPoYuHS1Ww72cRXM7yaeD7Z5Qu8lRibmJFeirSidz8LX3ISySN",
// 	"GN+QKjMnDjzIFA113omuFy4TchxAxgNAWZmU2kzXxKcckDMNr6LgCvJdiMZbzEcTzOIp2js9Rh4OApkt",
// 	"Cp3jm5T/5oRdUY/UEMJzWH7TtBNzpX9LFPpTWT81IEtI0HDTHIP+IPQAr8x+qlEQEJlLozYRrZXGTweq",
// 	"7Zvu7uy01ugNHpGqyw1pAk1H4Hy+0Qm6JIOIQQlrFssCyrqZ8npLu3AS64f4V0LYNH2J0WAgP6avxScD",
// 	"nARxZ3fd5fHbap0yoU/J1AEd05KZNxpNfSDAS0AlZpQrZhJKQMuUMVDN2VrPNWFEaxi6JWtSn/s4u7As",
// 	"Ahk6YGJAg5gwdAnMM+FoCAOBWkNhZmU3yFQwdyYAdFmLK4ePGCJ/JTjQlYobTxU02Egg2fu2uwia7CId",
// 	"e8YtfHeYAeYBJVbFeReUWNXtl1DyU0LJnDmKLNEwcfJVHMZEUox+2rfjyJYpcym4kxlFMQ4s1KuKtmj3",
// 	"N2fktUS5u9U4XA40IQxN8NA9jqIajQYStGpCfE2u4hHhRH5yRZQsOa5ZOa43ghXJMhiG20ph7EFIrekm",
// 	"u4IBy5Y8SD+uIID3FSTBdUWmb66WWO2hSTiMRz8+6Xm6BDdf2rxKQnuu1IKUVnaj4kyLKPili5sBOS9R",
// 	"020LLNiw8QugprTkgvkx7whrPjRESvdShCGHeWykpHLDNyt3pxPJYw/wcImmyQz5A2ory2ztCoV5ViH7",
// 	"+jTtUECvL7FaTc1lWWtPNHUmEw9w04FEy/JxZqoBbTZqertGHkVh/eqgleL+6kPGrPOzj2DFUXf6wdWZ",
// 	"vjfcX3NeVjUNWSCg4yYHK50x4VzIBrudvbSgo7OyLg4Ywf4U3NVxaN4+ehMNEQ3B7EewBXV+ItdlLb6c",
// 	"nJcVMYCuSGUdLICzWXy+68tkjMNVsV6IH1Lt5L6K6bT0WRTGr88/W9LVBWWu8+V4TLKFYedXIU2DvEWh",
// 	"9U8Pgj5r8qJTJwGxTZHRLnq0FxBPVvM2aGkXPToj0zAKfC6/NK4CbpWw/vkKgJvDmpvNLD1oaTQTZ21l",
// 	"XDIHLr/qM7dazLmMuNnhmiS/9XXn9KWtZovjjBMeo0til7wF7be0E8QjQplGIW4RTC/EeoAPiOJt1PdI",
// 	"wjRH9q8jIhEvYZCS5U9xt9E3SvriGDq7f34Vwm9BhKpDz6IzCWOgoEa+/nmx9tqaeVkTRq5olPBgqh6Z",
// 	"A6cbiWuB8GwDActCQm0LjjcoiJdy6BxfEb8cDWXErwweWuCiddKfC4eSE6LhMF/G7g5q2M0iUf4EAmR5",
// 	"1tkT9cXifh17S/3vZhJF70jsfHDS45KW3paWqniiJTGtJKYqD1ZRQHqDEzb9iaWZVmT2riQfOMQqcUTT",
// 	"PdLCr90iYg7CbwZsSPr3zALmxQPMTvvraLZd+tJQprzOUY+2qBrFPasuj6nDsyQT90Umcl7geyk/uaQW",
// 	"BWqRIhfs++qoJO1QX1SEao6W7JOA4kdKcWPr23reKBmP9Rc1Rn9jFz3a3HyCnhM/xAztJ+yK6DYeZGV8",
// 	"dIBDSoIrGgTpF6vO8y569HtPfxBYFQf692dPNraemk+CrdxFj3aebaw+2dle3X76+Bm62VnfePYsHXY8",
// 	"waGY8+N0jEP05s1+fr2bu+iRGZFFVzT0xKBHJGLDdN+a8ZYhqo4o3p+KtqaE68dTWTU1RPvK31y0F4DO",
// 	"qAsdikcJfJkWBgJlizwQZtp6Kgfml44FjNkWFkTKlr/3Mg0syJTfATjFExffvzdhG9b+0WtumpE+NBTV",
// 	"lKFrw0SorEOlbESKQFs4llg0nsE6SyIK0r3ep4PJUjT8yWm+Th0ULsl9Q3IvsYqm+OkzXCAC1izpUD0S",
// 	"/QHK2Ty32VZUuy2OlUL/HeDY2cTHtlLiUtm3xOhuZd9SkGuN2SUuKGJ2FRWckeOOaIgfPRCxZUacf1ea",
// 	"QnG0lYpCSLLAG7kv6HDFDOWBIs4N3RJk2zry8j4hbJoa0TjBzBtB3LKZyhVW9VenVUKhYz+TZkJmhBAz",
// 	"iUnL5gDa1WKSXozjhBfHJjeTAPzPBjjgxD0Xh76Z+UxoUInXWBr5w+NpIH4YRGzssH2+sLJk8Fus0cq2",
// 	"0b/L9eoUPbdZq8oSc6frPKB8EuCp4I4awZMv2/fbwlWjwVUahjsYWXvZzntcmYqg9ZoFP7qFvBFm2IsJ",
// 	"Q8e9d8hLGCOhNwU/Tl2VaMKoRziQQB/JcJYmkKPH6iuf0HRp5CYmLMTBQeRxVwkSO8hbdAbklTBBmTRp",
// 	"IWH3mn6jE+JT3I3YcE38tXbce9d/vLnx9F97XkyvCMzMLYBMIbQGIhude4xv+kwGP7Y49mUA9TI0dhlA",
// 	"vYSS+4ISD4ceCSqQifq+hJOHAycvo2s0xuFUyQJplpDuXaUJEcyFjADWBWBSkKwWSG6dHOW3/Wg8xogT",
// 	"IS7FxEfypP6NPo6oIOiUBD5HfBQlgS8EdBp6QeIrB/IWC5UDtSP+NWtjJMAqeYxZHrmZ4HCG5cl+nR8Z",
// 	"6ftrpU1Y6aRKgEbZJ6B5UTxaKi8XS3kJOR2MzmWpriyqK4VsJg8o4/Qvn8MMCSBkx3uNAVAKvbbWpoJe",
// 	"UCfVtdLjzqYglKYpXYdBDdc1WZfVDwgzoppCpGKx/BoOfZX+XAZEqfdBL2mgCg8PSOyN1CB6nkZ6STXZ",
// 	"idrqXImJVjtZ52hwbKu6FiEhvlKJulOgRyjhRIV4Fo/c7WpfV9ezIuX69YiwbI0NlfWWqjt3+tMvacbi",
// 	"R4rpq07fw5J2FGnHJIM0iqmEcg+/km7k2t5b8qAKAnA7gqJDdVYZUTxsWSkMTuKcb4PuixIOkVnpD3H0",
// 	"jYSm7MPlVHxTN4fSKWUrdQo1LhEw/2mazWKRk4jcXcoOODH3sHB/uRuoTddRyMqhp1i6XPyKhTc40JgU",
// 	"FB52qghmoxTp1D5TAgj4Bs8m+wF++pm9J7K0YW6eELdO9mDawAkXGqhfy1wrsuSnSYorF2q1I4ppiDDi",
// 	"ySUXhxzGaA06rJoOmsKhc+DJM8OkWjgOBTYSkNMuhUxFusMuuqJYp9wJhQQWBFA8CkomxQkLXXVinb6E",
// 	"GtDPFWFYXALqpFFugvS4OPWSQtwlhVBYRMMwkIyHTymGJBTvi2TeUA3FyOD9HK5fW7NCAlVDD8feyNVS",
// 	"VoOWre6TCEhy9kOIQBZ1D+kgXvUw8/naPwKkmiVJPaKDGO1jBuIHFaIL55FHQSBJwr9oQsDxw6mHEn1F",
// 	"V74v/Upqna6TkP6VEGtOPbTD3Vr5qtxXMIs4zb44zTpGPG24zJF6uxypGVBUIKUxpvn2IFDmUD8cO0uq",
// 	"T2wG2IBVJQdsWt1H5p4CwrGQUY1XLpRESyYIjO2yzD0Nh0ia5N1K72a+t6BtTp0YZS5GFRoPIzTyZKxF",
// 	"OtJcWWZuV4xoikhV7kLKVUm4hn57mvErX069kqXGve7cLgWnHL/nsHI9ZD9NQ1RqX0hjPd0Msmwg/SDz",
// 	"xetKsxx9dxgLskcxX3IhLcrNzM5LMjF7ln+BN34HvAGv2aIQ8u+HQB2UN0kQRd+SCWxL8tApitpFGyvN",
// 	"uWplD643/N4HEZGb/X/p3v6zIda4uQ17+49jZ1kSA9Ws1v5RvuKNeF4FO4LLiAvln2Xhz2vMpc4iWxbT",
// 	"UJAS6gT/FaMcN6qSKrO3VRSdTj3g74sNXuK1H8b+CqZXlg18yFhNM7zPp/Kd6GKbPxW6UkgnayxUn/5p",
// 	"h4VqkEm7UOYsh7tAtUeWaOTHVRr5BVgjIzXD3z8d9sghDlVup52Lmio55JaV9ceZI1X1koBHonFAVpDV",
// 	"cwVdYUZxGD/i+mv6A/+WrIARJo130M3mE/iq1oaOD2YMpMyF50UhUVkW8sJz88DKr/WSdlrqp7jypnF8",
// 	"diWduwkAPcfDmZcH6OZOVgXQ0ywiVQNaC4Cy/moY9Wp1bzXTCId+043Iti3Dtc2ooD8E3ZxSrVHe1z/9",
// 	"R9D+0gjxtJ1r7ssoCggOnRGy00nTOxJjzTtU06CsZZzmMgKvCYgsgzR/2eA7Awi6mHgmouvO4uHe0DGV",
// 	"+ePTcCezFNtPpXUg4EzheKVxeHagG8HeSLHUSsisPqQGwW6zL8wOEGy7sAZBgssovNtF4dmCTJsq0Hcd",
// 	"iffrFUK2BECtBFA/PQg1gAY0R9CC+jJD7Fs66P0EL+j5HZqBNclTV4QdJOBbKTlvQHwoClPaIkUAsJzK",
// 	"JiQc0pBA/UEcBJBMRt2J00tSg5OUL5roJOUa4gixJLQnvqbxqCoBVnMF5Q+g7j+cohcmnC9FGtHYkeVn",
// 	"T6BcsXB5Plz630p2S5NWSQ58MiGhzwWw1MCS/MyuMkVplrj9trhdyfe/CnaXACaN33/toke9EWWFQpIC",
// 	"qCvxumhwNzi9gYNoDoP/v7/+ozdRwPFt69pXan41PMxSxn4+BqSKemW2p/sjjjzbAD6PHHDZmWRStsyk",
// 	"iCqaKHAd5eLPEQkmgwSkThLyhBHkRYwRzyRdw4yYkpZSXY7V0IuSDe52e9FTPMCkcvOlolpoaSrbLOnd",
// 	"7eyZKMVlD5raGaOm+iVn1tRmrwYizH2YNjNkzCJvEgm2s22eyT5OAqe+1RE2Iwyo+RdA06dXcveKvgaq",
// 	"cL2YpbFkaSxpACFLW8kDh5D5skgW0m+kB5btl2rgeauBU2KpOSf5y4NgnBSQFXXAGnNVcUqm8/3oetX0",
// 	"RT6puRbgzMieZTySuutWKoCzrES7QC6kCkc0xCRLzHFLocsAzwPGHEbiMpqaIhppgEXuQ9yy0UUGiwjZ",
// 	"YpURzNsLXaIrOpNdS/CKaKJadOb8usXQfWvhDRkHq9uSf5g//2DDRAYZWB8eCE6wYNvFU9jwWYMU7Kb3",
// 	"x2HYmKAURbThN6wrr0cPCjRaMh+5KRaPB7HRTTvctMRFt+ZIbJzz6+Aii0sRPxS4FAvKmuOl++FZCpin",
// 	"gJd4k0Rj6sbBbhWWBeWeRlxhJD63NF6GJ3FgMfCQiCPto6gVzWdpdQd31mTxc2n64tSK+YaGBB3HZJxW",
// 	"pzYbL6iRwsilR9pD4nexRuz7OimGmD6jki4M9leCwxhy77odfeTXbCWLom+gAd66jcpBEDNEoDrtmT4+",
// 	"a51fHQEmOlCsbvZ3upaeFfWtwY1FY+cBqYelk1IUpzjOkDfKVVI8GeHh6zh0eCRIArHKka3zhCEPh8gb",
// 	"RREnKfibip4yg28X7QVgd42vSDAtdtexJ+lC4hEZcxJcSQNsLmBzosOMag7MrOKdCaCxji63xrIzzN1p",
// 	"OvlXhy4721Tfq35f88/IKq+3GbVfkvlbkHmJ4BV0Fgj8A6LsvCufiPRs0iAMGT0AiHfRnzL/m0oDJ3/W",
// 	"TcT/NK7bRRvyp+/i/77mXKMUKq1nCu4lgao6i7mlytPnKLPlYT7AfGAlQYWTFd/+1IdoTld/tjpne8sm",
// 	"+tBFmw394bv8x9dsLj5NC1YlKmunicmhVLcuRjdSbeoErY8jEo8I0yCRn8IRY9FFz6dIWZ4RDoJiH+VF",
// 	"VGnMprzP9HtuE0y4h7xcfaZc4DOiPtBRZRwrLO5yWrak1L2iZcmoVD+umB24ueLUmsjN7hM2X6nVJOOy",
// 	"gLGRdi3Xcalfm7NMm4cci+blPj0I4sezKKuoZMsDaiXlyje+L0VbHtVXUIF2aapK6UEaKAaynPGfraMR",
// 	"zRNTZVNiLWxyqiViW1TDwSBiADq/IEYT21Z/u3JbPQgclyIyG9td40kj9V3vGk9QFGYS8clCXgI8eDS2",
// 	"tGmKX8VBFA5lMtLsd05CH11i75tT/9eDJc1L+4d9n4qGOOg3UQSSG2+EwyGxtFrEN58rNILNFW6we4Wp",
// 	"VQYet/ZNfWygz9Hs9QfZQ89Sr7SxprhDXRzAjkotUqaI+7m1tBCHXaKnvSTwQq7xZHJrZa0Y5daqWjA6",
// 	"wF+UF9W/t1PZ5tSqmlbfhz4yVTJmQGyliBLmr34U91TLz4g2S6bl1qpHSZtspkX8+SA4FUEJy9WONljP",
// 	"rH2E7/kXURwtJRQt1ZliD9XskkBp96HKhNP9UYpM+64a6zMHmLfRZprJ8tdZPmF6rTPOmdOgiiNtKTAD",
// 	"c+DO6mySOUfhgLKx4SXccrOYW/xnVol5YQXmJS25x1zOD4yYNMnkfE8ou4FEm0UvFuJReGymbKxaauIu",
// 	"rGJ9q0Qn9aYPLZtlTSDlFo/Wlo7mS2AkwLEOsAwi7M8zL1g+o4tmHeYYzdlZT7n/8qIuJ/iGjpOxFcyZ",
// 	"v/Cs+0vLsM7OxnqjZeSOAZWkRW2Uq7WQJjVNg5udFCNOw6GYJzfb5dQhgOZ7j5MgphPdm+e7zzG/7gsT",
// 	"JZeqx2l4RcI4YlPDYZa9EN2wbzVsdDYT4tEB9TRo2PvrFu+0sGrVWCZogsA+HPrZOMU0TNPhp1MdVFnc",
// 	"vyPCUq2tuNa6mMq60QvRieUzBW23kYuvrBqZzDx04w0UAyq/zpt1s8lSm9x6fdVxaeOYM4vnIPm59BT6",
// 	"UzXPd4dMjoYZB3ez9k8qr7XKOmQov3g8fhWfo3c/SwoiPUuJ6TGja75lSqJ8+R93bp15pyfKR1y2nPdH",
// 	"pxZa5gRqhJ1b4+QlDp5PbiCUIptFRcKZeAexE0iPKJeRBXQ8oV01lBDDCPNIOh5ArtpjQWxL4hEioT+J",
// 	"KIgkIwyee9E10uW45fLFG9OFi4HfHOMQDwV3PiKUIU44136H6mGLkV01LQTGdE4I3uaCpxUYkgs5Teoc",
// 	"rDGVouxmlRF50EBARPvq6hk185mGJbOa78W59fNMx3CtRDvV16zDHLBzFboAeHH/+ktx5rQ+bvXUQ9FO",
// 	"1n5wzZ2W0i1MbtUyLswurbHVM8v6Ns5ZdU2i3Iyq5lNhNv16q+czqVZdM6Zpw9zXXDGr5nEazZ5qJSpW",
// 	"YSGoEqBL+fQiFzash3ud9MK1BhPLn5vapF1x8H1pSF3txFa8Ttn82ci9wjKyQdwlq2myjKr5yyZ2zJg3",
// 	"IldPbarRapce1xry7k+FxRR90gqrusaTuqVc40nJ/NKwmZ8UlP1fv/9/AQAA//86u5fRKvUCAA==",
// }

// // GetSwagger returns the content of the embedded swagger specification file
// // or error if failed to decode
// func decodeSpec() ([]byte, error) {
// 	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
// 	if err != nil {
// 		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
// 	}
// 	zr, err := gzip.NewReader(bytes.NewReader(zipped))
// 	if err != nil {
// 		return nil, fmt.Errorf("error decompressing spec: %s", err)
// 	}
// 	var buf bytes.Buffer
// 	_, err = buf.ReadFrom(zr)
// 	if err != nil {
// 		return nil, fmt.Errorf("error decompressing spec: %s", err)
// 	}

// 	return buf.Bytes(), nil
// }

// var rawSpec = decodeSpecCached()

// // a naive cached of a decoded swagger spec
// func decodeSpecCached() func() ([]byte, error) {
// 	data, err := decodeSpec()
// 	return func() ([]byte, error) {
// 		return data, err
// 	}
// }

// // Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
// func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
// 	var res = make(map[string]func() ([]byte, error))
// 	if len(pathToFile) > 0 {
// 		res[pathToFile] = rawSpec
// 	}

// 	return res
// }

// // GetSwagger returns the Swagger specification corresponding to the generated code
// // in this file. The external references of Swagger specification are resolved.
// // The logic of resolving external references is tightly connected to "import-mapping" feature.
// // Externally referenced files must be embedded in the corresponding golang packages.
// // Urls can be supported but this task was out of the scope.
// func GetSwagger() (swagger *openapi3.T, err error) {
// 	var resolvePath = PathToRawSpec("")

// 	loader := openapi3.NewLoader()
// 	loader.IsExternalRefsAllowed = true
// 	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
// 		var pathToFile = url.String()
// 		pathToFile = path.Clean(pathToFile)
// 		getSpec, ok := resolvePath[pathToFile]
// 		if !ok {
// 			err1 := fmt.Errorf("path not found: %s", pathToFile)
// 			return nil, err1
// 		}
// 		return getSpec()
// 	}
// 	var specData []byte
// 	specData, err = rawSpec()
// 	if err != nil {
// 		return
// 	}
// 	swagger, err = loader.LoadFromData(specData)
// 	if err != nil {
// 		return
// 	}
// 	return
// }
