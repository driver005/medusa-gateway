// Package medusa provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package medusa

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Api_tokenScopes   = "api_token.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
)

// Defines values for BatchJobStatus.
const (
	BatchJobStatusCanceled     BatchJobStatus = "canceled"
	BatchJobStatusCompleted    BatchJobStatus = "completed"
	BatchJobStatusConfirmed    BatchJobStatus = "confirmed"
	BatchJobStatusCreated      BatchJobStatus = "created"
	BatchJobStatusFailed       BatchJobStatus = "failed"
	BatchJobStatusPreProcessed BatchJobStatus = "pre_processed"
	BatchJobStatusProcessing   BatchJobStatus = "processing"
)

// Defines values for BatchJobType.
const (
	ProductExport BatchJobType = "product-export"
	ProductImport BatchJobType = "product-import"
)

// Defines values for DiscountConditionOperator.
const (
	In    DiscountConditionOperator = "in"
	NotIn DiscountConditionOperator = "not_in"
)

// Defines values for DiscountConditionType.
const (
	CustomerGroups     DiscountConditionType = "customer_groups"
	ProductCollections DiscountConditionType = "product_collections"
	ProductTags        DiscountConditionType = "product_tags"
	ProductTypes       DiscountConditionType = "product_types"
	Products           DiscountConditionType = "products"
)

// Defines values for DiscountRuleAllocation.
const (
	Item  DiscountRuleAllocation = "item"
	Total DiscountRuleAllocation = "total"
)

// Defines values for DiscountRuleType.
const (
	Fixed        DiscountRuleType = "fixed"
	FreeShipping DiscountRuleType = "free_shipping"
	Percentage   DiscountRuleType = "percentage"
)

// Defines values for DraftOrderStatus.
const (
	DraftOrderStatusCompleted DraftOrderStatus = "completed"
	DraftOrderStatusOpen      DraftOrderStatus = "open"
)

// Defines values for InviteRole.
const (
	Admin     InviteRole = "admin"
	Developer InviteRole = "developer"
	Member    InviteRole = "member"
)

// Defines values for OrderFulfillmentStatus.
const (
	OrderFulfillmentStatusCanceled           OrderFulfillmentStatus = "canceled"
	OrderFulfillmentStatusFulfilled          OrderFulfillmentStatus = "fulfilled"
	OrderFulfillmentStatusNotFulfilled       OrderFulfillmentStatus = "not_fulfilled"
	OrderFulfillmentStatusPartiallyFulfilled OrderFulfillmentStatus = "partially_fulfilled"
	OrderFulfillmentStatusPartiallyReturned  OrderFulfillmentStatus = "partially_returned"
	OrderFulfillmentStatusPartiallyShipped   OrderFulfillmentStatus = "partially_shipped"
	OrderFulfillmentStatusRequiresAction     OrderFulfillmentStatus = "requires_action"
	OrderFulfillmentStatusReturned           OrderFulfillmentStatus = "returned"
	OrderFulfillmentStatusShipped            OrderFulfillmentStatus = "shipped"
)

// Defines values for OrderPaymentStatus.
const (
	OrderPaymentStatusAwaiting          OrderPaymentStatus = "awaiting"
	OrderPaymentStatusCanceled          OrderPaymentStatus = "canceled"
	OrderPaymentStatusCaptured          OrderPaymentStatus = "captured"
	OrderPaymentStatusNotPaid           OrderPaymentStatus = "not_paid"
	OrderPaymentStatusPartiallyRefunded OrderPaymentStatus = "partially_refunded"
	OrderPaymentStatusRefuneded         OrderPaymentStatus = "refuneded"
	OrderPaymentStatusRequiresAction    OrderPaymentStatus = "requires_action"
)

// Defines values for OrderStatus.
const (
	OrderStatusArchived       OrderStatus = "archived"
	OrderStatusCanceled       OrderStatus = "canceled"
	OrderStatusCompleted      OrderStatus = "completed"
	OrderStatusPending        OrderStatus = "pending"
	OrderStatusRequiresAction OrderStatus = "requires_action"
)

// Defines values for OrderItemChangeType.
const (
	ItemAdd    OrderItemChangeType = "item_add"
	ItemRemove OrderItemChangeType = "item_remove"
	ItemUpdate OrderItemChangeType = "item_update"
)

// Defines values for PriceListStatus.
const (
	PriceListStatusActive PriceListStatus = "active"
	PriceListStatusDraft  PriceListStatus = "draft"
)

// Defines values for PriceListType.
const (
	Override PriceListType = "override"
	Sale     PriceListType = "sale"
)

// Defines values for ProductStatus.
const (
	ProductStatusDraft     ProductStatus = "draft"
	ProductStatusProposed  ProductStatus = "proposed"
	ProductStatusPublished ProductStatus = "published"
	ProductStatusRejected  ProductStatus = "rejected"
)

// Defines values for ReturnStatus.
const (
	ReturnStatusCanceled       ReturnStatus = "canceled"
	ReturnStatusReceived       ReturnStatus = "received"
	ReturnStatusRequested      ReturnStatus = "requested"
	ReturnStatusRequiresAction ReturnStatus = "requires_action"
)

// Defines values for ShippingOptionPriceType.
const (
	Calculated ShippingOptionPriceType = "calculated"
	FlatRate   ShippingOptionPriceType = "flat_rate"
)

// Defines values for ShippingOptionRequirementType.
const (
	MaxSubtotal ShippingOptionRequirementType = "max_subtotal"
	MinSubtotal ShippingOptionRequirementType = "min_subtotal"
)

// Defines values for ShippingProfileType.
const (
	ShippingProfileTypeCustom   ShippingProfileType = "custom"
	ShippingProfileTypeDefault  ShippingProfileType = "default"
	ShippingProfileTypeGiftCard ShippingProfileType = "gift_card"
)

// Defines values for SwapFulfillmentStatus.
const (
	SwapFulfillmentStatusCanceled       SwapFulfillmentStatus = "canceled"
	SwapFulfillmentStatusFulfilled      SwapFulfillmentStatus = "fulfilled"
	SwapFulfillmentStatusNotFulfilled   SwapFulfillmentStatus = "not_fulfilled"
	SwapFulfillmentStatusRequiresAction SwapFulfillmentStatus = "requires_action"
	SwapFulfillmentStatusShipped        SwapFulfillmentStatus = "shipped"
)

// Defines values for SwapPaymentStatus.
const (
	SwapPaymentStatusAwaiting           SwapPaymentStatus = "awaiting"
	SwapPaymentStatusCanceled           SwapPaymentStatus = "canceled"
	SwapPaymentStatusCaptured           SwapPaymentStatus = "captured"
	SwapPaymentStatusConfirmed          SwapPaymentStatus = "confirmed"
	SwapPaymentStatusDifferenceRefunded SwapPaymentStatus = "difference_refunded"
	SwapPaymentStatusNotPaid            SwapPaymentStatus = "not_paid"
	SwapPaymentStatusPartiallyRefunded  SwapPaymentStatus = "partially_refunded"
	SwapPaymentStatusRefunded           SwapPaymentStatus = "refunded"
	SwapPaymentStatusRequiresAction     SwapPaymentStatus = "requires_action"
)

// Represent an OAuth app
type OAuth struct {
	// The app's name
	ApplicationName string `json:"application_name"`

	// Any data necessary to the app.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The app's display name
	DisplayName string `json:"display_name"`

	// The app's ID
	Id string `json:"id"`

	// The URL to install the app
	InstallUrl *string `json:"install_url,omitempty"`

	// The URL to uninstall the app
	UninstallUrl *string `json:"uninstall_url,omitempty"`
}

// An address.
type Address struct {
	// Address line 1
	Address1 *string `json:"address_1,omitempty"`

	// Address line 2
	Address2 *string `json:"address_2,omitempty"`

	// City
	City *string `json:"city,omitempty"`

	// Company name
	Company *string `json:"company,omitempty"`

	// A country object. Available if the relation `country` is expanded.
	Country *map[string]interface{} `json:"country,omitempty"`

	// The 2 character ISO code of the country in lower case
	CountryCode *string `json:"country_code,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Available if the relation `customer` is expanded.
	Customer *[]map[string]interface{} `json:"customer,omitempty"`

	// ID of the customer this address belongs to
	CustomerId *string `json:"customer_id,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// First name
	FirstName *string `json:"first_name,omitempty"`

	// ID of the address
	Id *string `json:"id,omitempty"`

	// Last name
	LastName *string `json:"last_name,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone Number
	Phone *string `json:"phone,omitempty"`

	// Postal Code
	PostalCode *string `json:"postal_code,omitempty"`

	// Province
	Province *string `json:"province,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// A Batch Job.
type BatchJob struct {
	// The date of the concellation.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// The date of the completion.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// The date when the confirmation has been done.
	ConfirmedAt *time.Time `json:"confirmed_at,omitempty"`

	// The context of the batch job, the type of the batch job determines what the context should contain.
	Context *map[string]interface{} `json:"context,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The unique identifier of the user that created the batch job.
	CreatedBy *string `json:"created_by,omitempty"`

	// A user object. Available if the relation `created_by_user` is expanded.
	CreatedByUser *map[string]interface{} `json:"created_by_user,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Specify if the job must apply the modifications or not.
	DryRun *bool `json:"dry_run,omitempty"`

	// The date when the job failed.
	FailedAt *time.Time `json:"failed_at,omitempty"`

	// The unique identifier for the batch job.
	Id *string `json:"id,omitempty"`

	// The date from which the job has been pre processed.
	PreProcessedAt *time.Time `json:"pre_processed_at,omitempty"`

	// The date the job is processing at.
	ProcessingAt *time.Time `json:"processing_at,omitempty"`

	// The result of the batch job.
	Result *struct {
		AdvancementCount *float32 `json:"advancement_count,omitempty"`
		Count            *float32 `json:"count,omitempty"`
		Errors           *struct {
			Code    *interface{}   `json:"code,omitempty"`
			Err     *[]interface{} `json:"err,omitempty"`
			Message *string        `json:"message,omitempty"`
		} `json:"errors,omitempty"`
		FileKey         *string  `json:"file_key,omitempty"`
		FileSize        *float32 `json:"file_size,omitempty"`
		Progress        *float32 `json:"progress,omitempty"`
		StatDescriptors *struct {
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
			Name    *string `json:"name,omitempty"`
		} `json:"stat_descriptors,omitempty"`
	} `json:"result,omitempty"`

	// The status of the batch job.
	Status *BatchJobStatus `json:"status,omitempty"`

	// The type of batch job.
	Type BatchJobType `json:"type"`

	// The date with timezone at which the resource was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The status of the batch job.
type BatchJobStatus string

// The type of batch job.
type BatchJobType string

// Country details
type Country struct {
	// The country name appropriate for display.
	DisplayName string `json:"display_name"`

	// The country's ID
	Id *string `json:"id,omitempty"`

	// The 2 character ISO code of the country in lower case
	Iso2 string `json:"iso_2"`

	// The 2 character ISO code of the country in lower case
	Iso3 string `json:"iso_3"`

	// The normalized country name in upper case.
	Name string `json:"name"`

	// The numerical ISO code for the country.
	NumCode string `json:"num_code"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The region ID this country is associated with.
	RegionId *string `json:"region_id,omitempty"`
}

// Currency
type Currency struct {
	// The 3 character ISO code for the currency.
	Code string `json:"code"`

	// [EXPERIMENTAL] Does the currency prices include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The written name of the currency
	Name string `json:"name"`

	// The symbol used to indicate the currency.
	Symbol string `json:"symbol"`

	// The native symbol used to indicate the currency.
	SymbolNative string `json:"symbol_native"`
}

// Represents a customer
type Customer struct {
	// An address.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The customer's billing address ID
	BillingAddressId *string `json:"billing_address_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The customer's email
	Email openapi_types.Email `json:"email"`

	// The customer's first name
	FirstName *string `json:"first_name,omitempty"`

	// The customer groups the customer belongs to. Available if the relation `groups` is expanded.
	Groups *[]CustomerGroup `json:"groups,omitempty"`

	// Whether the customer has an account or not
	HasAccount *bool `json:"has_account,omitempty"`

	// The customer's ID
	Id *string `json:"id,omitempty"`

	// The customer's first name
	LastName *string `json:"last_name,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Available if the relation `orders` is expanded.
	Orders *[]map[string]interface{} `json:"orders,omitempty"`

	// The customer's phone number
	Phone *string `json:"phone,omitempty"`

	// Available if the relation `shipping_addresses` is expanded.
	ShippingAddresses *[]Address `json:"shipping_addresses,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Represents a customer group
type CustomerGroup struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The customers that belong to the customer group. Available if the relation `customers` is expanded.
	Customers *[]map[string]interface{} `json:"customers,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The customer group's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the customer group
	Name string `json:"name"`

	// The price lists that are associated with the customer group. Available if the relation `price_lists` is expanded.
	PriceLists *[]PriceList `json:"price_lists,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Represents a discount that can be applied to a cart for promotional purposes.
type Discount struct {
	// A unique code for the discount - this will be used by the customer to apply the discount
	Code string `json:"code"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The time at which the discount can no longer be used.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// The discount's ID
	Id *string `json:"id,omitempty"`

	// Whether the Discount has been disabled. Disabled discounts cannot be applied to carts
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// A flag to indicate if multiple instances of the discount can be generated. I.e. for newsletter discounts
	IsDynamic bool `json:"is_dynamic"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Represents a discount that can be applied to a cart for promotional purposes.
	ParentDiscount *Discount `json:"parent_discount,omitempty"`

	// The Discount that the discount was created from. This will always be a dynamic discount
	ParentDiscountId *string `json:"parent_discount_id,omitempty"`

	// The Regions in which the Discount can be used. Available if the relation `regions` is expanded.
	Regions *[]map[string]interface{} `json:"regions,omitempty"`

	// Holds the rules that governs how a Discount is calculated when applied to a Cart.
	Rule *DiscountRule `json:"rule,omitempty"`

	// The Discount Rule that governs the behaviour of the Discount
	RuleId *string `json:"rule_id,omitempty"`

	// The time at which the discount can be used.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The number of times a discount has been used.
	UsageCount *int `json:"usage_count,omitempty"`

	// The maximum number of times that a discount can be used.
	UsageLimit *int `json:"usage_limit,omitempty"`

	// Duration the discount runs between
	ValidDuration *string `json:"valid_duration,omitempty"`
}

// Holds rule conditions for when a discount is applicable
type DiscountCondition struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// customer groups associated with this condition if type = customer_groups. Available if the relation `customer_groups` is expanded.
	CustomerGroups *[]map[string]interface{} `json:"customer_groups,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Holds the rules that governs how a Discount is calculated when applied to a Cart.
	DiscountRule *DiscountRule `json:"discount_rule,omitempty"`

	// The ID of the discount rule associated with the condition
	DiscountRuleId string `json:"discount_rule_id"`

	// The discount condition's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The operator of the Condition
	Operator DiscountConditionOperator `json:"operator"`

	// product collections associated with this condition if type = product_collections. Available if the relation `product_collections` is expanded.
	ProductCollections *[]map[string]interface{} `json:"product_collections,omitempty"`

	// product tags associated with this condition if type = product_tags. Available if the relation `product_tags` is expanded.
	ProductTags *[]map[string]interface{} `json:"product_tags,omitempty"`

	// product types associated with this condition if type = product_types. Available if the relation `product_types` is expanded.
	ProductTypes *[]map[string]interface{} `json:"product_types,omitempty"`

	// products associated with this condition if type = products. Available if the relation `products` is expanded.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// The type of the Condition
	Type DiscountConditionType `json:"type"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The operator of the Condition
type DiscountConditionOperator string

// The type of the Condition
type DiscountConditionType string

// Holds the rules that governs how a Discount is calculated when applied to a Cart.
type DiscountRule struct {
	// The scope that the discount should apply to.
	Allocation *DiscountRuleAllocation `json:"allocation,omitempty"`

	// A set of conditions that can be used to limit when  the discount can be used. Available if the relation `conditions` is expanded.
	Conditions *[]map[string]interface{} `json:"conditions,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// A short description of the discount
	Description *string `json:"description,omitempty"`

	// The discount rule's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
	Type DiscountRuleType `json:"type"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value that the discount represents; this will depend on the type of the discount
	Value int `json:"value"`
}

// The scope that the discount should apply to.
type DiscountRuleAllocation string

// The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
type DiscountRuleType string

// Represents a draft order
type DraftOrder struct {
	// The date the draft order was canceled at.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The ID of the cart associated with the draft order.
	CartId *string `json:"cart_id,omitempty"`

	// The date the draft order was completed at.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The draft order's display ID
	DisplayId *string `json:"display_id,omitempty"`

	// The draft order's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of the cart associated with the draft order in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Whether to send the customer notifications regarding order updates.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the order associated with the draft order.
	OrderId *string `json:"order_id,omitempty"`

	// The status of the draft order
	Status *DraftOrderStatus `json:"status,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The status of the draft order
type DraftOrderStatus string

// Error defines model for error.
type Error struct {
	// A slug code to indicate the type of the error.
	Code *string `json:"code,omitempty"`

	// Description of the error that occurred.
	Message *string `json:"message,omitempty"`

	// A slug indicating the type of the error.
	Type *string `json:"type,omitempty"`
}

// Fulfillments are created once store operators can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a provider, which is typically an external shipping aggregator, shipping partner og 3PL, most plugins will have asynchronous communications with these providers through webhooks in order to automatically update and synchronize the state of Fulfillments.
type Fulfillment struct {
	// The date with timezone at which the Fulfillment was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// A claim order object. Available if the relation `claim_order` is expanded.
	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

	// The id of the Claim that the Fulfillment belongs to.
	ClaimOrderId *string `json:"claim_order_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// This contains all the data necessary for the Fulfillment provider to handle the fulfillment.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The cart's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of the fulfillment in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// The Fulfillment Items in the Fulfillment - these hold information about how many of each Line Item has been fulfilled. Available if the relation `items` is expanded.
	Items *[]FulfillmentItem `json:"items,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Flag for describing whether or not notifications related to this should be send.
	NoNotification *bool `json:"no_notification,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The id of the Order that the Fulfillment belongs to.
	OrderId *string `json:"order_id,omitempty"`

	// Represents a fulfillment provider plugin and holds its installation status.
	Provider *FulfillmentProvider `json:"provider,omitempty"`

	// The id of the Fulfillment Provider responsible for handling the fulfillment
	ProviderId string `json:"provider_id"`

	// The date with timezone at which the Fulfillment was shipped.
	ShippedAt *time.Time `json:"shipped_at,omitempty"`

	// A swap object. Available if the relation `swap` is expanded.
	Swap *map[string]interface{} `json:"swap,omitempty"`

	// The id of the Swap that the Fulfillment belongs to.
	SwapId *string `json:"swap_id,omitempty"`

	// The Tracking Links that can be used to track the status of the Fulfillment, these will usually be provided by the Fulfillment Provider. Available if the relation `tracking_links` is expanded.
	TrackingLinks *[]TrackingLink `json:"tracking_links,omitempty"`

	// The tracking numbers that can be used to track the status of the fulfillment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Correlates a Line Item with a Fulfillment, keeping track of the quantity of the Line Item.
type FulfillmentItem struct {
	// A fulfillment object. Available if the relation `fulfillment` is expanded.
	Fulfillment *map[string]interface{} `json:"fulfillment,omitempty"`

	// The id of the Fulfillment that the Fulfillment Item belongs to.
	FulfillmentId string `json:"fulfillment_id"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	Item *LineItem `json:"item,omitempty"`

	// The id of the Line Item that the Fulfillment Item references.
	ItemId string `json:"item_id"`

	// The quantity of the Line Item that is included in the Fulfillment.
	Quantity int `json:"quantity"`
}

// Represents a fulfillment provider plugin and holds its installation status.
type FulfillmentProvider struct {
	// The id of the fulfillment provider as given by the plugin.
	Id *string `json:"id,omitempty"`

	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
	IsInstalled *bool `json:"is_installed,omitempty"`
}

// Gift Cards are redeemable and represent a value that can be used towards the payment of an Order.
type GiftCard struct {
	// The remaining value on the Gift Card.
	Balance int `json:"balance"`

	// The unique code that identifies the Gift Card. This is used by the Customer to redeem the value of the Gift Card.
	Code string `json:"code"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The time at which the Gift Card can no longer be used.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// The cart's ID
	Id *string `json:"id,omitempty"`

	// Whether the Gift Card has been disabled. Disabled Gift Cards cannot be applied to carts.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The id of the Order that the Gift Card was purchased in.
	OrderId *string `json:"order_id,omitempty"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The id of the Region in which the Gift Card is available.
	RegionId string `json:"region_id"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value that the Gift Card represents.
	Value int `json:"value"`
}

// Gift Card Transactions are created once a Customer uses a Gift Card to pay for their Order
type GiftCardTransaction struct {
	// The amount that was used from the Gift Card.
	Amount int `json:"amount"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A gift card object. Available if the relation `gift_card` is expanded.
	GiftCard *map[string]interface{} `json:"gift_card,omitempty"`

	// The ID of the Gift Card that was used in the transaction.
	GiftCardId string `json:"gift_card_id"`

	// The gift card transaction's ID
	Id *string `json:"id,omitempty"`

	// Whether the transaction is taxable or not.
	IsTaxable *bool `json:"is_taxable,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the Order that the Gift Card was used to pay for.
	OrderId *string `json:"order_id,omitempty"`

	// The tax rate of the transaction
	TaxRate *float32 `json:"tax_rate,omitempty"`
}

// Images holds a reference to a URL at which the image file can be found.
type Image struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The image's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The URL at which the image file can be found.
	Url string `json:"url"`
}

// Represents an invite
type Invite struct {
	// Whether the invite was accepted or not.
	Accepted *bool `json:"accepted,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The date the invite expires at.
	ExporesAt *time.Time `json:"expores_at,omitempty"`

	// The invite's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The user's role.
	Role *InviteRole `json:"role,omitempty"`

	// The token used to accept the invite.
	Token *string `json:"token,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The email of the user being invited.
	UserEmail openapi_types.Email `json:"user_email"`
}

// The user's role.
type InviteRole string

// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
type LineItem struct {
	// Available if the relation `adjustments` is expanded.
	Adjustments *[]LineItemAdjustment `json:"adjustments,omitempty"`

	// Flag to indicate if the Line Item should be included when doing discount calculations.
	AllowDiscounts *bool `json:"allow_discounts,omitempty"`

	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The ID of the Cart that the Line Item belongs to.
	CartId *string `json:"cart_id,omitempty"`

	// A claim order object. Available if the relation `claim_order` is expanded.
	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

	// The id of the Claim that the Line Item belongs to.
	ClaimOrderId *string `json:"claim_order_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A more detailed description of the contents of the Line Item.
	Description *string `json:"description,omitempty"`

	// The total of discount of the line item
	DiscountTotal *int `json:"discount_total,omitempty"`

	// The quantity of the Line Item that has been fulfilled.
	FulfilledQuantity *int `json:"fulfilled_quantity,omitempty"`

	// The total of the gift card of the line item
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// Flag to indicate if the Line Item has fulfillment associated with it.
	HasShipping *bool `json:"has_shipping,omitempty"`

	// The cart's ID
	Id *string `json:"id,omitempty"`

	// [EXPERIMENTAL] Indicates if the line item unit_price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Flag to indicate if the Line Item is a Gift Card.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Is the item being returned
	IsReturn *bool `json:"is_return,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the Order that the Line Item belongs to.
	OrderId *string `json:"order_id,omitempty"`

	// The original tax total amount of the line item
	OriginalTaxTotal *int `json:"original_tax_total,omitempty"`

	// The original total amount of the line item
	OriginalTotal *int `json:"original_total,omitempty"`

	// The quantity of the content in the Line Item.
	Quantity int `json:"quantity"`

	// The amount that can be refunded from the given Line Item. Takes taxes and discounts into consideration.
	Refundable *int `json:"refundable,omitempty"`

	// The quantity of the Line Item that has been returned.
	ReturnedQuantity *int `json:"returned_quantity,omitempty"`

	// The quantity of the Line Item that has been shipped.
	ShippedQuantity *int `json:"shipped_quantity,omitempty"`

	// Flag to indicate if new Line Items with the same variant should be merged or added as an additional Line Item.
	ShouldMerge *bool `json:"should_merge,omitempty"`

	// The subtotal of the line item
	Subtotal *int `json:"subtotal,omitempty"`

	// A swap object. Available if the relation `swap` is expanded.
	Swap *map[string]interface{} `json:"swap,omitempty"`

	// The id of the Swap that the Line Item belongs to.
	SwapId *string `json:"swap_id,omitempty"`

	// Available if the relation `tax_lines` is expanded.
	TaxLines *[]LineItemTaxLine `json:"tax_lines,omitempty"`

	// The total of tax of the line item
	TaxTotal *int `json:"tax_total,omitempty"`

	// A URL string to a small image of the contents of the Line Item.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// The title of the Line Item, this should be easily identifiable by the Customer.
	Title string `json:"title"`

	// The total amount of the line item
	Total *int `json:"total,omitempty"`

	// The price of one unit of the content in the Line Item. This should be in the currency defined by the Cart/Order/Swap/Claim that the Line Item belongs to.
	UnitPrice bool `json:"unit_price"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// A product variant object. The Product Variant contained in the Line Item. Available if the relation `variant` is expanded.
	Variant *map[string]interface{} `json:"variant,omitempty"`

	// The id of the Product Variant contained in the Line Item.
	VariantId *string `json:"variant_id,omitempty"`
}

// Represents an Line Item Adjustment
type LineItemAdjustment struct {
	// The adjustment amount
	Amount float32 `json:"amount"`

	// The line item's adjustment description
	Description string `json:"description"`

	// Represents a discount that can be applied to a cart for promotional purposes.
	Discount *Discount `json:"discount,omitempty"`

	// The ID of the discount associated with the adjustment
	DiscountId *string `json:"discount_id,omitempty"`

	// The invite's ID
	Id *string `json:"id,omitempty"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	Item *LineItem `json:"item,omitempty"`

	// The ID of the line item
	ItemId string `json:"item_id"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// Represents an Line Item Tax Line
type LineItemTaxLine struct {
	// A code to identify the tax type by
	Code *string `json:"code,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The line item tax line's ID
	Id *string `json:"id,omitempty"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	Item *LineItem `json:"item,omitempty"`

	// The ID of the line item
	ItemId string `json:"item_id"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A human friendly name for the tax
	Name string `json:"name"`

	// The numeric rate to charge tax by
	Rate float32 `json:"rate"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Money Amounts represents an amount that a given Product Variant can be purcased for. Each Money Amount either has a Currency or Region associated with it to indicate the pricing in a given Currency or, for fully region-based pricing, the given price in a specific Region. If region-based pricing is used the amount will be in the currency defined for the Reigon.
type MoneyAmount struct {
	// The amount in the smallest currecny unit (e.g. cents 100 cents to charge $1) that the Product Variant will cost.
	Amount int `json:"amount"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Currency
	Currency *Currency `json:"currency,omitempty"`

	// The 3 character currency code that the Money Amount is given in.
	CurrencyCode string `json:"currency_code"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The money amount's ID
	Id *string `json:"id,omitempty"`

	// The maximum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
	MaxQuantity *int `json:"max_quantity,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The minimum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
	MinQuantity *int `json:"min_quantity,omitempty"`

	// Price Lists represents a set of prices that overrides the default price for one or more product variants.
	PriceList *PriceList `json:"price_list,omitempty"`

	// The ID of the price list associated with the money amount
	PriceListId *string `json:"price_list_id,omitempty"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The region's ID
	RegionId *string `json:"region_id,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The Product Variant contained in the Line Item. Available if the relation `variant` is expanded.
	Variant *map[string]interface{} `json:"variant,omitempty"`

	// The id of the Product Variant contained in the Line Item.
	VariantId *string `json:"variant_id,omitempty"`
}

// MultipleErrors defines model for multiple_errors.
type MultipleErrors struct {
	// Array of errors
	Errors  *[]Error `json:"errors,omitempty"`
	Message *string  `json:"message,omitempty"`
}

// Notes are elements which we can use in association with different resources to allow users to describe additional information in relation to these.
type Note struct {
	// Represents a User who can manage store settings.
	Author *User `json:"author,omitempty"`

	// The ID of the author (user)
	AuthorId *string `json:"author_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The note's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The ID of the resource that the Note refers to.
	ResourceId string `json:"resource_id"`

	// The type of resource that the Note refers to.
	ResourceType string `json:"resource_type"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The contents of the note.
	Value string `json:"value"`
}

// Notifications a communications sent via Notification Providers as a reaction to internal events such as `order.placed`. Notifications can be used to show a chronological timeline for communications sent to a Customer regarding an Order, and enables resends.
type Notification struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A customer object. Available if the relation `customer` is expanded.
	Customer *map[string]interface{} `json:"customer,omitempty"`

	// The ID of the Customer that the Notification was sent to.
	CustomerId *string `json:"customer_id,omitempty"`

	// The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The name of the event that the notification was sent for.
	EventName *string `json:"event_name,omitempty"`

	// The notification's ID
	Id *string `json:"id,omitempty"`

	// Represents a notification provider plugin and holds its installation status.
	Provider *NotificationProvider `json:"provider,omitempty"`

	// The id of the Notification Provider that handles the Notification.
	ProviderId *string `json:"provider_id,omitempty"`

	// The resends that have been completed after the original Notification.
	Resends *[]NotificationResend `json:"resends,omitempty"`

	// The ID of the resource that the Notification refers to.
	ResourceId string `json:"resource_id"`

	// The type of resource that the Notification refers to.
	ResourceType string `json:"resource_type"`

	// The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
	To string `json:"to"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Represents a notification provider plugin and holds its installation status.
type NotificationProvider struct {
	// The id of the notification provider as given by the plugin.
	Id string `json:"id"`

	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
	IsInstalled *bool `json:"is_installed,omitempty"`
}

// A resend of a Notification.
type NotificationResend struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A customer object. Available if the relation `customer` is expanded.
	Customer *map[string]interface{} `json:"customer,omitempty"`

	// The ID of the Customer that the Notification was sent to.
	CustomerId *string `json:"customer_id,omitempty"`

	// The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The name of the event that the notification was sent for.
	EventName *string `json:"event_name,omitempty"`

	// The notification resend's ID
	Id *string `json:"id,omitempty"`

	// The ID of the Notification that was originally sent.
	ParentId *string `json:"parent_id,omitempty"`

	// Notifications a communications sent via Notification Providers as a reaction to internal events such as `order.placed`. Notifications can be used to show a chronological timeline for communications sent to a Customer regarding an Order, and enables resends.
	ParentNotification *Notification `json:"parent_notification,omitempty"`

	// Represents a notification provider plugin and holds its installation status.
	Provider *NotificationProvider `json:"provider,omitempty"`

	// The ID of the Notification Provider that handles the Notification.
	ProviderId *string `json:"provider_id,omitempty"`

	// The ID of the resource that the Notification refers to.
	ResourceId *string `json:"resource_id,omitempty"`

	// The type of resource that the Notification refers to.
	ResourceType *string `json:"resource_type,omitempty"`

	// The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
	To *string `json:"to,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Represents an order
type Order struct {
	// An address.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The ID of the billing address associated with the order
	BillingAddressId *string `json:"billing_address_id,omitempty"`

	// The date the order was canceled on.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The ID of the cart associated with the order
	CartId *string `json:"cart_id,omitempty"`

	// The claims associated with the order. Available if the relation `claims` is expanded.
	Claims *[]map[string]interface{} `json:"claims,omitempty"`

	// Currency
	Currency *Currency `json:"currency,omitempty"`

	// The 3 character currency code that is used in the order
	CurrencyCode string `json:"currency_code"`

	// A customer object. Available if the relation `customer` is expanded.
	Customer *map[string]interface{} `json:"customer,omitempty"`

	// The ID of the customer associated with the order
	CustomerId string `json:"customer_id"`

	// The total of discount
	DiscountTotal *int `json:"discount_total,omitempty"`

	// The discounts used in the order. Available if the relation `discounts` is expanded.
	Discounts *[]map[string]interface{} `json:"discounts,omitempty"`

	// The order's display ID
	DisplayId *int `json:"display_id,omitempty"`

	// A draft order object. Available if the relation `draft_order` is expanded.
	DraftOrder *map[string]interface{} `json:"draft_order,omitempty"`

	// The ID of the draft order this order is associated with.
	DraftOrderId *string `json:"draft_order_id,omitempty"`

	// [EXPERIMENTAL] Order edits done on the order. Available if the relation `edits` is expanded.
	Edits *[]OrderEdit `json:"edits,omitempty"`

	// The email associated with the order
	Email openapi_types.Email `json:"email"`

	// The ID of an external order.
	ExternalId *string `json:"external_id,omitempty"`

	// The order's fulfillment status
	FulfillmentStatus *OrderFulfillmentStatus `json:"fulfillment_status,omitempty"`

	// The fulfillments used in the order. Available if the relation `fulfillments` is expanded.
	Fulfillments *[]Fulfillment `json:"fulfillments,omitempty"`

	// The total of gift cards with taxes
	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

	// The total of gift cards
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// The gift card transactions used in the order. Available if the relation `gift_card_transactions` is expanded.
	GiftCardTransactions *[]GiftCardTransaction `json:"gift_card_transactions,omitempty"`

	// The gift cards used in the order. Available if the relation `gift_cards` is expanded.
	GiftCards *[]map[string]interface{} `json:"gift_cards,omitempty"`

	// The order's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the processing of the order in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// The line items that belong to the order. Available if the relation `items` is expanded.
	Items *[]LineItem `json:"items,omitempty"`

	// Flag for describing whether or not notifications related to this should be send.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The total amount paid
	PaidTotal *int `json:"paid_total,omitempty"`

	// The order's payment status
	PaymentStatus *OrderPaymentStatus `json:"payment_status,omitempty"`

	// The payments used in the order. Available if the relation `payments` is expanded.
	Payments *[]Payment `json:"payments,omitempty"`

	// The amount that can be refunded
	RefundableAmount *int `json:"refundable_amount,omitempty"`

	// The total amount refunded if the order is returned.
	RefundedTotal *int `json:"refunded_total,omitempty"`

	// The refunds associated with the order. Available if the relation `refunds` is expanded.
	Refunds *[]map[string]interface{} `json:"refunds,omitempty"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The region's ID
	RegionId string `json:"region_id"`

	// The returns associated with the order. Available if the relation `returns` is expanded.
	Returns *[]map[string]interface{} `json:"returns,omitempty"`

	// A sales channel object. Available if the relation `sales_channel` is expanded.
	SalesChannel *map[string]interface{} `json:"sales_channel,omitempty"`

	// The ID of the sales channel this order is associated with.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// An address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The ID of the shipping address associated with the order
	ShippingAddressId *string `json:"shipping_address_id,omitempty"`

	// The shipping methods used in the order. Available if the relation `shipping_methods` is expanded.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// The total of shipping
	ShippingTotal *int `json:"shipping_total,omitempty"`

	// The order's status
	Status *OrderStatus `json:"status,omitempty"`

	// The subtotal of the order
	Subtotal *int `json:"subtotal,omitempty"`

	// The swaps associated with the order. Available if the relation `swaps` is expanded.
	Swaps *[]map[string]interface{} `json:"swaps,omitempty"`

	// The order's tax rate
	TaxRate *float32 `json:"tax_rate,omitempty"`

	// The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// The total amount of the order
	Total *int `json:"total,omitempty"`
}

// The order's fulfillment status
type OrderFulfillmentStatus string

// The order's payment status
type OrderPaymentStatus string

// The order's status
type OrderStatus string

// Order edit keeps track of order items changes.
type OrderEdit struct {
	// Line item changes array.
	Changes []OrderItemChange `json:"changes"`

	// The date with timezone at which the edit was confirmed.
	ConfirmedAt *time.Time `json:"confirmed_at,omitempty"`

	// The unique identifier of the user or customer who confirmed the order edit.
	ConfirmedBy *string `json:"confirmed_by,omitempty"`

	// The unique identifier of the user or customer who created the order edit.
	CreatedBy string `json:"created_by"`

	// The date with timezone at which the edit was declined.
	DeclinedAt *time.Time `json:"declined_at,omitempty"`

	// The unique identifier of the user or customer who declined the order edit.
	DeclinedBy *string `json:"declined_by,omitempty"`

	// An optional note why  the order edit is declined.
	DeclinedReason *string `json:"declined_reason,omitempty"`

	// The difference between the total amount of the order and total amount of edited order.
	DifferenceDue *int `json:"difference_due,omitempty"`

	// The total of discount
	DiscountTotal *int `json:"discount_total,omitempty"`

	// The order edit's ID
	Id *string `json:"id,omitempty"`

	// An optional note with additional details about the order edit.
	InternalNote *string `json:"internal_note,omitempty"`

	// Computed line items from the changes.
	Items *[]LineItem `json:"items,omitempty"`

	// Represents an order
	Order Order `json:"order"`

	// The ID of the order that is edited
	OrderId string `json:"order_id"`

	// The date with timezone at which the edit was requested.
	RequestedAt *time.Time `json:"requested_at,omitempty"`

	// The unique identifier of the user or customer who requested the order edit.
	RequestedBy *string `json:"requested_by,omitempty"`

	// The subtotal for line items computed from changes.
	Subtotal *int `json:"subtotal,omitempty"`

	// The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// The total amount of the edited order.
	Total *int `json:"total,omitempty"`
}

// Represents an order edit item change
type OrderItemChange struct {
	// The order item change's ID
	Id *string `json:"id,omitempty"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	LineItem *LineItem `json:"line_item,omitempty"`

	// The ID of the cloned line item.
	LineItemId *string `json:"line_item_id,omitempty"`

	// Order edit keeps track of order items changes.
	OrderEdit *OrderEdit `json:"order_edit,omitempty"`

	// The ID of the order edit
	OrderEditId string `json:"order_edit_id"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	OriginalLineItem *LineItem `json:"original_line_item,omitempty"`

	// The ID of the original line item in the order
	OriginalLineItemId *string `json:"original_line_item_id,omitempty"`

	// The order's status
	Type OrderItemChangeType `json:"type"`
}

// The order's status
type OrderItemChangeType string

// Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
type Payment struct {
	// The amount that the Payment has been authorized for.
	Amount int `json:"amount"`

	// The amount of the original Payment amount that has been refunded back to the Customer.
	AmountRefunded *int `json:"amount_refunded,omitempty"`

	// The date with timezone at which the Payment was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// The date with timezone at which the Payment was captured.
	CapturedAt *time.Time `json:"captured_at,omitempty"`

	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The id of the Cart that the Payment Session is created for.
	CartId *string `json:"cart_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Currency
	Currency *Currency `json:"currency,omitempty"`

	// The 3 character ISO currency code that the Payment is completed in.
	CurrencyCode string `json:"currency_code"`

	// The data required for the Payment Provider to identify, modify and process the Payment. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn't hold any state.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The payment's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of a payment in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the Order that the Payment is used for.
	OrderId *string `json:"order_id,omitempty"`

	// The id of the Payment Provider that is responsible for the Payment
	ProviderId string `json:"provider_id"`

	// A swap object. Available if the relation `swap` is expanded.
	Swap *map[string]interface{} `json:"swap,omitempty"`

	// The ID of the Swap that the Payment is used for.
	SwapId *string `json:"swap_id,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Represents a Payment Provider plugin and holds its installation status.
type PaymentProvider struct {
	// The id of the payment provider as given by the plugin.
	Id string `json:"id"`

	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
	IsInstalled *bool `json:"is_installed,omitempty"`
}

// Price Lists represents a set of prices that overrides the default price for one or more product variants.
type PriceList struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The Customer Groups that the Price List applies to. Available if the relation `customer_groups` is expanded.
	CustomerGroups *[]map[string]interface{} `json:"customer_groups,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The price list's description
	Description string `json:"description"`

	// The date with timezone that the Price List stops being valid.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// The price list's ID
	Id *string `json:"id,omitempty"`

	// [EXPERIMENTAL] Does the price list prices include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The price list's name
	Name string `json:"name"`

	// The Money Amounts that are associated with the Price List. Available if the relation `prices` is expanded.
	Prices *[]interface{} `json:"prices,omitempty"`

	// The date with timezone that the Price List starts being valid.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// The status of the Price List
	Status *PriceListStatus `json:"status,omitempty"`

	// The type of Price List. This can be one of either `sale` or `override`.
	Type *PriceListType `json:"type,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The status of the Price List
type PriceListStatus string

// The type of Price List. This can be one of either `sale` or `override`.
type PriceListType string

// Products are a grouping of Product Variants that have common properties such as images and descriptions. Products can have multiple options which define the properties that Product Variants differ by.
type Product struct {
	// A product collection object. Available if the relation `collection` is expanded.
	Collection *map[string]interface{} `json:"collection,omitempty"`

	// The Product Collection that the Product belongs to
	CollectionId *string `json:"collection_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// A short description of the Product.
	Description *string `json:"description,omitempty"`

	// Whether the Product can be discounted. Discounts will not apply to Line Items of this Product when this flag is set to `false`.
	Discountable *bool `json:"discountable,omitempty"`

	// The external ID of the product
	ExternalId *string `json:"external_id,omitempty"`

	// A unique identifier for the Product (e.g. for slug structure).
	Handle *string `json:"handle,omitempty"`

	// The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// The product's ID
	Id *string `json:"id,omitempty"`

	// Images of the Product. Available if the relation `images` is expanded.
	Images *[]Image `json:"images,omitempty"`

	// Whether the Product represents a Gift Card. Products that represent Gift Cards will automatically generate a redeemable Gift Card code once they are purchased.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// The Product Options that are defined for the Product. Product Variants of the Product will have a unique combination of Product Option Values. Available if the relation `options` is expanded.
	Options *[]ProductOption `json:"options,omitempty"`

	// The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// The ID of the Shipping Profile that the Product belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
	ProfileId string `json:"profile_id"`

	// The sales channels the product is associated with. Available if the relation `sales_channels` is expanded.
	SalesChannels *[]map[string]interface{} `json:"sales_channels,omitempty"`

	// The status of the product
	Status *ProductStatus `json:"status,omitempty"`

	// An optional subtitle that can be used to further specify the Product.
	Subtitle *string `json:"subtitle,omitempty"`

	// The Product Tags assigned to the Product. Available if the relation `tags` is expanded.
	Tags *[]ProductTag `json:"tags,omitempty"`

	// A URL to an image file that can be used to identify the Product.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// A title that can be displayed for easy identification of the Product.
	Title string `json:"title"`

	// Product Type can be added to Products for filtering and reporting purposes.
	Type *ProductType `json:"type,omitempty"`

	// The Product type that the Product belongs to
	TypeId *string `json:"type_id,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The Product Variants that belong to the Product. Each will have a unique combination of Product Option Values. Available if the relation `variants` is expanded.
	Variants *[]ProductVariant `json:"variants,omitempty"`

	// The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// The status of the product
type ProductStatus string

// Product Collections represents a group of Products that are related.
type ProductCollection struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// A unique string that identifies the Product Collection - can for example be used in slug structures.
	Handle *string `json:"handle,omitempty"`

	// The product collection's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Products contained in the Product Collection. Available if the relation `products` is expanded.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// The title that the Product Collection is identified by.
	Title string `json:"title"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Product Options define properties that may vary between different variants of a Product. Common Product Options are "Size" and "Color", but Medusa doesn't limit what Product Options that can be defined.
type ProductOption struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The product option's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A product object. Available if the relation `product` is expanded.
	Product *map[string]interface{} `json:"product,omitempty"`

	// The ID of the Product that the Product Option is defined for.
	ProductId string `json:"product_id"`

	// The title that the Product Option is defined by (e.g. "Size").
	Title string `json:"title"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The Product Option Values that are defined for the Product Option. Available if the relation `values` is expanded.
	Values *[]ProductOptionValue `json:"values,omitempty"`
}

// A value given to a Product Variant's option set. Product Variant have a Product Option Value for each of the Product Options defined on the Product.
type ProductOptionValue struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The product option value's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Product Options define properties that may vary between different variants of a Product. Common Product Options are "Size" and "Color", but Medusa doesn't limit what Product Options that can be defined.
	Option *ProductOption `json:"option,omitempty"`

	// The ID of the Product Option that the Product Option Value is defined for.
	OptionId string `json:"option_id"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value that the Product Variant has defined for the specific Product Option (e.g. if the Product Option is "Size" this value could be "Small", "Medium" or "Large").
	Value string `json:"value"`

	// Product Variants represent a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations.
	Variant *ProductVariant `json:"variant,omitempty"`

	// The ID of the Product Variant that the Product Option Value is defined for.
	VariantId string `json:"variant_id"`
}

// Product Tags can be added to Products for easy filtering and grouping.
type ProductTag struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The product tag's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value that the Product Tag represents
	Value string `json:"value"`
}

// Product Type can be added to Products for filtering and reporting purposes.
type ProductType struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The product type's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value that the Product Type represents.
	Value string `json:"value"`
}

// Product Variants represent a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations.
type ProductVariant struct {
	// Whether the Product Variant should be purchasable when `inventory_quantity` is 0.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// A generic field for a GTIN number that can be used to identify the Product Variant.
	Barcode *string `json:"barcode,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// An EAN barcode number that can be used to identify the Product Variant.
	Ean *string `json:"ean,omitempty"`

	// The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// The product variant's ID
	Id *string `json:"id,omitempty"`

	// The current quantity of the item that is stocked.
	InventoryQuantity int `json:"inventory_quantity"`

	// The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// Whether Medusa should manage inventory for the Product Variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// The Product Option Values specified for the Product Variant. Available if the relation `options` is expanded.
	Options *[]ProductOptionValue `json:"options,omitempty"`

	// The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// The Money Amounts defined for the Product Variant. Each Money Amount represents a price in a given currency or a price in a specific Region. Available if the relation `prices` is expanded.
	Prices *[]MoneyAmount `json:"prices,omitempty"`

	// A product object. Available if the relation `product` is expanded.
	Product *map[string]interface{} `json:"product,omitempty"`

	// The ID of the Product that the Product Variant belongs to.
	ProductId string `json:"product_id"`

	// The unique stock keeping unit used to identify the Product Variant. This will usually be a unqiue identifer for the item that is to be shipped, and can be referenced across multiple systems.
	Sku *string `json:"sku,omitempty"`

	// A title that can be displayed for easy identification of the Product Variant.
	Title string `json:"title"`

	// A UPC barcode number that can be used to identify the Product Variant.
	Upc *string `json:"upc,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The ranking of this variant
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// Regions hold settings for how Customers in a given geographical location shop. The is, for example, where currencies and tax rates are defined. A Region can consist of multiple countries to accomodate common shopping settings across countries.
type Region struct {
	// Whether taxes should be automated in this region.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// The countries that are included in the Region. Available if the relation `countries` is expanded.
	Countries *[]Country `json:"countries,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Currency
	Currency *Currency `json:"currency,omitempty"`

	// The 3 character currency code that the Region uses.
	CurrencyCode string `json:"currency_code"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The Fulfillment Providers that can be used to fulfill orders in the Region. Available if the relation `payment_providers` is expanded.
	FulfillmentProviders *[]FulfillmentProvider `json:"fulfillment_providers,omitempty"`

	// Whether the gift cards are taxable or not in this region.
	GiftCardsTaxable *bool `json:"gift_cards_taxable,omitempty"`

	// The cart's ID
	Id *string `json:"id,omitempty"`

	// [EXPERIMENTAL] Does the prices for the region include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the region as displayed to the customer. If the Region only has one country it is recommended to write the country name.
	Name string `json:"name"`

	// The Payment Providers that can be used to process Payments in the Region. Available if the relation `payment_providers` is expanded.
	PaymentProviders *[]PaymentProvider `json:"payment_providers,omitempty"`

	// The tax code used on purchases in the Region. This may be used by other systems for accounting purposes.
	TaxCode *string `json:"tax_code,omitempty"`

	// The tax service used to calculate taxes
	TaxProvider *TaxProvider `json:"tax_provider,omitempty"`

	// The ID of the tax provider used in this region
	TaxProviderId *string `json:"tax_provider_id,omitempty"`

	// The tax rate that should be charged on purchases in the Region.
	TaxRate float32 `json:"tax_rate"`

	// The tax rates that are included in the Region. Available if the relation `tax_rates` is expanded.
	TaxRates *[]TaxRate `json:"tax_rates,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Return orders hold information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can be used as part of a Swap.
type Return struct {
	// A claim order object. Available if the relation `claim_order` is expanded.
	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

	// The ID of the Claim that the Return is a part of.
	ClaimOrderId *string `json:"claim_order_id,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The return's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of the return in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// The Return Items that will be shipped back to the warehouse. Available if the relation `items` is expanded.
	Items *[]ReturnItem `json:"items,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// When set to true, no notification will be sent related to this return.
	NoNotification *bool `json:"no_notification,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the Order that the Return is made from.
	OrderId *string `json:"order_id,omitempty"`

	// The date with timezone at which the return was received.
	ReceivedAt *time.Time `json:"received_at,omitempty"`

	// The amount that should be refunded as a result of the return.
	RefundAmount int `json:"refund_amount"`

	// Data about the return shipment as provided by the Fulfilment Provider that handles the return shipment.
	ShippingData *map[string]interface{} `json:"shipping_data,omitempty"`

	// The Shipping Method that will be used to send the Return back. Can be null if the Customer facilitates the return shipment themselves. Available if the relation `shipping_method` is expanded.
	ShippingMethod *[]ShippingMethod `json:"shipping_method,omitempty"`

	// Status of the Return.
	Status *ReturnStatus `json:"status,omitempty"`

	// A swap object. Available if the relation `swap` is expanded.
	Swap *map[string]interface{} `json:"swap,omitempty"`

	// The ID of the Swap that the Return is a part of.
	SwapId *string `json:"swap_id,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Status of the Return.
type ReturnStatus string

// Correlates a Line Item with a Return, keeping track of the quantity of the Line Item that will be returned.
type ReturnItem struct {
	// Whether the Return Item was requested initially or received unexpectedly in the warehouse.
	IsRequested *bool `json:"is_requested,omitempty"`

	// Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
	Item *LineItem `json:"item,omitempty"`

	// The id of the Line Item that the Return Item references.
	ItemId string `json:"item_id"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// An optional note with additional details about the Return.
	Note *string `json:"note,omitempty"`

	// The quantity of the Line Item that is included in the Return.
	Quantity *int `json:"quantity,omitempty"`

	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
	Reason *ReturnReason `json:"reason,omitempty"`

	// The ID of the reason for returning the item.
	ReasonId *string `json:"reason_id,omitempty"`

	// The quantity that was received in the warehouse.
	RecievedQuantity *int `json:"recieved_quantity,omitempty"`

	// The quantity that was originally requested to be returned.
	RequestedQuantity *int `json:"requested_quantity,omitempty"`

	// The id of the Return that the Return Item belongs to.
	ReturnId string `json:"return_id"`

	// Return orders hold information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can be used as part of a Swap.
	ReturnOrder *Return `json:"return_order,omitempty"`
}

// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
type ReturnReason struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// A description of the Reason.
	Description *string `json:"description,omitempty"`

	// The cart's ID
	Id *string `json:"id,omitempty"`

	// A text that can be displayed to the Customer as a reason.
	Label string `json:"label"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
	ParentReturnReason *ReturnReason `json:"parent_return_reason,omitempty"`

	// The ID of the parent reason.
	ParentReturnReasonId *string `json:"parent_return_reason_id,omitempty"`

	// A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
	ReturnReasonChildren *ReturnReason `json:"return_reason_children,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The value to identify the reason by.
	Value string `json:"value"`
}

// A Sales Channel
type SalesChannel struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The description of the sales channel.
	Description *string `json:"description,omitempty"`

	// The sales channel's ID
	Id *string `json:"id,omitempty"`

	// Specify if the sales channel is enabled or disabled.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// The name of the sales channel.
	Name string `json:"name"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Shipping Methods represent a way in which an Order or Return can be shipped. Shipping Methods are built from a Shipping Option, but may contain additional details, that can be necessary for the Fulfillment Provider to handle the shipment.
type ShippingMethod struct {
	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The id of the Cart that the Shipping Method is used on.
	CartId *string `json:"cart_id,omitempty"`

	// A claim order object. Available if the relation `claim_order` is expanded.
	ClaimOrder *map[string]interface{} `json:"claim_order,omitempty"`

	// The id of the Claim that the Shipping Method is used on.
	ClaimOrderId *string `json:"claim_order_id,omitempty"`

	// Additional data that the Fulfillment Provider needs to fulfill the shipment. This is used in combination with the Shipping Options data, and may contain information such as a drop point id.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The shipping method's ID
	Id *string `json:"id,omitempty"`

	// [EXPERIMENTAL] Indicates if the shipping method price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The id of the Order that the Shipping Method is used on.
	OrderId *string `json:"order_id,omitempty"`

	// The amount to charge for the Shipping Method. The currency of the price is defined by the Region that the Order that the Shipping Method belongs to is a part of.
	Price int `json:"price"`

	// The id of the Return that the Shipping Method is used on.
	ReturnId *string `json:"return_id,omitempty"`

	// A return object. Available if the relation `return_order` is expanded.
	ReturnOrder *map[string]interface{} `json:"return_order,omitempty"`

	// Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

	// The id of the Shipping Option that the Shipping Method is built from.
	ShippingOptionId string `json:"shipping_option_id"`

	// A swap object. Available if the relation `swap` is expanded.
	Swap *map[string]interface{} `json:"swap,omitempty"`

	// The id of the Swap that the Shipping Method is used on.
	SwapId *string `json:"swap_id,omitempty"`

	// Available if the relation `tax_lines` is expanded.
	TaxLines *[]ShippingMethodTaxLine `json:"tax_lines,omitempty"`
}

// Shipping Method Tax Line
type ShippingMethodTaxLine struct {
	// A code to identify the tax type by
	Code *string `json:"code,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The line item tax line's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A human friendly name for the tax
	Name string `json:"name"`

	// The numeric rate to charge tax by
	Rate float32 `json:"rate"`

	// Shipping Methods represent a way in which an Order or Return can be shipped. Shipping Methods are built from a Shipping Option, but may contain additional details, that can be necessary for the Fulfillment Provider to handle the shipment.
	ShippingMethod *ShippingMethod `json:"shipping_method,omitempty"`

	// The ID of the line item
	ShippingMethodId string `json:"shipping_method_id"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
type ShippingOption struct {
	// The amount to charge for shipping when the Shipping Option price type is `flat_rate`.
	Amount *int `json:"amount,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The data needed for the Fulfillment Provider to identify the Shipping Option.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The shipping option's ID
	Id *string `json:"id,omitempty"`

	// [EXPERIMENTAL] Does the shipping option price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Flag to indicate if the Shipping Option can be used for Return shipments.
	IsReturn *bool `json:"is_return,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name given to the Shipping Option - this may be displayed to the Customer.
	Name string `json:"name"`

	// The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
	PriceType ShippingOptionPriceType `json:"price_type"`

	// Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// The ID of the Shipping Profile that the shipping option belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
	ProfileId string `json:"profile_id"`

	// Represents a fulfillment provider plugin and holds its installation status.
	Provider *FulfillmentProvider `json:"provider,omitempty"`

	// The id of the Fulfillment Provider, that will be used to process Fulfillments from the Shipping Option.
	ProviderId string `json:"provider_id"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The region's ID
	RegionId string `json:"region_id"`

	// The requirements that must be satisfied for the Shipping Option to be available for a Cart. Available if the relation `requirements` is expanded.
	Requirements *[]ShippingOptionRequirement `json:"requirements,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
type ShippingOptionPriceType string

// A requirement that a Cart must satisfy for the Shipping Option to be available to the Cart.
type ShippingOptionRequirement struct {
	// The amount to compare the Cart subtotal to.
	Amount int `json:"amount"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The shipping option requirement's ID
	Id *string `json:"id,omitempty"`

	// Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

	// The id of the Shipping Option that the hipping option requirement belongs to
	ShippingOptionId string `json:"shipping_option_id"`

	// The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
	Type ShippingOptionRequirementType `json:"type"`
}

// The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
type ShippingOptionRequirementType string

// Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
type ShippingProfile struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The shipping profile's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name given to the Shipping profile - this may be displayed to the Customer.
	Name string `json:"name"`

	// The Products that the Shipping Profile defines Shipping Options for. Available if the relation `products` is expanded.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// The Shipping Options that can be used to fulfill the Products in the Shipping Profile. Available if the relation `shipping_options` is expanded.
	ShippingOptions *[]ShippingOption `json:"shipping_options,omitempty"`

	// The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
	Type ShippingProfileType `json:"type"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
type ShippingProfileType string

// Holds settings for the Store, such as name, currencies, etc.
type Store struct {
	// The currencies that are enabled for the Store. Available if the relation `currencies` is expanded.
	Currencies *[]Currency `json:"currencies,omitempty"`

	// Currency
	DefaultCurrency *Currency `json:"default_currency,omitempty"`

	// The 3 character currency code that is the default of the store.
	DefaultCurrencyCode *string `json:"default_currency_code,omitempty"`

	// A sales channel object. Available if the relation `default_sales_channel` is expanded.
	DefaultSalesChannel *map[string]interface{} `json:"default_sales_channel,omitempty"`

	// The sales channel ID the cart is associated with.
	DefaultSalesChannelId *string `json:"default_sales_channel_id,omitempty"`

	// The store's ID
	Id *string `json:"id,omitempty"`

	// A template to generate Invite links from
	InviteLinkTemplate *string `json:"invite_link_template,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the Store - this may be displayed to the Customer.
	Name *string `json:"name,omitempty"`

	// A template to generate Payment links from. Use {{cart_id}} to include the payment's `cart_id` in the link.
	PaymentLinkTemplate *string `json:"payment_link_template,omitempty"`

	// A template to generate Swap links from. Use {{cart_id}} to include the Swap's `cart_id` in the link.
	SwapLinkTemplate *string `json:"swap_link_template,omitempty"`
}

// Swaps can be created when a Customer wishes to exchange Products that they have purchased to different Products. Swaps consist of a Return of previously purchased Products and a Fulfillment of new Products, the amount paid for the Products being returned will be used towards payment for the new Products. In the case where the amount paid for the the Products being returned exceed the amount to be paid for the new Products, a Refund will be issued for the difference.
type Swap struct {
	// The new Line Items to ship to the Customer. Available if the relation `additional_items` is expanded.
	AdditionalItems *[]LineItem `json:"additional_items,omitempty"`

	// If true, swaps can be completed with items out of stock
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// The date with timezone at which the Swap was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// A cart object. Available if the relation `cart` is expanded.
	Cart *map[string]interface{} `json:"cart,omitempty"`

	// The id of the Cart that the Customer will use to confirm the Swap.
	CartId *string `json:"cart_id,omitempty"`

	// The date with timezone at which the Swap was confirmed by the Customer.
	ConfirmedAt *time.Time `json:"confirmed_at,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The difference that is paid or refunded as a result of the Swap. May be negative when the amount paid for the returned items exceed the total of the new Products.
	DifferenceDue *int `json:"difference_due,omitempty"`

	// The status of the Fulfillment of the Swap.
	FulfillmentStatus SwapFulfillmentStatus `json:"fulfillment_status"`

	// The Fulfillments used to send the new Line Items. Available if the relation `fulfillments` is expanded.
	Fulfillments *[]Fulfillment `json:"fulfillments,omitempty"`

	// The swap's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of the swap in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true, no notification will be sent related to this swap
	NoNotification *bool `json:"no_notification,omitempty"`

	// An order object. Available if the relation `order` is expanded.
	Order *map[string]interface{} `json:"order,omitempty"`

	// The ID of the Order where the Line Items to be returned where purchased.
	OrderId string `json:"order_id"`

	// Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
	Payment *Payment `json:"payment,omitempty"`

	// The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
	PaymentStatus SwapPaymentStatus `json:"payment_status"`

	// A return order object. The Return that is issued for the return part of the Swap. Available if the relation `return_order` is expanded.
	ReturnOrder *map[string]interface{} `json:"return_order,omitempty"`

	// An address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The Address to send the new Line Items to - in most cases this will be the same as the shipping address on the Order.
	ShippingAddressId *string `json:"shipping_address_id,omitempty"`

	// The Shipping Methods used to fulfill the additional items purchased. Available if the relation `shipping_methods` is expanded.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The status of the Fulfillment of the Swap.
type SwapFulfillmentStatus string

// The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
type SwapPaymentStatus string

// The tax service used to calculate taxes
type TaxProvider struct {
	// The id of the tax provider as given by the plugin.
	Id *string `json:"id,omitempty"`

	// Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
	IsInstalled *bool `json:"is_installed,omitempty"`
}

// A Tax Rate can be used to associate a certain rate to charge on products within a given Region
type TaxRate struct {
	// A code to identify the tax type by
	Code *string `json:"code,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The tax rate's ID
	Id *string `json:"id,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A human friendly name for the tax
	Name string `json:"name"`

	// The count of products
	ProductCount *int `json:"product_count,omitempty"`

	// The count of product types
	ProductTypeCount *int `json:"product_type_count,omitempty"`

	// The product types that belong to this tax rate. Available if the relation `product_types` is expanded.
	ProductTypes *[]map[string]interface{} `json:"product_types,omitempty"`

	// The products that belong to this tax rate. Available if the relation `products` is expanded.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// The numeric rate to charge
	Rate *float32 `json:"rate,omitempty"`

	// A region object. Available if the relation `region` is expanded.
	Region *map[string]interface{} `json:"region,omitempty"`

	// The id of the Region that the rate belongs to
	RegionId string `json:"region_id"`

	// The count of shipping options
	ShippingOptionCount *int `json:"shipping_option_count,omitempty"`

	// The shipping options that belong to this tax rate. Available if the relation `shipping_options` is expanded.
	ShippingOptions *[]map[string]interface{} `json:"shipping_options,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Tracking Link holds information about tracking numbers for a Fulfillment. Tracking Links can optionally contain a URL that can be visited to see the status of the shipment.
type TrackingLink struct {
	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Fulfillments are created once store operators can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a provider, which is typically an external shipping aggregator, shipping partner og 3PL, most plugins will have asynchronous communications with these providers through webhooks in order to automatically update and synchronize the state of Fulfillments.
	Fulfillment *Fulfillment `json:"fulfillment,omitempty"`

	// The id of the Fulfillment that the Tracking Link references.
	FulfillmentId string `json:"fulfillment_id"`

	// The tracking link's ID
	Id *string `json:"id,omitempty"`

	// Randomly generated key used to continue the completion of a process in case of failure.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The tracking number given by the shipping carrier.
	TrackingNumber string `json:"tracking_number"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The URL at which the status of the shipment can be tracked.
	Url *string `json:"url,omitempty"`
}

// Represents a User who can manage store settings.
type User struct {
	// An API token associated with the user.
	ApiToken *string `json:"api_token,omitempty"`

	// The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// The email of the User
	Email openapi_types.Email `json:"email"`

	// The first name of the User
	FirstName *string `json:"first_name,omitempty"`

	// The user's ID
	Id *string `json:"id,omitempty"`

	// The last name of the User
	LastName *string `json:"last_name,omitempty"`

	// An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// N400Error defines model for 400_error.
type N400Error interface{}

// N500Error defines model for 500_error.
type N500Error = Error

// InvalidRequestError defines model for invalid_request_error.
type InvalidRequestError = Error

// InvalidStateError defines model for invalid_state_error.
type InvalidStateError = Error

// NotFoundError defines model for not_found_error.
type NotFoundError = Error

// PostDraftOrdersDraftOrderJSONBody defines parameters for PostDraftOrdersDraftOrder.
type PostDraftOrdersDraftOrderJSONBody struct {
	// An address.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The 2 character ISO code for the Country.
	CountryCode *string `json:"country_code,omitempty"`

	// The ID of the Customer to associate the Draft Order with.
	CustomerId *string `json:"customer_id,omitempty"`

	// An array of Discount codes to add to the Draft Order.
	Discounts *[]struct {
		// The code that a Discount is identifed by.
		Code string `json:"code"`
	} `json:"discounts,omitempty"`

	// An email to be used on the Draft Order.
	Email *openapi_types.Email `json:"email,omitempty"`

	// An optional flag passed to the resulting order to determine use of notifications.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// The ID of the Region to create the Draft Order in.
	RegionId *string `json:"region_id,omitempty"`

	// An address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`
}

// PostAppsJSONBody defines parameters for PostApps.
type PostAppsJSONBody struct {
	// Name of the application for the token to be generated for.
	ApplicationName string `json:"application_name"`

	// The code for the generated token.
	Code string `json:"code"`

	// State of the application.
	State string `json:"state"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	// The User's email.
	Email string `json:"email"`

	// The User's password.
	Password string `json:"password"`
}

// GetBatchJobsParams defines parameters for GetBatchJobs.
type GetBatchJobsParams struct {
	// The number of batch jobs to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of batch jobs to skip before results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter by the batch ID
	Id *interface{} `form:"id,omitempty" json:"id,omitempty"`

	// Filter by the batch type
	Type *[]string `form:"type,omitempty" json:"type,omitempty"`

	// Date comparison for when resulting collections was confirmed, i.e. less than, greater than etc.
	ConfirmedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"confirmed_at,omitempty" json:"confirmed_at,omitempty"`

	// Date comparison for when resulting collections was pre processed, i.e. less than, greater than etc.
	PreProcessedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"pre_processed_at,omitempty" json:"pre_processed_at,omitempty"`

	// Date comparison for when resulting collections was completed, i.e. less than, greater than etc.
	CompletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"completed_at,omitempty" json:"completed_at,omitempty"`

	// Date comparison for when resulting collections was failed, i.e. less than, greater than etc.
	FailedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"failed_at,omitempty" json:"failed_at,omitempty"`

	// Date comparison for when resulting collections was canceled, i.e. less than, greater than etc.
	CanceledAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"canceled_at,omitempty" json:"canceled_at,omitempty"`

	// Field used to order retrieved batch jobs
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// (Comma separated) Which fields should be expanded in each order of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each order of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Date comparison for when resulting collections was created, i.e. less than, greater than etc.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting collections was updated, i.e. less than, greater than etc.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// PostBatchJobsJSONBody defines parameters for PostBatchJobs.
type PostBatchJobsJSONBody struct {
	// Additional infomration regarding the batch to be used for processing.
	Context map[string]interface{} `json:"context"`

	// Set a batch job in dry_run mode to get some information on what will be done without applying any modifications.
	DryRun *bool `json:"dry_run,omitempty"`

	// The type of batch job to start.
	Type string `json:"type"`
}

// GetCollectionsParams defines parameters for GetCollections.
type GetCollectionsParams struct {
	// The number of collections to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of collections to skip before the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// The title of collections to return.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// The handle of collections to return.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// a search term to search titles and handles.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Date comparison for when resulting collections were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting collections were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting collections were deleted.
	DeletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// PostCollectionsJSONBody defines parameters for PostCollections.
type PostCollectionsJSONBody struct {
	// An optional handle to be used in slugs, if none is provided we will kebab-case the title.
	Handle *string `json:"handle,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The title to identify the Collection by.
	Title string `json:"title"`
}

// PostCollectionsCollectionJSONBody defines parameters for PostCollectionsCollection.
type PostCollectionsCollectionJSONBody struct {
	// An optional handle to be used in slugs, if none is provided we will kebab-case the title.
	Handle *string `json:"handle,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The title to identify the Collection by.
	Title *string `json:"title,omitempty"`
}

// DeleteProductsFromCollectionJSONBody defines parameters for DeleteProductsFromCollection.
type DeleteProductsFromCollectionJSONBody struct {
	// An array of Product IDs to remove from the Product Collection.
	ProductIds []string `json:"product_ids"`
}

// PostProductsToCollectionJSONBody defines parameters for PostProductsToCollection.
type PostProductsToCollectionJSONBody struct {
	// An array of Product IDs to add to the Product Collection.
	ProductIds []string `json:"product_ids"`
}

// GetCurrenciesParams defines parameters for GetCurrencies.
type GetCurrenciesParams struct {
	// Code of the currency to search for.
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// Search for tax inclusive currencies.
	IncludesTax *bool `form:"includes_tax,omitempty" json:"includes_tax,omitempty"`

	// to retrieve products in.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// How many products to skip in the result.
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of products returned.
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostCurrenciesCurrencyJSONBody defines parameters for PostCurrenciesCurrency.
type PostCurrenciesCurrencyJSONBody struct {
	// [EXPERIMENTAL] Tax included in prices of currency.
	IncludesTax *bool `json:"includes_tax,omitempty"`
}

// GetCustomerGroupsParams defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams struct {
	// Query used for searching customer group names.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// How many groups to skip in the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// the field used to order the customer groups.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Filter by the customer group ID
	Id *interface{} `form:"id,omitempty" json:"id,omitempty"`

	// Filter by the customer group name
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// Date comparison for when resulting customer groups were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting customer groups were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Limit the number of customer groups returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// (Comma separated) Which fields should be expanded in each customer groups of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostCustomerGroupsJSONBody defines parameters for PostCustomerGroups.
type PostCustomerGroupsJSONBody struct {
	// Metadata for the customer.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name of the customer group
	Name string `json:"name"`
}

// GetCustomerGroupsGroupParams defines parameters for GetCustomerGroupsGroup.
type GetCustomerGroupsGroupParams struct {
	// (Comma separated) Which fields should be expanded in the customer group.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in the customer group.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomerGroupsGroupJSONBody defines parameters for PostCustomerGroupsGroup.
type PostCustomerGroupsGroupJSONBody struct {
	// Metadata for the customer.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name of the customer group
	Name *string `json:"name,omitempty"`
}

// DeleteCustomerGroupsGroupCustomerBatchJSONBody defines parameters for DeleteCustomerGroupsGroupCustomerBatch.
type DeleteCustomerGroupsGroupCustomerBatchJSONBody struct {
	// The ids of the customers to remove
	CustomerIds []struct {
		// ID of the customer
		Id string `json:"id"`
	} `json:"customer_ids"`
}

// PostCustomerGroupsGroupCustomersBatchJSONBody defines parameters for PostCustomerGroupsGroupCustomersBatch.
type PostCustomerGroupsGroupCustomersBatchJSONBody struct {
	// The ids of the customers to add
	CustomerIds []struct {
		// ID of the customer
		Id string `json:"id"`
	} `json:"customer_ids"`
}

// GetCustomersParams defines parameters for GetCustomers.
type GetCustomersParams struct {
	// The number of items to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// The items to skip before result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// (Comma separated) Which fields should be expanded in each customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// a search term to search email, first_name, and last_name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// PostCustomersJSONBody defines parameters for PostCustomers.
type PostCustomersJSONBody struct {
	// The customer's email.
	Email openapi_types.Email `json:"email"`

	// The customer's first name.
	FirstName string `json:"first_name"`

	// The customer's last name.
	LastName string `json:"last_name"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The customer's password.
	Password string `json:"password"`

	// The customer's phone number.
	Phone *string `json:"phone,omitempty"`
}

// GetCustomersCustomerParams defines parameters for GetCustomersCustomer.
type GetCustomersCustomerParams struct {
	// (Comma separated) Which fields should be expanded in the customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in the customer.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomersCustomerJSONBody defines parameters for PostCustomersCustomer.
type PostCustomersCustomerJSONBody struct {
	// The Customer's email.
	Email *openapi_types.Email `json:"email,omitempty"`

	// The Customer's first name.
	FirstName *string `json:"first_name,omitempty"`

	// A list of customer groups to which the customer belongs.
	Groups *[]struct {
		// The ID of a customer group
		Id string `json:"id"`
	} `json:"groups,omitempty"`

	// The Customer's last name.
	LastName *string `json:"last_name,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Customer's password.
	Password *string `json:"password,omitempty"`

	// The Customer's phone number.
	Phone *string `json:"phone,omitempty"`
}

// PostCustomersCustomerParams defines parameters for PostCustomersCustomer.
type PostCustomersCustomerParams struct {
	// (Comma separated) Which fields should be expanded in each customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be retrieved in each customer.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsParams defines parameters for GetDiscounts.
type GetDiscountsParams struct {
	// Search query applied on the code field.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Discount Rules filters to apply on the search
	Rule *struct {
		// The value that the discount represents; this will depend on the type of the discount
		Allocation *GetDiscountsParamsRuleAllocation `json:"allocation,omitempty"`

		// The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
		Type *GetDiscountsParamsRuleType `json:"type,omitempty"`
	} `form:"rule,omitempty" json:"rule,omitempty"`

	// Return only dynamic discounts.
	IsDynamic *bool `form:"is_dynamic,omitempty" json:"is_dynamic,omitempty"`

	// Return only disabled discounts.
	IsDisabled *bool `form:"is_disabled,omitempty" json:"is_disabled,omitempty"`

	// The number of items in the response
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// The offset of items in response
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Comma separated list of relations to include in the results.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetDiscountsParamsRuleAllocation defines parameters for GetDiscounts.
type GetDiscountsParamsRuleAllocation string

// GetDiscountsParamsRuleType defines parameters for GetDiscounts.
type GetDiscountsParamsRuleType string

// PostDiscountsJSONBody defines parameters for PostDiscounts.
type PostDiscountsJSONBody struct {
	// A unique code that will be used to redeem the Discount
	Code string `json:"code"`

	// The time at which the Discount should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Whether the Discount code is disabled on creation. You will have to enable it later to make it available to Customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Whether the Discount should have multiple instances of itself, each with a different code. This can be useful for automatically generated codes that all have to follow a common set of rules.
	IsDynamic *bool `json:"is_dynamic,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A list of Region ids representing the Regions in which the Discount can be used.
	Regions *[]string `json:"regions,omitempty"`

	// The Discount Rule that defines how Discounts are calculated
	Rule struct {
		// The scope that the discount should apply to.
		Allocation PostDiscountsJSONBodyRuleAllocation `json:"allocation"`

		// A set of conditions that can be used to limit when  the discount can be used. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` should be provided.
		Conditions *[]struct {
			// list of customer group IDs if the condition is applied on customer groups.
			CustomerGroups *[]string `json:"customer_groups,omitempty"`

			// Operator of the condition
			Operator PostDiscountsJSONBodyRuleConditionsOperator `json:"operator"`

			// list of product collection IDs if the condition is applied on product collections.
			ProductCollections *[]string `json:"product_collections,omitempty"`

			// list of product tag IDs if the condition is applied on product tags.
			ProductTags *[]string `json:"product_tags,omitempty"`

			// list of product type IDs if the condition is applied on product types.
			ProductTypes *[]string `json:"product_types,omitempty"`

			// list of product IDs if the condition is applied on products.
			Products *[]string `json:"products,omitempty"`
		} `json:"conditions,omitempty"`

		// A short description of the discount
		Description *string `json:"description,omitempty"`

		// The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
		Type PostDiscountsJSONBodyRuleType `json:"type"`

		// The value that the discount represents; this will depend on the type of the discount
		Value float32 `json:"value"`
	} `json:"rule"`

	// The time at which the Discount should be available.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// Maximum times the discount can be used
	UsageLimit *float32 `json:"usage_limit,omitempty"`

	// Duration the discount runs between
	ValidDuration *string `json:"valid_duration,omitempty"`
}

// PostDiscountsParams defines parameters for PostDiscounts.
type PostDiscountsParams struct {
	// (Comma separated) Which fields should be expanded in each customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be retrieved in each customer.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsJSONBodyRuleAllocation defines parameters for PostDiscounts.
type PostDiscountsJSONBodyRuleAllocation string

// PostDiscountsJSONBodyRuleConditionsOperator defines parameters for PostDiscounts.
type PostDiscountsJSONBodyRuleConditionsOperator string

// PostDiscountsJSONBodyRuleType defines parameters for PostDiscounts.
type PostDiscountsJSONBodyRuleType string

// GetDiscountsDiscountCodeParams defines parameters for GetDiscountsDiscountCode.
type GetDiscountsDiscountCodeParams struct {
	// Comma separated list of relations to include in the results.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Comma separated list of fields to include in the results.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsJSONBody defines parameters for PostDiscountsDiscountConditions.
type PostDiscountsDiscountConditionsJSONBody struct {
	// list of customer group IDs if the condition is applied on customer groups.
	CustomerGroups *[]string `json:"customer_groups,omitempty"`

	// Operator of the condition
	Operator PostDiscountsDiscountConditionsJSONBodyOperator `json:"operator"`

	// list of product collection IDs if the condition is applied on product collections.
	ProductCollections *[]string `json:"product_collections,omitempty"`

	// list of product tag IDs if the condition is applied on product tags.
	ProductTags *[]string `json:"product_tags,omitempty"`

	// list of product type IDs if the condition is applied on product types.
	ProductTypes *[]string `json:"product_types,omitempty"`

	// list of product IDs if the condition is applied on products.
	Products *[]string `json:"products,omitempty"`
}

// PostDiscountsDiscountConditionsParams defines parameters for PostDiscountsDiscountConditions.
type PostDiscountsDiscountConditionsParams struct {
	// (Comma separated) Which fields should be expanded in each product of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each product of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsJSONBodyOperator defines parameters for PostDiscountsDiscountConditions.
type PostDiscountsDiscountConditionsJSONBodyOperator string

// DeleteDiscountsDiscountConditionsConditionParams defines parameters for DeleteDiscountsDiscountConditionsCondition.
type DeleteDiscountsDiscountConditionsConditionParams struct {
	// Comma separated list of relations to include in the results.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Comma separated list of fields to include in the results.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsDiscountConditionsConditionParams defines parameters for GetDiscountsDiscountConditionsCondition.
type GetDiscountsDiscountConditionsConditionParams struct {
	// Comma separated list of relations to include in the results.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Comma separated list of fields to include in the results.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsConditionJSONBody defines parameters for PostDiscountsDiscountConditionsCondition.
type PostDiscountsDiscountConditionsConditionJSONBody struct {
	// list of customer group IDs if the condition is applied on customer groups.
	CustomerGroups *[]string `json:"customer_groups,omitempty"`

	// list of product collection IDs if the condition is applied on product collections.
	ProductCollections *[]string `json:"product_collections,omitempty"`

	// list of product tag IDs if the condition is applied on product tags.
	ProductTags *[]string `json:"product_tags,omitempty"`

	// list of product type IDs if the condition is applied on product types.
	ProductTypes *[]string `json:"product_types,omitempty"`

	// list of product IDs if the condition is applied on products.
	Products *[]string `json:"products,omitempty"`
}

// PostDiscountsDiscountConditionsConditionParams defines parameters for PostDiscountsDiscountConditionsCondition.
type PostDiscountsDiscountConditionsConditionParams struct {
	// (Comma separated) Which fields should be expanded in each item of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each item of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsDiscountParams defines parameters for GetDiscountsDiscount.
type GetDiscountsDiscountParams struct {
	// Comma separated list of relations to include in the results.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Comma separated list of fields to include in the results.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountJSONBody defines parameters for PostDiscountsDiscount.
type PostDiscountsDiscountJSONBody struct {
	// A unique code that will be used to redeem the Discount
	Code *string `json:"code,omitempty"`

	// The time at which the Discount should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Whether the Discount code is disabled on creation. You will have to enable it later to make it available to Customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// An object containing metadata of the discount
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// A list of Region ids representing the Regions in which the Discount can be used.
	Regions *[]string `json:"regions,omitempty"`

	// The Discount Rule that defines how Discounts are calculated
	Rule *struct {
		// The scope that the discount should apply to.
		Allocation *PostDiscountsDiscountJSONBodyRuleAllocation `json:"allocation,omitempty"`

		// A set of conditions that can be used to limit when the discount can be used. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` should be provided.
		Conditions *[]struct {
			// list of customer group IDs if the condition is applied on customer groups.
			CustomerGroups *[]string `json:"customer_groups,omitempty"`

			// The ID of the Rule
			Id *string `json:"id,omitempty"`

			// Operator of the condition
			Operator PostDiscountsDiscountJSONBodyRuleConditionsOperator `json:"operator"`

			// list of product collection IDs if the condition is applied on product collections.
			ProductCollections *[]string `json:"product_collections,omitempty"`

			// list of product tag IDs if the condition is applied on product tags.
			ProductTags *[]string `json:"product_tags,omitempty"`

			// list of product type IDs if the condition is applied on product types.
			ProductTypes *[]string `json:"product_types,omitempty"`

			// list of product IDs if the condition is applied on products.
			Products *[]string `json:"products,omitempty"`
		} `json:"conditions,omitempty"`

		// A short description of the discount
		Description *string `json:"description,omitempty"`

		// The ID of the Rule
		Id string `json:"id"`

		// The value that the discount represents; this will depend on the type of the discount
		Value *float32 `json:"value,omitempty"`
	} `json:"rule,omitempty"`

	// The time at which the Discount should be available.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// Maximum times the discount can be used
	UsageLimit *float32 `json:"usage_limit,omitempty"`

	// Duration the discount runs between
	ValidDuration *string `json:"valid_duration,omitempty"`
}

// PostDiscountsDiscountParams defines parameters for PostDiscountsDiscount.
type PostDiscountsDiscountParams struct {
	// (Comma separated) Which fields should be expanded in each item of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each item of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountJSONBodyRuleAllocation defines parameters for PostDiscountsDiscount.
type PostDiscountsDiscountJSONBodyRuleAllocation string

// PostDiscountsDiscountJSONBodyRuleConditionsOperator defines parameters for PostDiscountsDiscount.
type PostDiscountsDiscountJSONBodyRuleConditionsOperator string

// PostDiscountsDiscountDynamicCodesJSONBody defines parameters for PostDiscountsDiscountDynamicCodes.
type PostDiscountsDiscountDynamicCodesJSONBody struct {
	// The unique code that will be used to redeem the Discount.
	Code string `json:"code"`

	// An optional set of key-value paris to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// amount of times the discount can be applied.
	UsageLimit *float32 `json:"usage_limit,omitempty"`
}

// GetDraftOrdersParams defines parameters for GetDraftOrders.
type GetDraftOrdersParams struct {
	// The number of items to skip before the results.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of items returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// a search term to search emails in carts associated with draft orders and display IDs of draft orders
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// PostDraftOrdersJSONBody defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBody struct {
	// An address.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The ID of the customer to add on the draft order
	CustomerId *string `json:"customer_id,omitempty"`

	// The discounts to add on the draft order
	Discounts *[]struct {
		// The code of the discount to apply
		Code string `json:"code"`
	} `json:"discounts,omitempty"`

	// The email of the customer of the draft order
	Email openapi_types.Email `json:"email"`

	// The Line Items that have been received.
	Items []struct {
		// The optional key-value map with additional details about the Line Item.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// The quantity of the Line Item.
		Quantity int `json:"quantity"`

		// The potential custom title of the item.
		Title *string `json:"title,omitempty"`

		// The potential custom price of the item.
		UnitPrice *int `json:"unit_price,omitempty"`

		// The ID of the Product Variant to generate the Line Item from.
		VariantId *string `json:"variant_id,omitempty"`
	} `json:"items"`

	// The optional key-value map with additional details about the Draft Order.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// An optional flag passed to the resulting order to determine use of notifications.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// The ID of the region for the draft order
	RegionId string `json:"region_id"`

	// An address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The shipping methods for the draft order
	ShippingMethods []struct {
		// The optional additional data needed for the shipping method
		Data *map[string]interface{} `json:"data,omitempty"`

		// The ID of the shipping option in use
		OptionId string `json:"option_id"`

		// The potential custom price of the shipping
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods"`

	// The status of the draft order
	Status *PostDraftOrdersJSONBodyStatus `json:"status,omitempty"`
}

// PostDraftOrdersJSONBodyStatus defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyStatus string

// PostDraftOrdersDraftOrderLineItemsJSONBody defines parameters for PostDraftOrdersDraftOrderLineItems.
type PostDraftOrdersDraftOrderLineItemsJSONBody struct {
	// The optional key-value map with additional details about the Line Item.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The quantity of the Line Item.
	Quantity int `json:"quantity"`

	// The potential custom title of the item.
	Title *string `json:"title,omitempty"`

	// The potential custom price of the item.
	UnitPrice *int `json:"unit_price,omitempty"`

	// The ID of the Product Variant to generate the Line Item from.
	VariantId *string `json:"variant_id,omitempty"`
}

// PostDraftOrdersDraftOrderLineItemsItemJSONBody defines parameters for PostDraftOrdersDraftOrderLineItemsItem.
type PostDraftOrdersDraftOrderLineItemsItemJSONBody struct {
	// The optional key-value map with additional details about the Line Item.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The quantity of the Line Item.
	Quantity *int `json:"quantity,omitempty"`

	// The potential custom title of the item.
	Title *string `json:"title,omitempty"`

	// The potential custom price of the item.
	UnitPrice *int `json:"unit_price,omitempty"`
}

// GetGiftCardsParams defines parameters for GetGiftCards.
type GetGiftCardsParams struct {
	// The number of items to skip before the results.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of items returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// a search term to search by code or display ID
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// PostGiftCardsJSONBody defines parameters for PostGiftCards.
type PostGiftCardsJSONBody struct {
	// The time at which the Gift Card should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Whether the Gift Card is disabled on creation. You will have to enable it later to make it available to Customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The ID of the Region in which the Gift Card can be used.
	RegionId string `json:"region_id"`

	// The value (excluding VAT) that the Gift Card should represent.
	Value *int `json:"value,omitempty"`
}

// PostGiftCardsGiftCardJSONBody defines parameters for PostGiftCardsGiftCard.
type PostGiftCardsGiftCardJSONBody struct {
	// The value (excluding VAT) that the Gift Card should represent.
	Balance *int `json:"balance,omitempty"`

	// The time at which the Gift Card should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Whether the Gift Card is disabled on creation. You will have to enable it later to make it available to Customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The ID of the Region in which the Gift Card can be used.
	RegionId *string `json:"region_id,omitempty"`
}

// PostInvitesJSONBody defines parameters for PostInvites.
type PostInvitesJSONBody struct {
	// The role of the user to be created.
	Role PostInvitesJSONBodyRole `json:"role"`

	// The email for the user to be created.
	User openapi_types.Email `json:"user"`
}

// PostInvitesJSONBodyRole defines parameters for PostInvites.
type PostInvitesJSONBodyRole string

// PostInvitesInviteAcceptJSONBody defines parameters for PostInvitesInviteAccept.
type PostInvitesInviteAcceptJSONBody struct {
	// The invite token provided by the admin.
	Token string `json:"token"`

	// The User to create.
	User struct {
		// the first name of the User
		FirstName string `json:"first_name"`

		// the last name of the User
		LastName string `json:"last_name"`

		// The desired password for the User
		Password string `json:"password"`
	} `json:"user"`
}

// GetNotesParams defines parameters for GetNotes.
type GetNotesParams struct {
	// The number of notes to get
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// The offset at which to get notes
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// The ID which the notes belongs to
	ResourceId *string `form:"resource_id,omitempty" json:"resource_id,omitempty"`
}

// PostNotesJSONBody defines parameters for PostNotes.
type PostNotesJSONBody struct {
	// The ID of the resource which the Note relates to.
	ResourceId string `json:"resource_id"`

	// The type of resource which the Note relates to.
	ResourceType string `json:"resource_type"`

	// The content of the Note to create.
	Value string `json:"value"`
}

// PostNotesNoteJSONBody defines parameters for PostNotesNote.
type PostNotesNoteJSONBody struct {
	// The updated description of the Note.
	Value string `json:"value"`
}

// GetNotificationsParams defines parameters for GetNotifications.
type GetNotificationsParams struct {
	// The number of notifications to skip before starting to collect the notifications set
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// The number of notifications to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Comma separated fields to include in the result set
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Comma separated fields to populate
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// The name of the event that the notification was sent for.
	EventName *string `form:"event_name,omitempty" json:"event_name,omitempty"`

	// The type of resource that the Notification refers to.
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// The ID of the resource that the Notification refers to.
	ResourceId *string `form:"resource_id,omitempty" json:"resource_id,omitempty"`

	// The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// A boolean indicating whether the result set should include resent notifications or not
	IncludeResends *string `form:"include_resends,omitempty" json:"include_resends,omitempty"`
}

// PostNotificationsNotificationResendJSONBody defines parameters for PostNotificationsNotificationResend.
type PostNotificationsNotificationResendJSONBody struct {
	// A new address or user identifier that the Notification should be sent to
	To *string `json:"to,omitempty"`
}

// PostOrdersOrderClaimsJSONBody defines parameters for PostOrdersOrderClaims.
type PostOrdersOrderClaimsJSONBody struct {
	// The new items to send to the Customer when the Claim type is Replace.
	AdditionalItems *[]struct {
		// The quantity of the Product Variant to ship.
		Quantity int `json:"quantity"`

		// The ID of the Product Variant to ship.
		VariantId string `json:"variant_id"`
	} `json:"additional_items,omitempty"`

	// The Claim Items that the Claim will consist of.
	ClaimItems []struct {
		// A list of image URL's that will be associated with the Claim
		Images *interface{} `json:"images,omitempty"`

		// The ID of the Line Item that will be claimed.
		ItemId string `json:"item_id"`

		// Short text describing the Claim Item in further detail.
		Note *string `json:"note,omitempty"`

		// The number of items that will be returned
		Quantity int `json:"quantity"`

		// The reason for the Claim
		Reason *PostOrdersOrderClaimsJSONBodyClaimItemsReason `json:"reason,omitempty"`

		// A list o tags to add to the Claim Item
		Tags *[]string `json:"tags,omitempty"`
	} `json:"claim_items"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true no notification will be send related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The amount to refund the Customer when the Claim type is `refund`.
	RefundAmount *int `json:"refund_amount,omitempty"`

	// Optional details for the Return Shipping Method, if the items are to be sent back.
	ReturnShipping *struct {
		// The ID of the Shipping Option to create the Shipping Method from.
		OptionId *string `json:"option_id,omitempty"`

		// The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`

	// An address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The Shipping Methods to send the additional Line Items with.
	ShippingMethods *[]struct {
		// The ID of an existing Shipping Method
		Id *string `json:"id,omitempty"`

		// The ID of the Shipping Option to create a Shipping Method from
		OptionId *string `json:"option_id,omitempty"`

		// The price to charge for the Shipping Method
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods,omitempty"`

	// The type of the Claim. This will determine how the Claim is treated: `replace` Claims will result in a Fulfillment with new items being created, while a `refund` Claim will refund the amount paid for the claimed items.
	Type PostOrdersOrderClaimsJSONBodyType `json:"type"`
}

// PostOrdersOrderClaimsJSONBodyClaimItemsReason defines parameters for PostOrdersOrderClaims.
type PostOrdersOrderClaimsJSONBodyClaimItemsReason string

// PostOrdersOrderClaimsJSONBodyType defines parameters for PostOrdersOrderClaims.
type PostOrdersOrderClaimsJSONBodyType string

// PostOrdersOrderClaimsClaimJSONBody defines parameters for PostOrdersOrderClaimsClaim.
type PostOrdersOrderClaimsClaimJSONBody struct {
	// The Claim Items that the Claim will consist of.
	ClaimItems *[]struct {
		// The ID of the Claim Item.
		Id string `json:"id"`

		// A list of image URL's that will be associated with the Claim
		Images []struct {
			// Image ID
			Id *string `json:"id,omitempty"`

			// Image URL
			Url *string `json:"url,omitempty"`
		} `json:"images"`

		// The ID of the Line Item that will be claimed.
		ItemId *string `json:"item_id,omitempty"`

		// An optional set of key-value pairs to hold additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Short text describing the Claim Item in further detail.
		Note *string `json:"note,omitempty"`

		// The number of items that will be returned
		Quantity *int `json:"quantity,omitempty"`

		// The reason for the Claim
		Reason *PostOrdersOrderClaimsClaimJSONBodyClaimItemsReason `json:"reason,omitempty"`

		// A list o tags to add to the Claim Item
		Tags []struct {
			// Tag ID
			Id *string `json:"id,omitempty"`

			// Tag value
			Value *string `json:"value,omitempty"`
		} `json:"tags"`
	} `json:"claim_items,omitempty"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true no notification will be send related to this Swap.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The Shipping Methods to send the additional Line Items with.
	ShippingMethods *[]struct {
		// The ID of an existing Shipping Method
		Id *string `json:"id,omitempty"`

		// The ID of the Shipping Option to create a Shipping Method from
		OptionId *string `json:"option_id,omitempty"`

		// The price to charge for the Shipping Method
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods,omitempty"`
}

// PostOrdersOrderClaimsClaimJSONBodyClaimItemsReason defines parameters for PostOrdersOrderClaimsClaim.
type PostOrdersOrderClaimsClaimJSONBodyClaimItemsReason string

// PostOrdersOrderSwapsJSONBody defines parameters for PostOrdersOrderSwaps.
type PostOrdersOrderSwapsJSONBody struct {
	// The new items to send to the Customer.
	AdditionalItems *[]struct {
		// The quantity of the Product Variant to ship.
		Quantity int `json:"quantity"`

		// The ID of the Product Variant to ship.
		VariantId string `json:"variant_id"`
	} `json:"additional_items,omitempty"`

	// If true, swaps can be completed with items out of stock
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// The custom shipping options to potentially create a Shipping Method from.
	CustomShippingOptions *[]struct {
		// The ID of the Shipping Option to override with a custom price.
		OptionId string `json:"option_id"`

		// The custom price of the Shipping Option.
		Price int `json:"price"`
	} `json:"custom_shipping_options,omitempty"`

	// If set to true no notification will be send related to this Swap.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The Line Items to return as part of the Swap.
	ReturnItems []struct {
		// The ID of the Line Item that will be claimed.
		ItemId string `json:"item_id"`

		// An optional note with information about the Return.
		Note *string `json:"note,omitempty"`

		// The number of items that will be returned
		Quantity int `json:"quantity"`

		// The ID of the Return Reason to use.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"return_items"`

	// How the Swap will be returned.
	ReturnShipping *struct {
		// The ID of the Shipping Option to create the Shipping Method from.
		OptionId string `json:"option_id"`

		// The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`
}

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Query used for searching orders by shipping address first name, orders' email, and orders' display ID
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// ID of the order to search for.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Status to search for
	Status *[]GetOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Fulfillment status to search for.
	FulfillmentStatus *[]GetOrdersParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// Payment status to search for.
	PaymentStatus *[]GetOrdersParamsPaymentStatus `form:"payment_status,omitempty" json:"payment_status,omitempty"`

	// Display ID to search for.
	DisplayId *string `form:"display_id,omitempty" json:"display_id,omitempty"`

	// to search for.
	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

	// to search for.
	CustomerId *string `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// to search for.
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// Regions to search orders by
	RegionId *interface{} `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Currency code to search for
	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`

	// to search for.
	TaxRate *string `form:"tax_rate,omitempty" json:"tax_rate,omitempty"`

	// Date comparison for when resulting orders were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting orders were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting orders were canceled.
	CanceledAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"canceled_at,omitempty" json:"canceled_at,omitempty"`

	// Filter by Sales Channels
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// How many orders to skip before the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of orders returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// (Comma separated) Which fields should be expanded in each order of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each order of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrdersParamsStatus defines parameters for GetOrders.
type GetOrdersParamsStatus string

// GetOrdersParamsFulfillmentStatus defines parameters for GetOrders.
type GetOrdersParamsFulfillmentStatus string

// GetOrdersParamsPaymentStatus defines parameters for GetOrders.
type GetOrdersParamsPaymentStatus string

// PostOrdersOrderJSONBody defines parameters for PostOrdersOrder.
type PostOrdersOrderJSONBody struct {
	// Billing address
	BillingAddress *interface{} `json:"billing_address,omitempty"`

	// ID of the customer
	CustomerId *string `json:"customer_id,omitempty"`

	// Discounts applied to the order
	Discounts *[]Discount `json:"discounts,omitempty"`

	// the email for the order
	Email *string `json:"email,omitempty"`

	// The Line Items for the order
	Items *[]LineItem `json:"items,omitempty"`

	// A flag to indicate if no notifications should be emitted related to the updated order.
	NoNotification *bool `json:"no_notification,omitempty"`

	// payment method chosen for the order
	PaymentMethod *struct {
		// Data relevant for the given payment method
		Data *map[string]interface{} `json:"data,omitempty"`

		// ID of the payment provider
		ProviderId *string `json:"provider_id,omitempty"`
	} `json:"payment_method,omitempty"`

	// ID of the region where the order belongs
	Region *string `json:"region,omitempty"`

	// Shipping address
	ShippingAddress *interface{} `json:"shipping_address,omitempty"`

	// The Shipping Method used for shipping the order.
	ShippingMethod *struct {
		// Data relevant to the specific shipping method.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Items to ship
		Items *[]LineItem `json:"items,omitempty"`

		// The price of the shipping.
		Price *int `json:"price,omitempty"`

		// The ID of the shipping profile.
		ProfileId *string `json:"profile_id,omitempty"`

		// The ID of the shipping provider.
		ProviderId *string `json:"provider_id,omitempty"`
	} `json:"shipping_method,omitempty"`
}

// PostOrdersOrderClaimsClaimFulfillmentsJSONBody defines parameters for PostOrdersOrderClaimsClaimFulfillments.
type PostOrdersOrderClaimsClaimFulfillmentsJSONBody struct {
	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true no notification will be send related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersOrderClaimsClaimShipmentsJSONBody defines parameters for PostOrdersOrderClaimsClaimShipments.
type PostOrdersOrderClaimsClaimShipmentsJSONBody struct {
	// The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// The tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// PostOrdersOrderFulfillmentsJSONBody defines parameters for PostOrdersOrderFulfillments.
type PostOrdersOrderFulfillmentsJSONBody struct {
	// The Line Items to include in the Fulfillment.
	Items []struct {
		// The ID of Line Item to fulfill.
		ItemId string `json:"item_id"`

		// The quantity of the Line Item to fulfill.
		Quantity int `json:"quantity"`
	} `json:"items"`

	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true no notification will be send related to this Swap.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersOrderRefundsJSONBody defines parameters for PostOrdersOrderRefunds.
type PostOrdersOrderRefundsJSONBody struct {
	// The amount to refund.
	Amount int `json:"amount"`

	// If set to true no notification will be send related to this Refund.
	NoNotification *bool `json:"no_notification,omitempty"`

	// A note with additional details about the Refund.
	Note *string `json:"note,omitempty"`

	// The reason for the Refund.
	Reason string `json:"reason"`
}

// PostOrdersOrderReturnsJSONBody defines parameters for PostOrdersOrderReturns.
type PostOrdersOrderReturnsJSONBody struct {
	// The Line Items that will be returned.
	Items []struct {
		// The ID of the Line Item.
		ItemId string `json:"item_id"`

		// An optional note with information about the Return.
		Note *string `json:"note,omitempty"`

		// The quantity of the Line Item.
		Quantity int `json:"quantity"`

		// The ID of the Return Reason to use.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"items"`

	// A flag to indicate if no notifications should be emitted related to the requested Return.
	NoNotification *bool `json:"no_notification,omitempty"`

	// An optional note with information about the Return.
	Note *string `json:"note,omitempty"`

	// A flag to indicate if the Return should be registerd as received immediately.
	ReceiveNow *bool `json:"receive_now,omitempty"`

	// The amount to refund.
	Refund *int `json:"refund,omitempty"`

	// The Shipping Method to be used to handle the return shipment.
	ReturnShipping *struct {
		// The ID of the Shipping Option to create the Shipping Method from.
		OptionId *string `json:"option_id,omitempty"`

		// The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`
}

// PostOrdersOrderShipmentJSONBody defines parameters for PostOrdersOrderShipment.
type PostOrdersOrderShipmentJSONBody struct {
	// The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// If set to true no notification will be send related to this Shipment.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// PostOrdersOrderShippingMethodsJSONBody defines parameters for PostOrdersOrderShippingMethods.
type PostOrdersOrderShippingMethodsJSONBody struct {
	// The data required for the Shipping Option to create a Shipping Method. This will depend on the Fulfillment Provider.
	Data *map[string]interface{} `json:"data,omitempty"`

	// The ID of the Shipping Option to create the Shipping Method from.
	OptionId string `json:"option_id"`

	// The price (excluding VAT) that should be charged for the Shipping Method
	Price int `json:"price"`
}

// PostOrdersOrderSwapsSwapFulfillmentsJSONBody defines parameters for PostOrdersOrderSwapsSwapFulfillments.
type PostOrdersOrderSwapsSwapFulfillmentsJSONBody struct {
	// An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// If set to true no notification will be send related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersOrderSwapsSwapShipmentsJSONBody defines parameters for PostOrdersOrderSwapsSwapShipments.
type PostOrdersOrderSwapsSwapShipmentsJSONBody struct {
	// The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// If set to true no notification will be sent related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// The tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// GetPriceListsParams defines parameters for GetPriceLists.
type GetPriceListsParams struct {
	// The number of items to get
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// The offset at which to get items
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// (Comma separated) Which fields should be expanded in each item of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// field to order results by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// ID to search for.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// query to search in price list description, price list name, and customer group name fields.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Status to search for.
	Status *[]GetPriceListsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// price list name to search for.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Customer Group IDs to search for.
	CustomerGroups *[]string `form:"customer_groups,omitempty" json:"customer_groups,omitempty"`

	// Type to search for.
	Type *[]GetPriceListsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Date comparison for when resulting price lists were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting price lists were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting price lists were deleted.
	DeletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetPriceListsParamsStatus defines parameters for GetPriceLists.
type GetPriceListsParamsStatus string

// GetPriceListsParamsType defines parameters for GetPriceLists.
type GetPriceListsParamsType string

// PostPriceListsPriceListJSONBody defines parameters for PostPriceListsPriceList.
type PostPriceListsPriceListJSONBody struct {
	// A list of customer groups that the Price List applies to.
	CustomerGroups *[]struct {
		// The ID of a customer group
		Id string `json:"id"`
	} `json:"customer_groups,omitempty"`

	// A description of the Price List.
	Description string `json:"description"`

	// The date with timezone that the Price List ends being valid.
	EndsAt *openapi_types.Date `json:"ends_at,omitempty"`

	// [EXPERIMENTAL] Tax included in prices of price list
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The name of the Price List
	Name string `json:"name"`

	// The prices of the Price List.
	Prices []struct {
		// The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// The ID of the Region for which the price is used. Only required if currecny_code is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices"`

	// The date with timezone that the Price List starts being valid.
	StartsAt *openapi_types.Date `json:"starts_at,omitempty"`

	// The status of the Price List.
	Status *PostPriceListsPriceListJSONBodyStatus `json:"status,omitempty"`

	// The type of the Price List.
	Type PostPriceListsPriceListJSONBodyType `json:"type"`
}

// PostPriceListsPriceListJSONBodyStatus defines parameters for PostPriceListsPriceList.
type PostPriceListsPriceListJSONBodyStatus string

// PostPriceListsPriceListJSONBodyType defines parameters for PostPriceListsPriceList.
type PostPriceListsPriceListJSONBodyType string

// PostPriceListsPriceListPriceListJSONBody defines parameters for PostPriceListsPriceListPriceList.
type PostPriceListsPriceListPriceListJSONBody struct {
	// A list of customer groups that the Price List applies to.
	CustomerGroups *[]struct {
		// The ID of a customer group
		Id string `json:"id"`
	} `json:"customer_groups,omitempty"`

	// A description of the Price List.
	Description *string `json:"description,omitempty"`

	// The date with timezone that the Price List ends being valid.
	EndsAt *openapi_types.Date `json:"ends_at,omitempty"`

	// [EXPERIMENTAL] Tax included in prices of price list
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The name of the Price List
	Name *string `json:"name,omitempty"`

	// The prices of the Price List.
	Prices *[]struct {
		// The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// The ID of the price.
		Id *string `json:"id,omitempty"`

		// The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// The ID of the Region for which the price is used. Only required if currecny_code is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices,omitempty"`

	// The date with timezone that the Price List starts being valid.
	StartsAt *openapi_types.Date `json:"starts_at,omitempty"`

	// The status of the Price List.
	Status *PostPriceListsPriceListPriceListJSONBodyStatus `json:"status,omitempty"`

	// The type of the Price List.
	Type *PostPriceListsPriceListPriceListJSONBodyType `json:"type,omitempty"`
}

// PostPriceListsPriceListPriceListJSONBodyStatus defines parameters for PostPriceListsPriceListPriceList.
type PostPriceListsPriceListPriceListJSONBodyStatus string

// PostPriceListsPriceListPriceListJSONBodyType defines parameters for PostPriceListsPriceListPriceList.
type PostPriceListsPriceListPriceListJSONBodyType string

// DeletePriceListsPriceListPricesBatchJSONBody defines parameters for DeletePriceListsPriceListPricesBatch.
type DeletePriceListsPriceListPricesBatchJSONBody struct {
	// The price id's of the Money Amounts to delete.
	PriceIds *[]string `json:"price_ids,omitempty"`
}

// PostPriceListsPriceListPricesBatchJSONBody defines parameters for PostPriceListsPriceListPricesBatch.
type PostPriceListsPriceListPricesBatchJSONBody struct {
	// If true the prices will replace all existing prices associated with the Price List.
	Override *bool `json:"override,omitempty"`

	// The prices to update or add.
	Prices *[]struct {
		// The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// The ID of the price.
		Id *string `json:"id,omitempty"`

		// The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// The ID of the Region for which the price is used. Only required if currecny_code is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices,omitempty"`
}

// GetPriceListsPriceListProductsParams defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParams struct {
	// Query used for searching product title and description, variant title and sku, and collection title.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// ID of the product to search for.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Product status to search for
	Status *[]GetPriceListsPriceListProductsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Collection IDs to search for
	CollectionId *[]string `form:"collection_id,omitempty" json:"collection_id,omitempty"`

	// Tag IDs to search for
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// product title to search for.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// product description to search for.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// product handle to search for.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// Search for giftcards using is_giftcard=true.
	IsGiftcard *string `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

	// to search for.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// field to sort results by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Date comparison for when resulting products were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting products were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting products were deleted.
	DeletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// How many products to skip in the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of products returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// (Comma separated) Which fields should be expanded in each product of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each product of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPriceListsPriceListProductsParamsStatus defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParamsStatus string

// GetProductTagsParams defines parameters for GetProductTags.
type GetProductTagsParams struct {
	// The number of tags to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// The field to sort items by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// The tag values to search for
	Value *[]string `form:"value,omitempty" json:"value,omitempty"`

	// A query string to search values for
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// The tag IDs to search for
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Date comparison for when resulting product tags were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting product tags were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetProductTypesParams defines parameters for GetProductTypes.
type GetProductTypesParams struct {
	// The number of types to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// The field to sort items by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// The type values to search for
	Value *[]string `form:"value,omitempty" json:"value,omitempty"`

	// The type IDs to search for
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// A query string to search values for
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Date comparison for when resulting product types were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting product types were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetProductsParams defines parameters for GetProducts.
type GetProductsParams struct {
	// Query used for searching product title and description, variant title and sku, and collection title.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Filter by product IDs.
	Id *interface{} `form:"id,omitempty" json:"id,omitempty"`

	// Status to search for
	Status *[]GetProductsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Collection ids to search for.
	CollectionId *[]string `form:"collection_id,omitempty" json:"collection_id,omitempty"`

	// Tag IDs to search for
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Price List IDs to search for
	PriceListId *[]string `form:"price_list_id,omitempty" json:"price_list_id,omitempty"`

	// Sales Channel IDs to filter products by
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// title to search for.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// description to search for.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// handle to search for.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// Search for giftcards using is_giftcard=true.
	IsGiftcard *bool `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

	// type ID to search for.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Date comparison for when resulting products were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting products were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting products were deleted.
	DeletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// How many products to skip in the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of products returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// (Comma separated) Which fields should be expanded in each product of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each product of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsParamsStatus defines parameters for GetProducts.
type GetProductsParamsStatus string

// PostProductsJSONBody defines parameters for PostProducts.
type PostProductsJSONBody struct {
	// The ID of the Collection the Product should belong to.
	CollectionId *string `json:"collection_id,omitempty"`

	// A description of the Product.
	Description *string `json:"description,omitempty"`

	// A flag to indicate if discounts can be applied to the LineItems generated from this Product
	Discountable *bool `json:"discountable,omitempty"`

	// A unique handle to identify the Product by.
	Handle *string `json:"handle,omitempty"`

	// The height of the Product.
	Height *float32 `json:"height,omitempty"`

	// The Harmonized System code for the Product Variant.
	HsCode *string `json:"hs_code,omitempty"`

	// Images of the Product.
	Images *[]string `json:"images,omitempty"`

	// A flag to indicate if the Product represents a Gift Card. Purchasing Products with this flag set to `true` will result in a Gift Card being created.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// The length of the Product.
	Length *float32 `json:"length,omitempty"`

	// The material composition of the Product.
	Material *string `json:"material,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturer Identification code for the Product.
	MidCode *string `json:"mid_code,omitempty"`

	// The Options that the Product should have. These define on which properties the Product's Product Variants will differ.
	Options *[]struct {
		// The title to identify the Product Option by.
		Title string `json:"title"`
	} `json:"options,omitempty"`

	// The country of origin of the Product.
	OriginCountry *string `json:"origin_country,omitempty"`

	// [EXPERIMENTAL] Sales channels to associate the Product with.
	SalesChannels *[]struct {
		// The ID of an existing Sales channel.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// The status of the product.
	Status *PostProductsJSONBodyStatus `json:"status,omitempty"`

	// The subtitle of the Product
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags to associate the Product with.
	Tags *[]struct {
		// The ID of an existing Tag.
		Id *string `json:"id,omitempty"`

		// The value of the Tag, these will be upserted.
		Value string `json:"value"`
	} `json:"tags,omitempty"`

	// The thumbnail to use for the Product.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// The title of the Product
	Title string `json:"title"`

	// The Product Type to associate the Product with.
	Type *struct {
		// The ID of the Product Type.
		Id *string `json:"id,omitempty"`

		// The value of the Product Type.
		Value string `json:"value"`
	} `json:"type,omitempty"`

	// A list of Product Variants to create with the Product.
	Variants *[]struct {
		// Whether the Product Variant can be purchased when out of stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// A generic GTIN field for the Product Variant.
		Barcode *string `json:"barcode,omitempty"`

		// The EAN number of the item.
		Ean *string `json:"ean,omitempty"`

		// The height of the Product Variant.
		Height *float32 `json:"height,omitempty"`

		// The Harmonized System code for the Product Variant.
		HsCode *string `json:"hs_code,omitempty"`

		// The amount of stock kept for the Product Variant.
		InventoryQuantity *int `json:"inventory_quantity,omitempty"`

		// The length of the Product Variant.
		Length *float32 `json:"length,omitempty"`

		// Whether Medusa should keep track of the inventory for this Product Variant.
		ManageInventory *bool `json:"manage_inventory,omitempty"`

		// The material composition of the Product Variant.
		Material *string `json:"material,omitempty"`

		// An optional set of key-value pairs with additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// The Manufacturer Identification code for the Product Variant.
		MidCode *string `json:"mid_code,omitempty"`
		Options *[]struct {
			// The value to give for the Product Option at the same index in the Product's `options` field.
			Value string `json:"value"`
		} `json:"options,omitempty"`

		// The country of origin of the Product Variant.
		OriginCountry *string `json:"origin_country,omitempty"`
		Prices        *[]struct {
			// The amount to charge for the Product Variant.
			Amount int `json:"amount"`

			// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// The maximum quantity for which the price will be used.
			MaxQuantity *int `json:"max_quantity,omitempty"`

			// The minimum quantity for which the price will be used.
			MinQuantity *int `json:"min_quantity,omitempty"`

			// The ID of the Region for which the price is used. Only required if currency_code is not provided.
			RegionId *string `json:"region_id,omitempty"`
		} `json:"prices,omitempty"`

		// The unique SKU for the Product Variant.
		Sku *string `json:"sku,omitempty"`

		// The title to identify the Product Variant by.
		Title string `json:"title"`

		// The UPC number of the item.
		Upc *string `json:"upc,omitempty"`

		// The wieght of the Product Variant.
		Weight *float32 `json:"weight,omitempty"`

		// The width of the Product Variant.
		Width *float32 `json:"width,omitempty"`
	} `json:"variants,omitempty"`

	// The weight of the Product.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsJSONBodyStatus defines parameters for PostProducts.
type PostProductsJSONBodyStatus string

// PostProductsProductJSONBody defines parameters for PostProductsProduct.
type PostProductsProductJSONBody struct {
	// The ID of the Collection the Product should belong to.
	CollectionId *string `json:"collection_id,omitempty"`

	// A description of the Product.
	Description *string `json:"description,omitempty"`

	// A flag to indicate if discounts can be applied to the LineItems generated from this Product
	Discountable *bool `json:"discountable,omitempty"`

	// A unique handle to identify the Product by.
	Handle *string `json:"handle,omitempty"`

	// The height of the Product.
	Height *float32 `json:"height,omitempty"`

	// Images of the Product.
	Images *[]string `json:"images,omitempty"`

	// The length of the Product.
	Length *float32 `json:"length,omitempty"`

	// The material composition of the Product.
	Material *string `json:"material,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturer Identification code for the Product.
	MidCode *string `json:"mid_code,omitempty"`

	// The country of origin of the Product.
	OriginCountry *string `json:"origin_country,omitempty"`

	// [EXPERIMENTAL] Sales channels to associate the Product with.
	SalesChannels *[]struct {
		// The ID of an existing Sales channel.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// The status of the product.
	Status *PostProductsProductJSONBodyStatus `json:"status,omitempty"`

	// The subtitle of the Product
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags to associate the Product with.
	Tags *[]struct {
		// The ID of an existing Tag.
		Id *string `json:"id,omitempty"`

		// The value of the Tag, these will be upserted.
		Value string `json:"value"`
	} `json:"tags,omitempty"`

	// The thumbnail to use for the Product.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// The title of the Product
	Title *string `json:"title,omitempty"`

	// The Product Type to associate the Product with.
	Type *struct {
		// The ID of the Product Type.
		Id *string `json:"id,omitempty"`

		// The value of the Product Type.
		Value string `json:"value"`
	} `json:"type,omitempty"`

	// A list of Product Variants to create with the Product.
	Variants *[]struct {
		// Whether the Product Variant can be purchased when out of stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// A generic GTIN field for the Product Variant.
		Barcode *string `json:"barcode,omitempty"`

		// The EAN number of the item.
		Ean *string `json:"ean,omitempty"`

		// The height of the Product Variant.
		Height *float32 `json:"height,omitempty"`

		// The Harmonized System code for the Product Variant.
		HsCode *string `json:"hs_code,omitempty"`

		// The ID of the Product Variant.
		Id *string `json:"id,omitempty"`

		// The amount of stock kept for the Product Variant.
		InventoryQuantity *int `json:"inventory_quantity,omitempty"`

		// The length of the Product Variant.
		Length *float32 `json:"length,omitempty"`

		// Whether Medusa should keep track of the inventory for this Product Variant.
		ManageInventory *bool `json:"manage_inventory,omitempty"`

		// The material composition of the Product Variant.
		Material *string `json:"material,omitempty"`

		// An optional set of key-value pairs with additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// The Manufacturer Identification code for the Product Variant.
		MidCode *string `json:"mid_code,omitempty"`
		Options *[]struct {
			// The ID of the Option.
			OptionId string `json:"option_id"`

			// The value to give for the Product Option at the same index in the Product's `options` field.
			Value string `json:"value"`
		} `json:"options,omitempty"`

		// The country of origin of the Product Variant.
		OriginCountry *string `json:"origin_country,omitempty"`
		Prices        *[]struct {
			// The amount to charge for the Product Variant.
			Amount int `json:"amount"`

			// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// The ID of the Price.
			Id *string `json:"id,omitempty"`

			// The maximum quantity for which the price will be used.
			MaxQuantity *int `json:"max_quantity,omitempty"`

			// The minimum quantity for which the price will be used.
			MinQuantity *int `json:"min_quantity,omitempty"`

			// The ID of the Region for which the price is used. Only required if currency_code is not provided.
			RegionId *string `json:"region_id,omitempty"`
		} `json:"prices,omitempty"`

		// The unique SKU for the Product Variant.
		Sku *string `json:"sku,omitempty"`

		// The title to identify the Product Variant by.
		Title *string `json:"title,omitempty"`

		// The UPC number of the item.
		Upc *string `json:"upc,omitempty"`

		// The wieght of the Product Variant.
		Weight *float32 `json:"weight,omitempty"`

		// The width of the Product Variant.
		Width *float32 `json:"width,omitempty"`
	} `json:"variants,omitempty"`

	// The wieght of the Product.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsProductJSONBodyStatus defines parameters for PostProductsProduct.
type PostProductsProductJSONBodyStatus string

// PostProductsProductMetadataJSONBody defines parameters for PostProductsProductMetadata.
type PostProductsProductMetadataJSONBody struct {
	// The metadata key
	Key string `json:"key"`

	// The metadata value
	Value string `json:"value"`
}

// PostProductsProductOptionsJSONBody defines parameters for PostProductsProductOptions.
type PostProductsProductOptionsJSONBody struct {
	// The title the Product Option will be identified by i.e. "Size"
	Title string `json:"title"`
}

// PostProductsProductOptionsOptionJSONBody defines parameters for PostProductsProductOptionsOption.
type PostProductsProductOptionsOptionJSONBody struct {
	// The title of the Product Option
	Title string `json:"title"`
}

// GetProductsProductVariantsParams defines parameters for GetProductsProductVariants.
type GetProductsProductVariantsParams struct {
	// Comma separated string of the column to select.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Comma separated string of the relations to include.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// How many items to skip before the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of items returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostProductsProductVariantsJSONBody defines parameters for PostProductsProductVariants.
type PostProductsProductVariantsJSONBody struct {
	// Whether the Product Variant can be purchased when out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// A generic GTIN field for the Product Variant.
	Barcode *string `json:"barcode,omitempty"`

	// The EAN number of the item.
	Ean *string `json:"ean,omitempty"`

	// The height of the Product Variant.
	Height *float32 `json:"height,omitempty"`

	// The Harmonized System code for the Product Variant.
	HsCode *string `json:"hs_code,omitempty"`

	// The amount of stock kept for the Product Variant.
	InventoryQuantity *int `json:"inventory_quantity,omitempty"`

	// The length of the Product Variant.
	Length *float32 `json:"length,omitempty"`

	// Whether Medusa should keep track of the inventory for this Product Variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// The material composition of the Product Variant.
	Material *string `json:"material,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturer Identification code for the Product Variant.
	MidCode *string `json:"mid_code,omitempty"`
	Options []struct {
		// The ID of the Product Option to set the value for.
		OptionId string `json:"option_id"`

		// The value to give for the Product Option.
		Value string `json:"value"`
	} `json:"options"`

	// The country of origin of the Product Variant.
	OriginCountry *string `json:"origin_country,omitempty"`
	Prices        []struct {
		// The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// The ID of the price.
		Id *string `json:"id,omitempty"`

		// The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// The ID of the Region for which the price is used. Only required if currency_code is not provided.
		RegionId *string `json:"region_id,omitempty"`
	} `json:"prices"`

	// The unique SKU for the Product Variant.
	Sku *string `json:"sku,omitempty"`

	// The title to identify the Product Variant by.
	Title string `json:"title"`

	// The UPC number of the item.
	Upc *string `json:"upc,omitempty"`

	// The wieght of the Product Variant.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product Variant.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsProductVariantsVariantJSONBody defines parameters for PostProductsProductVariantsVariant.
type PostProductsProductVariantsVariantJSONBody struct {
	// Whether the Product Variant can be purchased when out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// A generic GTIN field for the Product Variant.
	Barcode *string `json:"barcode,omitempty"`

	// The EAN number of the item.
	Ean *string `json:"ean,omitempty"`

	// The height of the Product Variant.
	Height *float32 `json:"height,omitempty"`

	// The Harmonized System code for the Product Variant.
	HsCode *string `json:"hs_code,omitempty"`

	// The amount of stock kept for the Product Variant.
	InventoryQuantity *int `json:"inventory_quantity,omitempty"`

	// The length of the Product Variant.
	Length *float32 `json:"length,omitempty"`

	// Whether Medusa should keep track of the inventory for this Product Variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// The material composition of the Product Variant.
	Material *string `json:"material,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The Manufacturer Identification code for the Product Variant.
	MidCode *string `json:"mid_code,omitempty"`
	Options *[]struct {
		// The ID of the Product Option to set the value for.
		OptionId string `json:"option_id"`

		// The value to give for the Product Option.
		Value string `json:"value"`
	} `json:"options,omitempty"`

	// The country of origin of the Product Variant.
	OriginCountry *string `json:"origin_country,omitempty"`
	Prices        []struct {
		// The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// The 3 character ISO currency code for which the price will be used. Only required if region_id is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// The ID of the price.
		Id *string `json:"id,omitempty"`

		// The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// The ID of the Region for which the price is used. Only required if currency_code is not provided.
		RegionId *string `json:"region_id,omitempty"`
	} `json:"prices"`

	// The unique SKU for the Product Variant.
	Sku *string `json:"sku,omitempty"`

	// The title to identify the Product Variant by.
	Title *string `json:"title,omitempty"`

	// The UPC number of the item.
	Upc *string `json:"upc,omitempty"`

	// The weight of the Product Variant.
	Weight *float32 `json:"weight,omitempty"`

	// The width of the Product Variant.
	Width *float32 `json:"width,omitempty"`
}

// GetRegionsParams defines parameters for GetRegions.
type GetRegionsParams struct {
	// limit the number of regions in response
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset of regions in response (used for pagination)
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Date comparison for when resulting region was created, i.e. less than, greater than etc.
	CreatedAt *map[string]interface{} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting region was updated, i.e. less than, greater than etc.
	UpdatedAt *map[string]interface{} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting region was deleted, i.e. less than, greater than etc.
	DeletedAt *map[string]interface{} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// PostRegionsJSONBody defines parameters for PostRegions.
type PostRegionsJSONBody struct {
	// A list of countries' 2 ISO Characters that should be included in the Region.
	Countries []string `json:"countries"`

	// The 3 character ISO currency code to use for the Region.
	CurrencyCode string `json:"currency_code"`

	// A list of Fulfillment Provider IDs that should be enabled for the Region
	FulfillmentProviders []string `json:"fulfillment_providers"`

	// [EXPERIMENTAL] Tax included in prices of region
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The name of the Region
	Name string `json:"name"`

	// A list of Payment Provider IDs that should be enabled for the Region
	PaymentProviders []string `json:"payment_providers"`

	// An optional tax code the Region.
	TaxCode *string `json:"tax_code,omitempty"`

	// The tax rate to use on Orders in the Region.
	TaxRate float32 `json:"tax_rate"`
}

// PostRegionsRegionJSONBody defines parameters for PostRegionsRegion.
type PostRegionsRegionJSONBody struct {
	// If true Medusa will automatically calculate taxes for carts in this region. If false you have to manually call POST /carts/:id/taxes.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// A list of countries' 2 ISO Characters that should be included in the Region.
	Countries *[]string `json:"countries,omitempty"`

	// The 3 character ISO currency code to use for the Region.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// A list of Fulfillment Provider IDs that should be enabled for the Region
	FulfillmentProviders *[]string `json:"fulfillment_providers,omitempty"`

	// Whether gift cards in this region should be applied sales tax when purchasing a gift card
	GiftCardsTaxable *bool `json:"gift_cards_taxable,omitempty"`

	// [EXPERIMENTAL] Tax included in prices of region
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// The name of the Region
	Name *string `json:"name,omitempty"`

	// A list of Payment Provider IDs that should be enabled for the Region
	PaymentProviders *[]string `json:"payment_providers,omitempty"`

	// An optional tax code the Region.
	TaxCode *string `json:"tax_code,omitempty"`

	// The ID of the tax provider to use; if null the system tax provider is used
	TaxProviderId *string `json:"tax_provider_id,omitempty"`

	// The tax rate to use on Orders in the Region.
	TaxRate *float32 `json:"tax_rate,omitempty"`
}

// PostRegionsRegionCountriesJSONBody defines parameters for PostRegionsRegionCountries.
type PostRegionsRegionCountriesJSONBody struct {
	// The 2 character ISO code for the Country.
	CountryCode string `json:"country_code"`
}

// PostRegionsRegionFulfillmentProvidersJSONBody defines parameters for PostRegionsRegionFulfillmentProviders.
type PostRegionsRegionFulfillmentProvidersJSONBody struct {
	// The ID of the Fulfillment Provider to add.
	ProviderId string `json:"provider_id"`
}

// PostRegionsRegionPaymentProvidersJSONBody defines parameters for PostRegionsRegionPaymentProviders.
type PostRegionsRegionPaymentProvidersJSONBody struct {
	// The ID of the Payment Provider to add.
	ProviderId string `json:"provider_id"`
}

// PostReturnReasonsJSONBody defines parameters for PostReturnReasons.
type PostReturnReasonsJSONBody struct {
	// An optional description to for the Reason.
	Description *string `json:"description,omitempty"`

	// The label to display to the Customer.
	Label string `json:"label"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The ID of the parent return reason.
	ParentReturnReasonId *string `json:"parent_return_reason_id,omitempty"`

	// The value that the Return Reason will be identified by. Must be unique.
	Value string `json:"value"`
}

// PostReturnReasonsReasonJSONBody defines parameters for PostReturnReasonsReason.
type PostReturnReasonsReasonJSONBody struct {
	// An optional description to for the Reason.
	Description *string `json:"description,omitempty"`

	// The label to display to the Customer.
	Label *string `json:"label,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The value that the Return Reason will be identified by. Must be unique.
	Value *string `json:"value,omitempty"`
}

// GetReturnsParams defines parameters for GetReturns.
type GetReturnsParams struct {
	// The upper limit for the amount of responses returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// The offset of the list returned.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostReturnsReturnReceiveJSONBody defines parameters for PostReturnsReturnReceive.
type PostReturnsReturnReceiveJSONBody struct {
	// The Line Items that have been received.
	Items []struct {
		// The ID of the Line Item.
		ItemId string `json:"item_id"`

		// The quantity of the Line Item.
		Quantity int `json:"quantity"`
	} `json:"items"`

	// The amount to refund.
	Refund *float32 `json:"refund,omitempty"`
}

// GetSalesChannelsParams defines parameters for GetSalesChannels.
type GetSalesChannelsParams struct {
	// ID of the sales channel
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name of the sales channel
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Description of the sales channel
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Query used for searching sales channels' names and descriptions.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// The field to order the results by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Date comparison for when resulting collections were created.
	CreatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Date comparison for when resulting collections were updated.
	UpdatedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Date comparison for when resulting collections were deleted.
	DeletedAt *struct {
		// filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// How many sales channels to skip in the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of sales channels returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// (Comma separated) Which fields should be expanded in each sales channel of the result.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// (Comma separated) Which fields should be included in each sales channel of the result.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostSalesChannelsJSONBody defines parameters for PostSalesChannels.
type PostSalesChannelsJSONBody struct {
	// The description of the Sales Channel
	Description *string `json:"description,omitempty"`

	// Whether the Sales Channel is disabled or not.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// The name of the Sales Channel
	Name string `json:"name"`
}

// PostSalesChannelsSalesChannelJSONBody defines parameters for PostSalesChannelsSalesChannel.
type PostSalesChannelsSalesChannelJSONBody struct {
	// Sales Channel description.
	Description *string `json:"description,omitempty"`

	// Indication of if the sales channel is active.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Name of the sales channel.
	Name *string `json:"name,omitempty"`
}

// DeleteSalesChannelsChannelProductsBatchJSONBody defines parameters for DeleteSalesChannelsChannelProductsBatch.
type DeleteSalesChannelsChannelProductsBatchJSONBody struct {
	// The IDs of the products to delete from the Sales Channel.
	ProductIds []struct {
		// The ID of a product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// PostSalesChannelsChannelProductsBatchJSONBody defines parameters for PostSalesChannelsChannelProductsBatch.
type PostSalesChannelsChannelProductsBatchJSONBody struct {
	// The IDs of the products to add to the Sales Channel
	ProductIds []struct {
		// The ID of the product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// GetShippingOptionsParams defines parameters for GetShippingOptions.
type GetShippingOptionsParams struct {
	// Region ID to fetch options from
	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Flag for fetching return options only
	IsReturn *bool `form:"is_return,omitempty" json:"is_return,omitempty"`

	// Flag for fetching admin specific options
	AdminOnly *bool `form:"admin_only,omitempty" json:"admin_only,omitempty"`
}

// PostShippingOptionsJSONBody defines parameters for PostShippingOptions.
type PostShippingOptionsJSONBody struct {
	// If true, the option can be used for draft orders
	AdminOnly *bool `json:"admin_only,omitempty"`

	// The amount to charge for the Shipping Option.
	Amount *int `json:"amount,omitempty"`

	// The data needed for the Fulfillment Provider to handle shipping with this Shipping Option.
	Data map[string]interface{} `json:"data"`

	// [EXPERIMENTAL] Tax included in prices of shipping option
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Whether the Shipping Option defines a return shipment.
	IsReturn *bool `json:"is_return,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the Shipping Option
	Name string `json:"name"`

	// The type of the Shipping Option price.
	PriceType PostShippingOptionsJSONBodyPriceType `json:"price_type"`

	// The ID of the Shipping Profile to add the Shipping Option to.
	ProfileId *float32 `json:"profile_id,omitempty"`

	// The ID of the Fulfillment Provider that handles the Shipping Option.
	ProviderId string `json:"provider_id"`

	// The ID of the Region in which the Shipping Option will be available.
	RegionId string `json:"region_id"`

	// The requirements that must be satisfied for the Shipping Option to be available.
	Requirements *[]struct {
		// The amount to compare with.
		Amount int `json:"amount"`

		// The type of the requirement
		Type PostShippingOptionsJSONBodyRequirementsType `json:"type"`
	} `json:"requirements,omitempty"`
}

// PostShippingOptionsJSONBodyPriceType defines parameters for PostShippingOptions.
type PostShippingOptionsJSONBodyPriceType string

// PostShippingOptionsJSONBodyRequirementsType defines parameters for PostShippingOptions.
type PostShippingOptionsJSONBodyRequirementsType string

// PostShippingOptionsOptionJSONBody defines parameters for PostShippingOptionsOption.
type PostShippingOptionsOptionJSONBody struct {
	// If true, the option can be used for draft orders
	AdminOnly *bool `json:"admin_only,omitempty"`

	// The amount to charge for the Shipping Option.
	Amount *int `json:"amount,omitempty"`

	// [EXPERIMENTAL] Tax included in prices of shipping option
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the Shipping Option
	Name *string `json:"name,omitempty"`

	// The requirements that must be satisfied for the Shipping Option to be available.
	Requirements []struct {
		// The amount to compare with.
		Amount int `json:"amount"`

		// The ID of the requirement
		Id *string `json:"id,omitempty"`

		// The type of the requirement
		Type PostShippingOptionsOptionJSONBodyRequirementsType `json:"type"`
	} `json:"requirements"`
}

// PostShippingOptionsOptionJSONBodyRequirementsType defines parameters for PostShippingOptionsOption.
type PostShippingOptionsOptionJSONBodyRequirementsType string

// PostShippingProfilesJSONBody defines parameters for PostShippingProfiles.
type PostShippingProfilesJSONBody struct {
	// The name of the Shipping Profile
	Name string `json:"name"`
}

// PostShippingProfilesProfileJSONBody defines parameters for PostShippingProfilesProfile.
type PostShippingProfilesProfileJSONBody struct {
	// The name of the Shipping Profile
	Name *string `json:"name,omitempty"`
}

// PostStoreJSONBody defines parameters for PostStore.
type PostStoreJSONBody struct {
	// Array of currencies in 2 character ISO code format.
	Currencies *[]string `json:"currencies,omitempty"`

	// The default currency code for the Store.
	DefaultCurrencyCode *string `json:"default_currency_code,omitempty"`

	// A template for invite links - use `{{invite_token}}` to insert the invite token
	InviteLinkTemplate *string `json:"invite_link_template,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The name of the Store
	Name *string `json:"name,omitempty"`

	// A template for payment links links - use `{{cart_id}}` to insert the Cart id
	PaymentLinkTemplate *string `json:"payment_link_template,omitempty"`

	// A template for Swap links - use `{{cart_id}}` to insert the Swap Cart id
	SwapLinkTemplate *string `json:"swap_link_template,omitempty"`
}

// GetSwapsParams defines parameters for GetSwaps.
type GetSwapsParams struct {
	// The upper limit for the amount of responses returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// The offset of the list returned.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTaxRatesParams defines parameters for GetTaxRates.
type GetTaxRatesParams struct {
	// Name of tax rate to retrieve
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Filter by Region ID
	RegionId *interface{} `form:"region_id,omitempty" json:"region_id,omitempty"`

	// code to search for.
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// Filter by Rate
	Rate *interface{} `form:"rate,omitempty" json:"rate,omitempty"`

	// How many tax rates to skip before retrieving the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of tax rates returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Which fields should be included in each item.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved for each item.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesJSONBody defines parameters for PostTaxRates.
type PostTaxRatesJSONBody struct {
	// A code to identify the tax type by
	Code string `json:"code"`

	// A human friendly name for the tax
	Name string `json:"name"`

	// The IDs of the types of products associated with this tax rate
	ProductTypes *[]string `json:"product_types,omitempty"`

	// The IDs of the products associated with this tax rate
	Products *[]string `json:"products,omitempty"`

	// The numeric rate to charge
	Rate *float32 `json:"rate,omitempty"`

	// The ID of the Region that the rate belongs to
	RegionId string `json:"region_id"`

	// The IDs of the shipping options associated with this tax rate
	ShippingOptions *[]string `json:"shipping_options,omitempty"`
}

// PostTaxRatesParams defines parameters for PostTaxRates.
type PostTaxRatesParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetTaxRatesTaxRateParams defines parameters for GetTaxRatesTaxRate.
type GetTaxRatesTaxRateParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateJSONBody defines parameters for PostTaxRatesTaxRate.
type PostTaxRatesTaxRateJSONBody struct {
	// A code to identify the tax type by
	Code *string `json:"code,omitempty"`

	// A human friendly name for the tax
	Name *string `json:"name,omitempty"`

	// The IDs of the types of products associated with this tax rate
	ProductTypes *[]string `json:"product_types,omitempty"`

	// The IDs of the products associated with this tax rate
	Products *[]string `json:"products,omitempty"`

	// The numeric rate to charge
	Rate *float32 `json:"rate,omitempty"`

	// The ID of the Region that the rate belongs to
	RegionId *string `json:"region_id,omitempty"`

	// The IDs of the shipping options associated with this tax rate
	ShippingOptions *[]string `json:"shipping_options,omitempty"`
}

// PostTaxRatesTaxRateParams defines parameters for PostTaxRatesTaxRate.
type PostTaxRatesTaxRateParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateProductTypesJSONBody defines parameters for DeleteTaxRatesTaxRateProductTypes.
type DeleteTaxRatesTaxRateProductTypesJSONBody struct {
	// The IDs of the types of products to remove association with this tax rate
	ProductTypes []string `json:"product_types"`
}

// DeleteTaxRatesTaxRateProductTypesParams defines parameters for DeleteTaxRatesTaxRateProductTypes.
type DeleteTaxRatesTaxRateProductTypesParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateProductTypesJSONBody defines parameters for PostTaxRatesTaxRateProductTypes.
type PostTaxRatesTaxRateProductTypesJSONBody struct {
	// The IDs of the types of products to associate with this tax rate
	ProductTypes []string `json:"product_types"`
}

// PostTaxRatesTaxRateProductTypesParams defines parameters for PostTaxRatesTaxRateProductTypes.
type PostTaxRatesTaxRateProductTypesParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateProductsJSONBody defines parameters for DeleteTaxRatesTaxRateProducts.
type DeleteTaxRatesTaxRateProductsJSONBody struct {
	// The IDs of the products to remove association with this tax rate
	Products []string `json:"products"`
}

// DeleteTaxRatesTaxRateProductsParams defines parameters for DeleteTaxRatesTaxRateProducts.
type DeleteTaxRatesTaxRateProductsParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateProductsJSONBody defines parameters for PostTaxRatesTaxRateProducts.
type PostTaxRatesTaxRateProductsJSONBody struct {
	// The IDs of the products to associate with this tax rate
	Products []string `json:"products"`
}

// PostTaxRatesTaxRateProductsParams defines parameters for PostTaxRatesTaxRateProducts.
type PostTaxRatesTaxRateProductsParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateShippingOptionsJSONBody defines parameters for DeleteTaxRatesTaxRateShippingOptions.
type DeleteTaxRatesTaxRateShippingOptionsJSONBody struct {
	// The IDs of the shipping options to remove association with this tax rate
	ShippingOptions []string `json:"shipping_options"`
}

// DeleteTaxRatesTaxRateShippingOptionsParams defines parameters for DeleteTaxRatesTaxRateShippingOptions.
type DeleteTaxRatesTaxRateShippingOptionsParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateShippingOptionsJSONBody defines parameters for PostTaxRatesTaxRateShippingOptions.
type PostTaxRatesTaxRateShippingOptionsJSONBody struct {
	// The IDs of the shipping options to associate with this tax rate
	ShippingOptions []string `json:"shipping_options"`
}

// PostTaxRatesTaxRateShippingOptionsParams defines parameters for PostTaxRatesTaxRateShippingOptions.
type PostTaxRatesTaxRateShippingOptionsParams struct {
	// Which fields should be included in the result.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Which fields should be expanded and retrieved in the result.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostUsersJSONBody defines parameters for PostUsers.
type PostUsersJSONBody struct {
	// The Users email.
	Email openapi_types.Email `json:"email"`

	// The name of the User.
	FirstName *string `json:"first_name,omitempty"`

	// The name of the User.
	LastName *string `json:"last_name,omitempty"`

	// The Users password.
	Password string `json:"password"`

	// Userrole assigned to the user.
	Role *PostUsersJSONBodyRole `json:"role,omitempty"`
}

// PostUsersJSONBodyRole defines parameters for PostUsers.
type PostUsersJSONBodyRole string

// PostUsersUserPasswordTokenJSONBody defines parameters for PostUsersUserPasswordToken.
type PostUsersUserPasswordTokenJSONBody struct {
	// The Users email.
	Email openapi_types.Email `json:"email"`
}

// PostUsersUserPasswordJSONBody defines parameters for PostUsersUserPassword.
type PostUsersUserPasswordJSONBody struct {
	// The Users email.
	Email *openapi_types.Email `json:"email,omitempty"`

	// The Users new password.
	Password string `json:"password"`

	// The token generated from the 'password-token' endpoint.
	Token string `json:"token"`
}

// PostUsersUserJSONBody defines parameters for PostUsersUser.
type PostUsersUserJSONBody struct {
	// The api token of the User.
	ApiToken *string `json:"api_token,omitempty"`

	// The name of the User.
	FirstName *string `json:"first_name,omitempty"`

	// The name of the User.
	LastName *string `json:"last_name,omitempty"`

	// An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Userrole assigned to the user.
	Role *PostUsersUserJSONBodyRole `json:"role,omitempty"`
}

// PostUsersUserJSONBodyRole defines parameters for PostUsersUser.
type PostUsersUserJSONBodyRole string

// GetVariantsParams defines parameters for GetVariants.
type GetVariantsParams struct {
	// Query used for searching variants.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// How many variants to skip in the result.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit the number of variants returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDraftOrdersDraftOrderJSONRequestBody defines body for PostDraftOrdersDraftOrder for application/json ContentType.
type PostDraftOrdersDraftOrderJSONRequestBody PostDraftOrdersDraftOrderJSONBody

// PostAppsJSONRequestBody defines body for PostApps for application/json ContentType.
type PostAppsJSONRequestBody PostAppsJSONBody

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostBatchJobsJSONRequestBody defines body for PostBatchJobs for application/json ContentType.
type PostBatchJobsJSONRequestBody PostBatchJobsJSONBody

// PostCollectionsJSONRequestBody defines body for PostCollections for application/json ContentType.
type PostCollectionsJSONRequestBody PostCollectionsJSONBody

// PostCollectionsCollectionJSONRequestBody defines body for PostCollectionsCollection for application/json ContentType.
type PostCollectionsCollectionJSONRequestBody PostCollectionsCollectionJSONBody

// DeleteProductsFromCollectionJSONRequestBody defines body for DeleteProductsFromCollection for application/json ContentType.
type DeleteProductsFromCollectionJSONRequestBody DeleteProductsFromCollectionJSONBody

// PostProductsToCollectionJSONRequestBody defines body for PostProductsToCollection for application/json ContentType.
type PostProductsToCollectionJSONRequestBody PostProductsToCollectionJSONBody

// PostCurrenciesCurrencyJSONRequestBody defines body for PostCurrenciesCurrency for application/json ContentType.
type PostCurrenciesCurrencyJSONRequestBody PostCurrenciesCurrencyJSONBody

// PostCustomerGroupsJSONRequestBody defines body for PostCustomerGroups for application/json ContentType.
type PostCustomerGroupsJSONRequestBody PostCustomerGroupsJSONBody

// PostCustomerGroupsGroupJSONRequestBody defines body for PostCustomerGroupsGroup for application/json ContentType.
type PostCustomerGroupsGroupJSONRequestBody PostCustomerGroupsGroupJSONBody

// DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody defines body for DeleteCustomerGroupsGroupCustomerBatch for application/json ContentType.
type DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody DeleteCustomerGroupsGroupCustomerBatchJSONBody

// PostCustomerGroupsGroupCustomersBatchJSONRequestBody defines body for PostCustomerGroupsGroupCustomersBatch for application/json ContentType.
type PostCustomerGroupsGroupCustomersBatchJSONRequestBody PostCustomerGroupsGroupCustomersBatchJSONBody

// PostCustomersJSONRequestBody defines body for PostCustomers for application/json ContentType.
type PostCustomersJSONRequestBody PostCustomersJSONBody

// PostCustomersCustomerJSONRequestBody defines body for PostCustomersCustomer for application/json ContentType.
type PostCustomersCustomerJSONRequestBody PostCustomersCustomerJSONBody

// PostDiscountsJSONRequestBody defines body for PostDiscounts for application/json ContentType.
type PostDiscountsJSONRequestBody PostDiscountsJSONBody

// PostDiscountsDiscountConditionsJSONRequestBody defines body for PostDiscountsDiscountConditions for application/json ContentType.
type PostDiscountsDiscountConditionsJSONRequestBody PostDiscountsDiscountConditionsJSONBody

// PostDiscountsDiscountConditionsConditionJSONRequestBody defines body for PostDiscountsDiscountConditionsCondition for application/json ContentType.
type PostDiscountsDiscountConditionsConditionJSONRequestBody PostDiscountsDiscountConditionsConditionJSONBody

// PostDiscountsDiscountJSONRequestBody defines body for PostDiscountsDiscount for application/json ContentType.
type PostDiscountsDiscountJSONRequestBody PostDiscountsDiscountJSONBody

// PostDiscountsDiscountDynamicCodesJSONRequestBody defines body for PostDiscountsDiscountDynamicCodes for application/json ContentType.
type PostDiscountsDiscountDynamicCodesJSONRequestBody PostDiscountsDiscountDynamicCodesJSONBody

// PostDraftOrdersJSONRequestBody defines body for PostDraftOrders for application/json ContentType.
type PostDraftOrdersJSONRequestBody PostDraftOrdersJSONBody

// PostDraftOrdersDraftOrderLineItemsJSONRequestBody defines body for PostDraftOrdersDraftOrderLineItems for application/json ContentType.
type PostDraftOrdersDraftOrderLineItemsJSONRequestBody PostDraftOrdersDraftOrderLineItemsJSONBody

// PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody defines body for PostDraftOrdersDraftOrderLineItemsItem for application/json ContentType.
type PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody PostDraftOrdersDraftOrderLineItemsItemJSONBody

// PostGiftCardsJSONRequestBody defines body for PostGiftCards for application/json ContentType.
type PostGiftCardsJSONRequestBody PostGiftCardsJSONBody

// PostGiftCardsGiftCardJSONRequestBody defines body for PostGiftCardsGiftCard for application/json ContentType.
type PostGiftCardsGiftCardJSONRequestBody PostGiftCardsGiftCardJSONBody

// PostInvitesJSONRequestBody defines body for PostInvites for application/json ContentType.
type PostInvitesJSONRequestBody PostInvitesJSONBody

// PostInvitesInviteAcceptJSONRequestBody defines body for PostInvitesInviteAccept for application/json ContentType.
type PostInvitesInviteAcceptJSONRequestBody PostInvitesInviteAcceptJSONBody

// PostNotesJSONRequestBody defines body for PostNotes for application/json ContentType.
type PostNotesJSONRequestBody PostNotesJSONBody

// PostNotesNoteJSONRequestBody defines body for PostNotesNote for application/json ContentType.
type PostNotesNoteJSONRequestBody PostNotesNoteJSONBody

// PostNotificationsNotificationResendJSONRequestBody defines body for PostNotificationsNotificationResend for application/json ContentType.
type PostNotificationsNotificationResendJSONRequestBody PostNotificationsNotificationResendJSONBody

// PostOrdersOrderClaimsJSONRequestBody defines body for PostOrdersOrderClaims for application/json ContentType.
type PostOrdersOrderClaimsJSONRequestBody PostOrdersOrderClaimsJSONBody

// PostOrdersOrderClaimsClaimJSONRequestBody defines body for PostOrdersOrderClaimsClaim for application/json ContentType.
type PostOrdersOrderClaimsClaimJSONRequestBody PostOrdersOrderClaimsClaimJSONBody

// PostOrdersOrderSwapsJSONRequestBody defines body for PostOrdersOrderSwaps for application/json ContentType.
type PostOrdersOrderSwapsJSONRequestBody PostOrdersOrderSwapsJSONBody

// PostOrdersOrderJSONRequestBody defines body for PostOrdersOrder for application/json ContentType.
type PostOrdersOrderJSONRequestBody PostOrdersOrderJSONBody

// PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody defines body for PostOrdersOrderClaimsClaimFulfillments for application/json ContentType.
type PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody PostOrdersOrderClaimsClaimFulfillmentsJSONBody

// PostOrdersOrderClaimsClaimShipmentsJSONRequestBody defines body for PostOrdersOrderClaimsClaimShipments for application/json ContentType.
type PostOrdersOrderClaimsClaimShipmentsJSONRequestBody PostOrdersOrderClaimsClaimShipmentsJSONBody

// PostOrdersOrderFulfillmentsJSONRequestBody defines body for PostOrdersOrderFulfillments for application/json ContentType.
type PostOrdersOrderFulfillmentsJSONRequestBody PostOrdersOrderFulfillmentsJSONBody

// PostOrdersOrderRefundsJSONRequestBody defines body for PostOrdersOrderRefunds for application/json ContentType.
type PostOrdersOrderRefundsJSONRequestBody PostOrdersOrderRefundsJSONBody

// PostOrdersOrderReturnsJSONRequestBody defines body for PostOrdersOrderReturns for application/json ContentType.
type PostOrdersOrderReturnsJSONRequestBody PostOrdersOrderReturnsJSONBody

// PostOrdersOrderShipmentJSONRequestBody defines body for PostOrdersOrderShipment for application/json ContentType.
type PostOrdersOrderShipmentJSONRequestBody PostOrdersOrderShipmentJSONBody

// PostOrdersOrderShippingMethodsJSONRequestBody defines body for PostOrdersOrderShippingMethods for application/json ContentType.
type PostOrdersOrderShippingMethodsJSONRequestBody PostOrdersOrderShippingMethodsJSONBody

// PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody defines body for PostOrdersOrderSwapsSwapFulfillments for application/json ContentType.
type PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody PostOrdersOrderSwapsSwapFulfillmentsJSONBody

// PostOrdersOrderSwapsSwapShipmentsJSONRequestBody defines body for PostOrdersOrderSwapsSwapShipments for application/json ContentType.
type PostOrdersOrderSwapsSwapShipmentsJSONRequestBody PostOrdersOrderSwapsSwapShipmentsJSONBody

// PostPriceListsPriceListJSONRequestBody defines body for PostPriceListsPriceList for application/json ContentType.
type PostPriceListsPriceListJSONRequestBody PostPriceListsPriceListJSONBody

// PostPriceListsPriceListPriceListJSONRequestBody defines body for PostPriceListsPriceListPriceList for application/json ContentType.
type PostPriceListsPriceListPriceListJSONRequestBody PostPriceListsPriceListPriceListJSONBody

// DeletePriceListsPriceListPricesBatchJSONRequestBody defines body for DeletePriceListsPriceListPricesBatch for application/json ContentType.
type DeletePriceListsPriceListPricesBatchJSONRequestBody DeletePriceListsPriceListPricesBatchJSONBody

// PostPriceListsPriceListPricesBatchJSONRequestBody defines body for PostPriceListsPriceListPricesBatch for application/json ContentType.
type PostPriceListsPriceListPricesBatchJSONRequestBody PostPriceListsPriceListPricesBatchJSONBody

// PostProductsJSONRequestBody defines body for PostProducts for application/json ContentType.
type PostProductsJSONRequestBody PostProductsJSONBody

// PostProductsProductJSONRequestBody defines body for PostProductsProduct for application/json ContentType.
type PostProductsProductJSONRequestBody PostProductsProductJSONBody

// PostProductsProductMetadataJSONRequestBody defines body for PostProductsProductMetadata for application/json ContentType.
type PostProductsProductMetadataJSONRequestBody PostProductsProductMetadataJSONBody

// PostProductsProductOptionsJSONRequestBody defines body for PostProductsProductOptions for application/json ContentType.
type PostProductsProductOptionsJSONRequestBody PostProductsProductOptionsJSONBody

// PostProductsProductOptionsOptionJSONRequestBody defines body for PostProductsProductOptionsOption for application/json ContentType.
type PostProductsProductOptionsOptionJSONRequestBody PostProductsProductOptionsOptionJSONBody

// PostProductsProductVariantsJSONRequestBody defines body for PostProductsProductVariants for application/json ContentType.
type PostProductsProductVariantsJSONRequestBody PostProductsProductVariantsJSONBody

// PostProductsProductVariantsVariantJSONRequestBody defines body for PostProductsProductVariantsVariant for application/json ContentType.
type PostProductsProductVariantsVariantJSONRequestBody PostProductsProductVariantsVariantJSONBody

// PostRegionsJSONRequestBody defines body for PostRegions for application/json ContentType.
type PostRegionsJSONRequestBody PostRegionsJSONBody

// PostRegionsRegionJSONRequestBody defines body for PostRegionsRegion for application/json ContentType.
type PostRegionsRegionJSONRequestBody PostRegionsRegionJSONBody

// PostRegionsRegionCountriesJSONRequestBody defines body for PostRegionsRegionCountries for application/json ContentType.
type PostRegionsRegionCountriesJSONRequestBody PostRegionsRegionCountriesJSONBody

// PostRegionsRegionFulfillmentProvidersJSONRequestBody defines body for PostRegionsRegionFulfillmentProviders for application/json ContentType.
type PostRegionsRegionFulfillmentProvidersJSONRequestBody PostRegionsRegionFulfillmentProvidersJSONBody

// PostRegionsRegionPaymentProvidersJSONRequestBody defines body for PostRegionsRegionPaymentProviders for application/json ContentType.
type PostRegionsRegionPaymentProvidersJSONRequestBody PostRegionsRegionPaymentProvidersJSONBody

// PostReturnReasonsJSONRequestBody defines body for PostReturnReasons for application/json ContentType.
type PostReturnReasonsJSONRequestBody PostReturnReasonsJSONBody

// PostReturnReasonsReasonJSONRequestBody defines body for PostReturnReasonsReason for application/json ContentType.
type PostReturnReasonsReasonJSONRequestBody PostReturnReasonsReasonJSONBody

// PostReturnsReturnReceiveJSONRequestBody defines body for PostReturnsReturnReceive for application/json ContentType.
type PostReturnsReturnReceiveJSONRequestBody PostReturnsReturnReceiveJSONBody

// PostSalesChannelsJSONRequestBody defines body for PostSalesChannels for application/json ContentType.
type PostSalesChannelsJSONRequestBody PostSalesChannelsJSONBody

// PostSalesChannelsSalesChannelJSONRequestBody defines body for PostSalesChannelsSalesChannel for application/json ContentType.
type PostSalesChannelsSalesChannelJSONRequestBody PostSalesChannelsSalesChannelJSONBody

// DeleteSalesChannelsChannelProductsBatchJSONRequestBody defines body for DeleteSalesChannelsChannelProductsBatch for application/json ContentType.
type DeleteSalesChannelsChannelProductsBatchJSONRequestBody DeleteSalesChannelsChannelProductsBatchJSONBody

// PostSalesChannelsChannelProductsBatchJSONRequestBody defines body for PostSalesChannelsChannelProductsBatch for application/json ContentType.
type PostSalesChannelsChannelProductsBatchJSONRequestBody PostSalesChannelsChannelProductsBatchJSONBody

// PostShippingOptionsJSONRequestBody defines body for PostShippingOptions for application/json ContentType.
type PostShippingOptionsJSONRequestBody PostShippingOptionsJSONBody

// PostShippingOptionsOptionJSONRequestBody defines body for PostShippingOptionsOption for application/json ContentType.
type PostShippingOptionsOptionJSONRequestBody PostShippingOptionsOptionJSONBody

// PostShippingProfilesJSONRequestBody defines body for PostShippingProfiles for application/json ContentType.
type PostShippingProfilesJSONRequestBody PostShippingProfilesJSONBody

// PostShippingProfilesProfileJSONRequestBody defines body for PostShippingProfilesProfile for application/json ContentType.
type PostShippingProfilesProfileJSONRequestBody PostShippingProfilesProfileJSONBody

// PostStoreJSONRequestBody defines body for PostStore for application/json ContentType.
type PostStoreJSONRequestBody PostStoreJSONBody

// PostTaxRatesJSONRequestBody defines body for PostTaxRates for application/json ContentType.
type PostTaxRatesJSONRequestBody PostTaxRatesJSONBody

// PostTaxRatesTaxRateJSONRequestBody defines body for PostTaxRatesTaxRate for application/json ContentType.
type PostTaxRatesTaxRateJSONRequestBody PostTaxRatesTaxRateJSONBody

// DeleteTaxRatesTaxRateProductTypesJSONRequestBody defines body for DeleteTaxRatesTaxRateProductTypes for application/json ContentType.
type DeleteTaxRatesTaxRateProductTypesJSONRequestBody DeleteTaxRatesTaxRateProductTypesJSONBody

// PostTaxRatesTaxRateProductTypesJSONRequestBody defines body for PostTaxRatesTaxRateProductTypes for application/json ContentType.
type PostTaxRatesTaxRateProductTypesJSONRequestBody PostTaxRatesTaxRateProductTypesJSONBody

// DeleteTaxRatesTaxRateProductsJSONRequestBody defines body for DeleteTaxRatesTaxRateProducts for application/json ContentType.
type DeleteTaxRatesTaxRateProductsJSONRequestBody DeleteTaxRatesTaxRateProductsJSONBody

// PostTaxRatesTaxRateProductsJSONRequestBody defines body for PostTaxRatesTaxRateProducts for application/json ContentType.
type PostTaxRatesTaxRateProductsJSONRequestBody PostTaxRatesTaxRateProductsJSONBody

// DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody defines body for DeleteTaxRatesTaxRateShippingOptions for application/json ContentType.
type DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody DeleteTaxRatesTaxRateShippingOptionsJSONBody

// PostTaxRatesTaxRateShippingOptionsJSONRequestBody defines body for PostTaxRatesTaxRateShippingOptions for application/json ContentType.
type PostTaxRatesTaxRateShippingOptionsJSONRequestBody PostTaxRatesTaxRateShippingOptionsJSONBody

// PostUsersJSONRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody PostUsersJSONBody

// PostUsersUserPasswordTokenJSONRequestBody defines body for PostUsersUserPasswordToken for application/json ContentType.
type PostUsersUserPasswordTokenJSONRequestBody PostUsersUserPasswordTokenJSONBody

// PostUsersUserPasswordJSONRequestBody defines body for PostUsersUserPassword for application/json ContentType.
type PostUsersUserPasswordJSONRequestBody PostUsersUserPasswordJSONBody

// PostUsersUserJSONRequestBody defines body for PostUsersUser for application/json ContentType.
type PostUsersUserJSONRequestBody PostUsersUserJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Update a Draft Order
	// (POST /admin/draft-orders/{id})
	PostDraftOrdersDraftOrder(ctx echo.Context, id string) error
	// List Applications
	// (GET /apps)
	GetApps(ctx echo.Context) error
	// Generate Token for App
	// (POST /apps/authorizations)
	PostApps(ctx echo.Context) error
	// User Logout
	// (DELETE /auth)
	DeleteAuth(ctx echo.Context) error
	// Get Current User
	// (GET /auth)
	GetAuth(ctx echo.Context) error
	// User Login
	// (POST /auth)
	PostAuth(ctx echo.Context) error
	// List Batch Jobs
	// (GET /batch-jobs)
	GetBatchJobs(ctx echo.Context, params GetBatchJobsParams) error
	// Create a Batch Job
	// (POST /batch-jobs)
	PostBatchJobs(ctx echo.Context) error
	// Get a Batch Job
	// (GET /batch-jobs/{id})
	GetBatchJobsBatchJob(ctx echo.Context, id string) error
	// Cancel a Batch Job
	// (POST /batch-jobs/{id}/cancel)
	PostBatchJobsBatchJobCancel(ctx echo.Context, id string) error
	// Confirm a Batch Job
	// (POST /batch-jobs/{id}/confirm)
	PostBatchJobsBatchJobConfirmProcessing(ctx echo.Context, id string) error
	// List Collections
	// (GET /collections)
	GetCollections(ctx echo.Context, params GetCollectionsParams) error
	// Create a Collection
	// (POST /collections)
	PostCollections(ctx echo.Context) error
	// Delete a Collection
	// (DELETE /collections/{id})
	DeleteCollectionsCollection(ctx echo.Context, id string) error
	// Get a Collection
	// (GET /collections/{id})
	GetCollectionsCollection(ctx echo.Context, id string) error
	// Update a Collection
	// (POST /collections/{id})
	PostCollectionsCollection(ctx echo.Context, id string) error
	// Remove Product
	// (DELETE /collections/{id}/products/batch)
	DeleteProductsFromCollection(ctx echo.Context, id string) error
	// Update Products
	// (POST /collections/{id}/products/batch)
	PostProductsToCollection(ctx echo.Context, id string) error
	// List Currency
	// (GET /currencies)
	GetCurrencies(ctx echo.Context, params GetCurrenciesParams) error
	// Update a Currency
	// (POST /currencies/{code})
	PostCurrenciesCurrency(ctx echo.Context, code string) error
	// List Customer Groups
	// (GET /customer-groups)
	GetCustomerGroups(ctx echo.Context, params GetCustomerGroupsParams) error
	// Create a Customer Group
	// (POST /customer-groups)
	PostCustomerGroups(ctx echo.Context) error
	// Delete a Customer Group
	// (DELETE /customer-groups/{id})
	DeleteCustomerGroupsCustomerGroup(ctx echo.Context, id string) error
	// Get a Customer Group
	// (GET /customer-groups/{id})
	GetCustomerGroupsGroup(ctx echo.Context, id string, params GetCustomerGroupsGroupParams) error
	// Update a Customer Group
	// (POST /customer-groups/{id})
	PostCustomerGroupsGroup(ctx echo.Context, id string) error
	// List Customers
	// (GET /customer-groups/{id}/customers)
	GetCustomerGroupsGroupCustomers(ctx echo.Context, id string) error
	// Remove Customers
	// (DELETE /customer-groups/{id}/customers/batch)
	DeleteCustomerGroupsGroupCustomerBatch(ctx echo.Context, id string) error
	// Add Customers
	// (POST /customer-groups/{id}/customers/batch)
	PostCustomerGroupsGroupCustomersBatch(ctx echo.Context, id string) error
	// List Customers
	// (GET /customers)
	GetCustomers(ctx echo.Context, params GetCustomersParams) error
	// Create a Customer
	// (POST /customers)
	PostCustomers(ctx echo.Context) error
	// Get a Customer
	// (GET /customers/{id})
	GetCustomersCustomer(ctx echo.Context, id string, params GetCustomersCustomerParams) error
	// Update a Customer
	// (POST /customers/{id})
	PostCustomersCustomer(ctx echo.Context, id string, params PostCustomersCustomerParams) error
	// List Discounts
	// (GET /discounts)
	GetDiscounts(ctx echo.Context, params GetDiscountsParams) error
	// Creates a Discount
	// (POST /discounts)
	PostDiscounts(ctx echo.Context, params PostDiscountsParams) error
	// Get Discount by Code
	// (GET /discounts/code/{code})
	GetDiscountsDiscountCode(ctx echo.Context, code string, params GetDiscountsDiscountCodeParams) error
	// Create a Condition
	// (POST /discounts/{discount_id}/conditions)
	PostDiscountsDiscountConditions(ctx echo.Context, discountId string, params PostDiscountsDiscountConditionsParams) error
	// Delete a Condition
	// (DELETE /discounts/{discount_id}/conditions/{condition_id})
	DeleteDiscountsDiscountConditionsCondition(ctx echo.Context, discountId string, conditionId string, params DeleteDiscountsDiscountConditionsConditionParams) error
	// Get a Condition
	// (GET /discounts/{discount_id}/conditions/{condition_id})
	GetDiscountsDiscountConditionsCondition(ctx echo.Context, discountId string, conditionId string, params GetDiscountsDiscountConditionsConditionParams) error
	// Update a Condition
	// (POST /discounts/{discount_id}/conditions/{condition_id})
	PostDiscountsDiscountConditionsCondition(ctx echo.Context, discountId string, conditionId string, params PostDiscountsDiscountConditionsConditionParams) error
	// Delete a Discount
	// (DELETE /discounts/{id})
	DeleteDiscountsDiscount(ctx echo.Context, id string) error
	// Get a Discount
	// (GET /discounts/{id})
	GetDiscountsDiscount(ctx echo.Context, id string, params GetDiscountsDiscountParams) error
	// Update a Discount
	// (POST /discounts/{id})
	PostDiscountsDiscount(ctx echo.Context, id string, params PostDiscountsDiscountParams) error
	// Create a Dynamic Code
	// (POST /discounts/{id}/dynamic-codes)
	PostDiscountsDiscountDynamicCodes(ctx echo.Context, id string) error
	// Delete a Dynamic Code
	// (DELETE /discounts/{id}/dynamic-codes/{code})
	DeleteDiscountsDiscountDynamicCodesCode(ctx echo.Context, id string, code string) error
	// Remove Region
	// (DELETE /discounts/{id}/regions/{region_id})
	DeleteDiscountsDiscountRegionsRegion(ctx echo.Context, id string, regionId string) error
	// Add Region
	// (POST /discounts/{id}/regions/{region_id})
	PostDiscountsDiscountRegionsRegion(ctx echo.Context, id string, regionId string) error
	// List Draft Orders
	// (GET /draft-orders)
	GetDraftOrders(ctx echo.Context, params GetDraftOrdersParams) error
	// Create a Draft Order
	// (POST /draft-orders)
	PostDraftOrders(ctx echo.Context) error
	// Delete a Draft Order
	// (DELETE /draft-orders/{id})
	DeleteDraftOrdersDraftOrder(ctx echo.Context, id string) error
	// Get a Draft Order
	// (GET /draft-orders/{id})
	GetDraftOrdersDraftOrder(ctx echo.Context, id string) error
	// Create a Line Item
	// (POST /draft-orders/{id}/line-items)
	PostDraftOrdersDraftOrderLineItems(ctx echo.Context, id string) error
	// Delete a Line Item
	// (DELETE /draft-orders/{id}/line-items/{line_id})
	DeleteDraftOrdersDraftOrderLineItemsItem(ctx echo.Context, id string, lineId string) error
	// Update a Line Item
	// (POST /draft-orders/{id}/line-items/{line_id})
	PostDraftOrdersDraftOrderLineItemsItem(ctx echo.Context, id string, lineId string) error
	// Registers a Payment
	// (POST /draft-orders/{id}/pay)
	PostDraftOrdersDraftOrderRegisterPayment(ctx echo.Context, id string) error
	// List Gift Cards
	// (GET /gift-cards)
	GetGiftCards(ctx echo.Context, params GetGiftCardsParams) error
	// Create a Gift Card
	// (POST /gift-cards)
	PostGiftCards(ctx echo.Context) error
	// Delete a Gift Card
	// (DELETE /gift-cards/{id})
	DeleteGiftCardsGiftCard(ctx echo.Context, id string) error
	// Get a Gift Card
	// (GET /gift-cards/{id})
	GetGiftCardsGiftCard(ctx echo.Context, id string) error
	// Update a Gift Card
	// (POST /gift-cards/{id})
	PostGiftCardsGiftCard(ctx echo.Context, id string) error
	// Lists Invites
	// (GET /invites)
	GetInvites(ctx echo.Context) error
	// Create an Invite
	// (POST /invites)
	PostInvites(ctx echo.Context) error
	// Accept an Invite
	// (POST /invites/accept)
	PostInvitesInviteAccept(ctx echo.Context) error
	// Create an Invite
	// (DELETE /invites/{invite_id})
	DeleteInvitesInvite(ctx echo.Context, inviteId string) error
	// Resend an Invite
	// (POST /invites/{invite_id}/resend)
	PostInvitesInviteResend(ctx echo.Context, inviteId string) error
	// List Notes
	// (GET /notes)
	GetNotes(ctx echo.Context, params GetNotesParams) error
	// Creates a Note
	// (POST /notes)
	PostNotes(ctx echo.Context) error
	// Delete a Note
	// (DELETE /notes/{id})
	DeleteNotesNote(ctx echo.Context, id string) error
	// Get a Note
	// (GET /notes/{id})
	GetNotesNote(ctx echo.Context, id string) error
	// Update a Note
	// (POST /notes/{id})
	PostNotesNote(ctx echo.Context, id string) error
	// List Notifications
	// (GET /notifications)
	GetNotifications(ctx echo.Context, params GetNotificationsParams) error
	// Resend Notification
	// (POST /notifications/{id}/resend)
	PostNotificationsNotificationResend(ctx echo.Context, id string) error
	// Create a Claim
	// (POST /order/{id}/claims)
	PostOrdersOrderClaims(ctx echo.Context, id string) error
	// Update a Claim
	// (POST /order/{id}/claims/{claim_id})
	PostOrdersOrderClaimsClaim(ctx echo.Context, id string, claimId string) error
	// Create a Swap
	// (POST /order/{id}/swaps)
	PostOrdersOrderSwaps(ctx echo.Context, id string) error
	// List Orders
	// (GET /orders)
	GetOrders(ctx echo.Context, params GetOrdersParams) error
	// Get an Order
	// (GET /orders/{id})
	GetOrdersOrder(ctx echo.Context, id string) error
	// Update an Order
	// (POST /orders/{id})
	PostOrdersOrder(ctx echo.Context, id string) error
	// Archive Order
	// (POST /orders/{id}/archive)
	PostOrdersOrderArchive(ctx echo.Context, id string) error
	// Cancel an Order
	// (POST /orders/{id}/cancel)
	PostOrdersOrderCancel(ctx echo.Context, id string) error
	// Capture Order's Payment
	// (POST /orders/{id}/capture)
	PostOrdersOrderCapture(ctx echo.Context, id string) error
	// Cancel a Claim
	// (POST /orders/{id}/claims/{claim_id}/cancel)
	PostOrdersClaimCancel(ctx echo.Context, id string, claimId string) error
	// Create Claim Fulfillment
	// (POST /orders/{id}/claims/{claim_id}/fulfillments)
	PostOrdersOrderClaimsClaimFulfillments(ctx echo.Context, id string, claimId string) error
	// Cancel Claim Fulfillment
	// (POST /orders/{id}/claims/{claim_id}/fulfillments/{fulfillment_id}/cancel)
	PostOrdersClaimFulfillmentsCancel(ctx echo.Context, id string, claimId string, fulfillmentId string) error
	// Create Claim Shipment
	// (POST /orders/{id}/claims/{claim_id}/shipments)
	PostOrdersOrderClaimsClaimShipments(ctx echo.Context, id string, claimId string) error
	// Complete an Order
	// (POST /orders/{id}/complete)
	PostOrdersOrderComplete(ctx echo.Context, id string) error
	// Create a Fulfillment
	// (POST /orders/{id}/fulfillment)
	PostOrdersOrderFulfillments(ctx echo.Context, id string) error
	// Cancels a Fulfilmment
	// (POST /orders/{id}/fulfillments/{fulfillment_id}/cancel)
	PostOrdersOrderFulfillmentsCancel(ctx echo.Context, id string, fulfillmentId string) error
	// Create a Refund
	// (POST /orders/{id}/refund)
	PostOrdersOrderRefunds(ctx echo.Context, id string) error
	// Request a Return
	// (POST /orders/{id}/return)
	PostOrdersOrderReturns(ctx echo.Context, id string) error
	// Create a Shipment
	// (POST /orders/{id}/shipment)
	PostOrdersOrderShipment(ctx echo.Context, id string) error
	// Add a Shipping Method
	// (POST /orders/{id}/shipping-methods)
	PostOrdersOrderShippingMethods(ctx echo.Context, id string) error
	// Cancels a Swap
	// (POST /orders/{id}/swaps/{swap_id}/cancel)
	PostOrdersSwapCancel(ctx echo.Context, id string, swapId string) error
	// Create Swap Fulfillment
	// (POST /orders/{id}/swaps/{swap_id}/fulfillments)
	PostOrdersOrderSwapsSwapFulfillments(ctx echo.Context, id string, swapId string) error
	// Cancel Swap's Fulfilmment
	// (POST /orders/{id}/swaps/{swap_id}/fulfillments/{fulfillment_id}/cancel)
	PostOrdersSwapFulfillmentsCancel(ctx echo.Context, id string, swapId string, fulfillmentId string) error
	// Process Swap Payment
	// (POST /orders/{id}/swaps/{swap_id}/process-payment)
	PostOrdersOrderSwapsSwapProcessPayment(ctx echo.Context, id string, swapId string) error
	// Create Swap Shipment
	// (POST /orders/{id}/swaps/{swap_id}/shipments)
	PostOrdersOrderSwapsSwapShipments(ctx echo.Context, id string, swapId string) error
	// List Price Lists
	// (GET /price-lists)
	GetPriceLists(ctx echo.Context, params GetPriceListsParams) error
	// Create a Price List
	// (POST /price-lists)
	PostPriceListsPriceList(ctx echo.Context) error
	// Delete a Price List
	// (DELETE /price-lists/{id})
	DeletePriceListsPriceList(ctx echo.Context, id string) error
	// Get a Price List
	// (GET /price-lists/{id})
	GetPriceListsPriceList(ctx echo.Context, id string) error
	// Update a Price List
	// (POST /price-lists/{id})
	PostPriceListsPriceListPriceList(ctx echo.Context, id string) error
	// Delete Prices
	// (DELETE /price-lists/{id}/prices/batch)
	DeletePriceListsPriceListPricesBatch(ctx echo.Context, id string) error
	// Update Prices
	// (POST /price-lists/{id}/prices/batch)
	PostPriceListsPriceListPricesBatch(ctx echo.Context, id string) error
	// List Products
	// (GET /price-lists/{id}/products)
	GetPriceListsPriceListProducts(ctx echo.Context, id string, params GetPriceListsPriceListProductsParams) error
	// Delete Product's Prices
	// (DELETE /price-lists/{id}/products/{product_id}/prices)
	DeletePriceListsPriceListProductsProductPrices(ctx echo.Context, id string, productId string) error
	// Delete Variant's Prices
	// (DELETE /price-lists/{id}/variants/{variant_id}/prices)
	DeletePriceListsPriceListVariantsVariantPrices(ctx echo.Context, id string, variantId string) error
	// List Product Tags
	// (GET /product-tags)
	GetProductTags(ctx echo.Context, params GetProductTagsParams) error
	// List Product Types
	// (GET /product-types)
	GetProductTypes(ctx echo.Context, params GetProductTypesParams) error
	// List Products
	// (GET /products)
	GetProducts(ctx echo.Context, params GetProductsParams) error
	// Create a Product
	// (POST /products)
	PostProducts(ctx echo.Context) error
	// List Tags Usage Number
	// (GET /products/tag-usage)
	GetProductsTagUsage(ctx echo.Context) error
	// List Product Types
	// (GET /products/types)
	GetProductsTypes(ctx echo.Context) error
	// Delete a Product
	// (DELETE /products/{id})
	DeleteProductsProduct(ctx echo.Context, id string) error
	// Get a Product
	// (GET /products/{id})
	GetProductsProduct(ctx echo.Context, id string) error
	// Update a Product
	// (POST /products/{id})
	PostProductsProduct(ctx echo.Context, id string) error
	// Set Product Metadata
	// (POST /products/{id}/metadata)
	PostProductsProductMetadata(ctx echo.Context, id string) error
	// Add an Option
	// (POST /products/{id}/options)
	PostProductsProductOptions(ctx echo.Context, id string) error
	// Delete a Product Option
	// (DELETE /products/{id}/options/{option_id})
	DeleteProductsProductOptionsOption(ctx echo.Context, id string, optionId string) error
	// Update a Product Option
	// (POST /products/{id}/options/{option_id})
	PostProductsProductOptionsOption(ctx echo.Context, id string, optionId string) error
	// List a Product's Variants
	// (GET /products/{id}/variants)
	GetProductsProductVariants(ctx echo.Context, id string, params GetProductsProductVariantsParams) error
	// Create a Product Variant
	// (POST /products/{id}/variants)
	PostProductsProductVariants(ctx echo.Context, id string) error
	// Delete a Product Variant
	// (DELETE /products/{id}/variants/{variant_id})
	DeleteProductsProductVariantsVariant(ctx echo.Context, id string, variantId string) error
	// Update a Product Variant
	// (POST /products/{id}/variants/{variant_id})
	PostProductsProductVariantsVariant(ctx echo.Context, id string, variantId string) error
	// List Regions
	// (GET /regions)
	GetRegions(ctx echo.Context, params GetRegionsParams) error
	// Create a Region
	// (POST /regions)
	PostRegions(ctx echo.Context) error
	// Delete a Region
	// (DELETE /regions/{id})
	DeleteRegionsRegion(ctx echo.Context, id string) error
	// Get a Region
	// (GET /regions/{id})
	GetRegionsRegion(ctx echo.Context, id string) error
	// Update a Region
	// (POST /regions/{id})
	PostRegionsRegion(ctx echo.Context, id string) error
	// Add Country
	// (POST /regions/{id}/countries)
	PostRegionsRegionCountries(ctx echo.Context, id string) error
	// Delete Country
	// (DELETE /regions/{id}/countries/{country_code})
	PostRegionsRegionCountriesCountry(ctx echo.Context, id string, countryCode string) error
	// List Fulfillment Options
	// (GET /regions/{id}/fulfillment-options)
	GetRegionsRegionFulfillmentOptions(ctx echo.Context, id string) error
	// Add Fulfillment Provider
	// (POST /regions/{id}/fulfillment-providers)
	PostRegionsRegionFulfillmentProviders(ctx echo.Context, id string) error
	// Del. Fulfillment Provider
	// (DELETE /regions/{id}/fulfillment-providers/{provider_id})
	PostRegionsRegionFulfillmentProvidersProvider(ctx echo.Context, id string, providerId string) error
	// Add Payment Provider
	// (POST /regions/{id}/payment-providers)
	PostRegionsRegionPaymentProviders(ctx echo.Context, id string) error
	// Delete Payment Provider
	// (DELETE /regions/{id}/payment-providers/{provider_id})
	PostRegionsRegionPaymentProvidersProvider(ctx echo.Context, id string, providerId string) error
	// List Return Reasons
	// (GET /return-reasons)
	GetReturnReasons(ctx echo.Context) error
	// Create a Return Reason
	// (POST /return-reasons)
	PostReturnReasons(ctx echo.Context) error
	// Delete a Return Reason
	// (DELETE /return-reasons/{id})
	DeleteReturnReason(ctx echo.Context, id string) error
	// Get a Return Reason
	// (GET /return-reasons/{id})
	GetReturnReasonsReason(ctx echo.Context, id string) error
	// Update a Return Reason
	// (POST /return-reasons/{id})
	PostReturnReasonsReason(ctx echo.Context, id string) error
	// List Returns
	// (GET /returns)
	GetReturns(ctx echo.Context, params GetReturnsParams) error
	// Cancel a Return
	// (POST /returns/{id}/cancel)
	PostReturnsReturnCancel(ctx echo.Context, id string) error
	// Receive a Return
	// (POST /returns/{id}/receive)
	PostReturnsReturnReceive(ctx echo.Context, id string) error
	// List Sales Channels
	// (GET /sales-channels)
	GetSalesChannels(ctx echo.Context, params GetSalesChannelsParams) error
	// Create a Sales Channel
	// (POST /sales-channels)
	PostSalesChannels(ctx echo.Context) error
	// Delete a Sales Channel
	// (DELETE /sales-channels/{id})
	DeleteSalesChannelsSalesChannel(ctx echo.Context, id string) error
	// Get a Sales Channel
	// (GET /sales-channels/{id})
	GetSalesChannelsSalesChannel(ctx echo.Context, id string) error
	// Update a Sales Channel
	// (POST /sales-channels/{id})
	PostSalesChannelsSalesChannel(ctx echo.Context, id string) error
	// Delete Products
	// (DELETE /sales-channels/{id}/products/batch)
	DeleteSalesChannelsChannelProductsBatch(ctx echo.Context, id string) error
	// Add Products
	// (POST /sales-channels/{id}/products/batch)
	PostSalesChannelsChannelProductsBatch(ctx echo.Context, id string) error
	// List Shipping Options
	// (GET /shipping-options)
	GetShippingOptions(ctx echo.Context, params GetShippingOptionsParams) error
	// Create Shipping Option
	// (POST /shipping-options)
	PostShippingOptions(ctx echo.Context) error
	// Delete a Shipping Option
	// (DELETE /shipping-options/{id})
	DeleteShippingOptionsOption(ctx echo.Context, id string) error
	// Get a Shipping Option
	// (GET /shipping-options/{id})
	GetShippingOptionsOption(ctx echo.Context, id string) error
	// Update Shipping Option
	// (POST /shipping-options/{id})
	PostShippingOptionsOption(ctx echo.Context, id string) error
	// List Shipping Profiles
	// (GET /shipping-profiles)
	GetShippingProfiles(ctx echo.Context) error
	// Create a Shipping Profile
	// (POST /shipping-profiles)
	PostShippingProfiles(ctx echo.Context) error
	// Delete a Shipping Profile
	// (DELETE /shipping-profiles/{id})
	DeleteShippingProfilesProfile(ctx echo.Context, id string) error
	// Get a Shipping Profile
	// (GET /shipping-profiles/{id})
	GetShippingProfilesProfile(ctx echo.Context, id string) error
	// Update a Shipping Profile
	// (POST /shipping-profiles/{id})
	PostShippingProfilesProfile(ctx echo.Context, id string) error
	// Get Store details
	// (GET /store)
	GetStore(ctx echo.Context) error
	// Update Store Details
	// (POST /store)
	PostStore(ctx echo.Context) error
	// Delete a Currency Code
	// (DELETE /store/currencies/{code})
	DeleteStoreCurrenciesCode(ctx echo.Context, code string) error
	// Add a Currency Code
	// (POST /store/currencies/{code})
	PostStoreCurrenciesCode(ctx echo.Context, code string) error
	// List Payment Providers
	// (GET /store/payment-providers)
	GetStorePaymentProviders(ctx echo.Context) error
	// List Tax Providers
	// (GET /store/tax-providers)
	GetStoreTaxProviders(ctx echo.Context) error
	// List Swaps
	// (GET /swaps)
	GetSwaps(ctx echo.Context, params GetSwapsParams) error
	// Get a Swap
	// (GET /swaps/{id})
	GetSwapsSwap(ctx echo.Context, id string) error
	// List Tax Rates
	// (GET /tax-rates)
	GetTaxRates(ctx echo.Context, params GetTaxRatesParams) error
	// Create a Tax Rate
	// (POST /tax-rates)
	PostTaxRates(ctx echo.Context, params PostTaxRatesParams) error
	// Delete a Tax Rate
	// (DELETE /tax-rates/{id})
	DeleteTaxRatesTaxRate(ctx echo.Context, id string) error
	// Get a Tax Rate
	// (GET /tax-rates/{id})
	GetTaxRatesTaxRate(ctx echo.Context, id string, params GetTaxRatesTaxRateParams) error
	// Update a Tax Rate
	// (POST /tax-rates/{id})
	PostTaxRatesTaxRate(ctx echo.Context, id string, params PostTaxRatesTaxRateParams) error
	// Delete from Product Types
	// (DELETE /tax-rates/{id}/product-types/batch)
	DeleteTaxRatesTaxRateProductTypes(ctx echo.Context, id string, params DeleteTaxRatesTaxRateProductTypesParams) error
	// Add to Product Types
	// (POST /tax-rates/{id}/product-types/batch)
	PostTaxRatesTaxRateProductTypes(ctx echo.Context, id string, params PostTaxRatesTaxRateProductTypesParams) error
	// Delete from Products
	// (DELETE /tax-rates/{id}/products/batch)
	DeleteTaxRatesTaxRateProducts(ctx echo.Context, id string, params DeleteTaxRatesTaxRateProductsParams) error
	// Add to Products
	// (POST /tax-rates/{id}/products/batch)
	PostTaxRatesTaxRateProducts(ctx echo.Context, id string, params PostTaxRatesTaxRateProductsParams) error
	// Del. for Shipping Options
	// (DELETE /tax-rates/{id}/shipping-options/batch)
	DeleteTaxRatesTaxRateShippingOptions(ctx echo.Context, id string, params DeleteTaxRatesTaxRateShippingOptionsParams) error
	// Add to Shipping Options
	// (POST /tax-rates/{id}/shipping-options/batch)
	PostTaxRatesTaxRateShippingOptions(ctx echo.Context, id string, params PostTaxRatesTaxRateShippingOptionsParams) error
	// Upload files
	// (POST /uploads)
	PostUploads(ctx echo.Context) error
	// List Users
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// Create a User
	// (POST /users)
	PostUsers(ctx echo.Context) error
	// Request Password Reset
	// (POST /users/password-token)
	PostUsersUserPasswordToken(ctx echo.Context) error
	// Reset Password
	// (POST /users/reset-password)
	PostUsersUserPassword(ctx echo.Context) error
	// Delete a User
	// (DELETE /users/{id})
	DeleteUsersUser(ctx echo.Context, id string) error
	// Get a User
	// (GET /users/{id})
	GetUsersUser(ctx echo.Context, id string) error
	// Update a User
	// (POST /users/{id})
	PostUsersUser(ctx echo.Context, id string) error
	// List Product Variants
	// (GET /variants)
	GetVariants(ctx echo.Context, params GetVariantsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDraftOrdersDraftOrder converts echo context to params.
func (w *ServerInterfaceWrapper) PostDraftOrdersDraftOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDraftOrdersDraftOrder(ctx, id)
	return err
}

// GetApps converts echo context to params.
func (w *ServerInterfaceWrapper) GetApps(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApps(ctx)
	return err
}

// PostApps converts echo context to params.
func (w *ServerInterfaceWrapper) PostApps(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostApps(ctx)
	return err
}

// DeleteAuth converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuth(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteAuth(ctx)
	return err
}

// GetAuth converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuth(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuth(ctx)
	return err
}

// PostAuth converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAuth(ctx)
	return err
}

// GetBatchJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBatchJobs(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBatchJobsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", false, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "confirmed_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "confirmed_at", ctx.QueryParams(), &params.ConfirmedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter confirmed_at: %s", err))
	}

	// ------------- Optional query parameter "pre_processed_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "pre_processed_at", ctx.QueryParams(), &params.PreProcessedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pre_processed_at: %s", err))
	}

	// ------------- Optional query parameter "completed_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "completed_at", ctx.QueryParams(), &params.CompletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter completed_at: %s", err))
	}

	// ------------- Optional query parameter "failed_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "failed_at", ctx.QueryParams(), &params.FailedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter failed_at: %s", err))
	}

	// ------------- Optional query parameter "canceled_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "canceled_at", ctx.QueryParams(), &params.CanceledAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter canceled_at: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", false, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBatchJobs(ctx, params)
	return err
}

// PostBatchJobs converts echo context to params.
func (w *ServerInterfaceWrapper) PostBatchJobs(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBatchJobs(ctx)
	return err
}

// GetBatchJobsBatchJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetBatchJobsBatchJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBatchJobsBatchJob(ctx, id)
	return err
}

// PostBatchJobsBatchJobCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostBatchJobsBatchJobCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBatchJobsBatchJobCancel(ctx, id)
	return err
}

// PostBatchJobsBatchJobConfirmProcessing converts echo context to params.
func (w *ServerInterfaceWrapper) PostBatchJobsBatchJobConfirmProcessing(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBatchJobsBatchJobConfirmProcessing(ctx, id)
	return err
}

// GetCollections converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollections(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "handle" -------------

	err = runtime.BindQueryParameter("form", true, false, "handle", ctx.QueryParams(), &params.Handle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handle: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCollections(ctx, params)
	return err
}

// PostCollections converts echo context to params.
func (w *ServerInterfaceWrapper) PostCollections(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCollections(ctx)
	return err
}

// DeleteCollectionsCollection converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCollectionsCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCollectionsCollection(ctx, id)
	return err
}

// GetCollectionsCollection converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionsCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCollectionsCollection(ctx, id)
	return err
}

// PostCollectionsCollection converts echo context to params.
func (w *ServerInterfaceWrapper) PostCollectionsCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCollectionsCollection(ctx, id)
	return err
}

// DeleteProductsFromCollection converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsFromCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProductsFromCollection(ctx, id)
	return err
}

// PostProductsToCollection converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsToCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsToCollection(ctx, id)
	return err
}

// GetCurrencies converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrencies(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrenciesParams
	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "includes_tax" -------------

	err = runtime.BindQueryParameter("form", true, false, "includes_tax", ctx.QueryParams(), &params.IncludesTax)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includes_tax: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrencies(ctx, params)
	return err
}

// PostCurrenciesCurrency converts echo context to params.
func (w *ServerInterfaceWrapper) PostCurrenciesCurrency(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCurrenciesCurrency(ctx, code)
	return err
}

// GetCustomerGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomerGroups(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerGroupsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomerGroups(ctx, params)
	return err
}

// PostCustomerGroups converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomerGroups(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomerGroups(ctx)
	return err
}

// DeleteCustomerGroupsCustomerGroup converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCustomerGroupsCustomerGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCustomerGroupsCustomerGroup(ctx, id)
	return err
}

// GetCustomerGroupsGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomerGroupsGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerGroupsGroupParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomerGroupsGroup(ctx, id, params)
	return err
}

// PostCustomerGroupsGroup converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomerGroupsGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomerGroupsGroup(ctx, id)
	return err
}

// GetCustomerGroupsGroupCustomers converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomerGroupsGroupCustomers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomerGroupsGroupCustomers(ctx, id)
	return err
}

// DeleteCustomerGroupsGroupCustomerBatch converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCustomerGroupsGroupCustomerBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCustomerGroupsGroupCustomerBatch(ctx, id)
	return err
}

// PostCustomerGroupsGroupCustomersBatch converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomerGroupsGroupCustomersBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomerGroupsGroupCustomersBatch(ctx, id)
	return err
}

// GetCustomers converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomers(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomers(ctx, params)
	return err
}

// PostCustomers converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomers(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomers(ctx)
	return err
}

// GetCustomersCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomersCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomersCustomerParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomersCustomer(ctx, id, params)
	return err
}

// PostCustomersCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomersCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCustomersCustomerParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomersCustomer(ctx, id, params)
	return err
}

// GetDiscounts converts echo context to params.
func (w *ServerInterfaceWrapper) GetDiscounts(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDiscountsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "rule" -------------

	err = runtime.BindQueryParameter("form", true, false, "rule", ctx.QueryParams(), &params.Rule)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rule: %s", err))
	}

	// ------------- Optional query parameter "is_dynamic" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_dynamic", ctx.QueryParams(), &params.IsDynamic)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_dynamic: %s", err))
	}

	// ------------- Optional query parameter "is_disabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_disabled", ctx.QueryParams(), &params.IsDisabled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_disabled: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDiscounts(ctx, params)
	return err
}

// PostDiscounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscounts(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDiscountsParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscounts(ctx, params)
	return err
}

// GetDiscountsDiscountCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetDiscountsDiscountCode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDiscountsDiscountCodeParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDiscountsDiscountCode(ctx, code, params)
	return err
}

// PostDiscountsDiscountConditions converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscountsDiscountConditions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "discount_id" -------------
	var discountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, ctx.Param("discount_id"), &discountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter discount_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDiscountsDiscountConditionsParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscountsDiscountConditions(ctx, discountId, params)
	return err
}

// DeleteDiscountsDiscountConditionsCondition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDiscountsDiscountConditionsCondition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "discount_id" -------------
	var discountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, ctx.Param("discount_id"), &discountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter discount_id: %s", err))
	}

	// ------------- Path parameter "condition_id" -------------
	var conditionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, ctx.Param("condition_id"), &conditionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter condition_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDiscountsDiscountConditionsConditionParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params)
	return err
}

// GetDiscountsDiscountConditionsCondition converts echo context to params.
func (w *ServerInterfaceWrapper) GetDiscountsDiscountConditionsCondition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "discount_id" -------------
	var discountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, ctx.Param("discount_id"), &discountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter discount_id: %s", err))
	}

	// ------------- Path parameter "condition_id" -------------
	var conditionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, ctx.Param("condition_id"), &conditionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter condition_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDiscountsDiscountConditionsConditionParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params)
	return err
}

// PostDiscountsDiscountConditionsCondition converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscountsDiscountConditionsCondition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "discount_id" -------------
	var discountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, ctx.Param("discount_id"), &discountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter discount_id: %s", err))
	}

	// ------------- Path parameter "condition_id" -------------
	var conditionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, ctx.Param("condition_id"), &conditionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter condition_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDiscountsDiscountConditionsConditionParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params)
	return err
}

// DeleteDiscountsDiscount converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDiscountsDiscount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDiscountsDiscount(ctx, id)
	return err
}

// GetDiscountsDiscount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDiscountsDiscount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDiscountsDiscountParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDiscountsDiscount(ctx, id, params)
	return err
}

// PostDiscountsDiscount converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscountsDiscount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDiscountsDiscountParams
	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscountsDiscount(ctx, id, params)
	return err
}

// PostDiscountsDiscountDynamicCodes converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscountsDiscountDynamicCodes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscountsDiscountDynamicCodes(ctx, id)
	return err
}

// DeleteDiscountsDiscountDynamicCodesCode converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDiscountsDiscountDynamicCodesCode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDiscountsDiscountDynamicCodesCode(ctx, id, code)
	return err
}

// DeleteDiscountsDiscountRegionsRegion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDiscountsDiscountRegionsRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "region_id" -------------
	var regionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "region_id", runtime.ParamLocationPath, ctx.Param("region_id"), &regionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDiscountsDiscountRegionsRegion(ctx, id, regionId)
	return err
}

// PostDiscountsDiscountRegionsRegion converts echo context to params.
func (w *ServerInterfaceWrapper) PostDiscountsDiscountRegionsRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "region_id" -------------
	var regionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "region_id", runtime.ParamLocationPath, ctx.Param("region_id"), &regionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDiscountsDiscountRegionsRegion(ctx, id, regionId)
	return err
}

// GetDraftOrders converts echo context to params.
func (w *ServerInterfaceWrapper) GetDraftOrders(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDraftOrdersParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDraftOrders(ctx, params)
	return err
}

// PostDraftOrders converts echo context to params.
func (w *ServerInterfaceWrapper) PostDraftOrders(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDraftOrders(ctx)
	return err
}

// DeleteDraftOrdersDraftOrder converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDraftOrdersDraftOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDraftOrdersDraftOrder(ctx, id)
	return err
}

// GetDraftOrdersDraftOrder converts echo context to params.
func (w *ServerInterfaceWrapper) GetDraftOrdersDraftOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDraftOrdersDraftOrder(ctx, id)
	return err
}

// PostDraftOrdersDraftOrderLineItems converts echo context to params.
func (w *ServerInterfaceWrapper) PostDraftOrdersDraftOrderLineItems(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDraftOrdersDraftOrderLineItems(ctx, id)
	return err
}

// DeleteDraftOrdersDraftOrderLineItemsItem converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDraftOrdersDraftOrderLineItemsItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "line_id" -------------
	var lineId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "line_id", runtime.ParamLocationPath, ctx.Param("line_id"), &lineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter line_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteDraftOrdersDraftOrderLineItemsItem(ctx, id, lineId)
	return err
}

// PostDraftOrdersDraftOrderLineItemsItem converts echo context to params.
func (w *ServerInterfaceWrapper) PostDraftOrdersDraftOrderLineItemsItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "line_id" -------------
	var lineId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "line_id", runtime.ParamLocationPath, ctx.Param("line_id"), &lineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter line_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDraftOrdersDraftOrderLineItemsItem(ctx, id, lineId)
	return err
}

// PostDraftOrdersDraftOrderRegisterPayment converts echo context to params.
func (w *ServerInterfaceWrapper) PostDraftOrdersDraftOrderRegisterPayment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostDraftOrdersDraftOrderRegisterPayment(ctx, id)
	return err
}

// GetGiftCards converts echo context to params.
func (w *ServerInterfaceWrapper) GetGiftCards(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGiftCardsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGiftCards(ctx, params)
	return err
}

// PostGiftCards converts echo context to params.
func (w *ServerInterfaceWrapper) PostGiftCards(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGiftCards(ctx)
	return err
}

// DeleteGiftCardsGiftCard converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGiftCardsGiftCard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGiftCardsGiftCard(ctx, id)
	return err
}

// GetGiftCardsGiftCard converts echo context to params.
func (w *ServerInterfaceWrapper) GetGiftCardsGiftCard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGiftCardsGiftCard(ctx, id)
	return err
}

// PostGiftCardsGiftCard converts echo context to params.
func (w *ServerInterfaceWrapper) PostGiftCardsGiftCard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGiftCardsGiftCard(ctx, id)
	return err
}

// GetInvites converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvites(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInvites(ctx)
	return err
}

// PostInvites converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvites(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInvites(ctx)
	return err
}

// PostInvitesInviteAccept converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvitesInviteAccept(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInvitesInviteAccept(ctx)
	return err
}

// DeleteInvitesInvite converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvitesInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "invite_id" -------------
	var inviteId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, ctx.Param("invite_id"), &inviteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invite_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteInvitesInvite(ctx, inviteId)
	return err
}

// PostInvitesInviteResend converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvitesInviteResend(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "invite_id" -------------
	var inviteId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, ctx.Param("invite_id"), &inviteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invite_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInvitesInviteResend(ctx, inviteId)
	return err
}

// GetNotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotes(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNotesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "resource_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource_id", ctx.QueryParams(), &params.ResourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNotes(ctx, params)
	return err
}

// PostNotes converts echo context to params.
func (w *ServerInterfaceWrapper) PostNotes(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostNotes(ctx)
	return err
}

// DeleteNotesNote converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNotesNote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteNotesNote(ctx, id)
	return err
}

// GetNotesNote converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotesNote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNotesNote(ctx, id)
	return err
}

// PostNotesNote converts echo context to params.
func (w *ServerInterfaceWrapper) PostNotesNote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostNotesNote(ctx, id)
	return err
}

// GetNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNotificationsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "event_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_name", ctx.QueryParams(), &params.EventName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_name: %s", err))
	}

	// ------------- Optional query parameter "resource_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource_type", ctx.QueryParams(), &params.ResourceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource_type: %s", err))
	}

	// ------------- Optional query parameter "resource_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource_id", ctx.QueryParams(), &params.ResourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource_id: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "include_resends" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_resends", ctx.QueryParams(), &params.IncludeResends)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_resends: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNotifications(ctx, params)
	return err
}

// PostNotificationsNotificationResend converts echo context to params.
func (w *ServerInterfaceWrapper) PostNotificationsNotificationResend(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostNotificationsNotificationResend(ctx, id)
	return err
}

// PostOrdersOrderClaims converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderClaims(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderClaims(ctx, id)
	return err
}

// PostOrdersOrderClaimsClaim converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderClaimsClaim(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claim_id" -------------
	var claimId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, ctx.Param("claim_id"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claim_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderClaimsClaim(ctx, id, claimId)
	return err
}

// PostOrdersOrderSwaps converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderSwaps(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderSwaps(ctx, id)
	return err
}

// GetOrders converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrders(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrdersParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "fulfillment_status" -------------

	err = runtime.BindQueryParameter("form", false, false, "fulfillment_status", ctx.QueryParams(), &params.FulfillmentStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_status: %s", err))
	}

	// ------------- Optional query parameter "payment_status" -------------

	err = runtime.BindQueryParameter("form", false, false, "payment_status", ctx.QueryParams(), &params.PaymentStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_status: %s", err))
	}

	// ------------- Optional query parameter "display_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "display_id", ctx.QueryParams(), &params.DisplayId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter display_id: %s", err))
	}

	// ------------- Optional query parameter "cart_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "cart_id", ctx.QueryParams(), &params.CartId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cart_id: %s", err))
	}

	// ------------- Optional query parameter "customer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "customer_id", ctx.QueryParams(), &params.CustomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_id: %s", err))
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// ------------- Optional query parameter "region_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "region_id", ctx.QueryParams(), &params.RegionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
	}

	// ------------- Optional query parameter "currency_code" -------------

	err = runtime.BindQueryParameter("form", false, false, "currency_code", ctx.QueryParams(), &params.CurrencyCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency_code: %s", err))
	}

	// ------------- Optional query parameter "tax_rate" -------------

	err = runtime.BindQueryParameter("form", true, false, "tax_rate", ctx.QueryParams(), &params.TaxRate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tax_rate: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "canceled_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "canceled_at", ctx.QueryParams(), &params.CanceledAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter canceled_at: %s", err))
	}

	// ------------- Optional query parameter "sales_channel_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "sales_channel_id", ctx.QueryParams(), &params.SalesChannelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sales_channel_id: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrders(ctx, params)
	return err
}

// GetOrdersOrder converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrdersOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrdersOrder(ctx, id)
	return err
}

// PostOrdersOrder converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrder(ctx, id)
	return err
}

// PostOrdersOrderArchive converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderArchive(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderArchive(ctx, id)
	return err
}

// PostOrdersOrderCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderCancel(ctx, id)
	return err
}

// PostOrdersOrderCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderCapture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderCapture(ctx, id)
	return err
}

// PostOrdersClaimCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersClaimCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claim_id" -------------
	var claimId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, ctx.Param("claim_id"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claim_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersClaimCancel(ctx, id, claimId)
	return err
}

// PostOrdersOrderClaimsClaimFulfillments converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderClaimsClaimFulfillments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claim_id" -------------
	var claimId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, ctx.Param("claim_id"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claim_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderClaimsClaimFulfillments(ctx, id, claimId)
	return err
}

// PostOrdersClaimFulfillmentsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersClaimFulfillmentsCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claim_id" -------------
	var claimId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, ctx.Param("claim_id"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claim_id: %s", err))
	}

	// ------------- Path parameter "fulfillment_id" -------------
	var fulfillmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, ctx.Param("fulfillment_id"), &fulfillmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersClaimFulfillmentsCancel(ctx, id, claimId, fulfillmentId)
	return err
}

// PostOrdersOrderClaimsClaimShipments converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderClaimsClaimShipments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claim_id" -------------
	var claimId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, ctx.Param("claim_id"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claim_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderClaimsClaimShipments(ctx, id, claimId)
	return err
}

// PostOrdersOrderComplete converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderComplete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderComplete(ctx, id)
	return err
}

// PostOrdersOrderFulfillments converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderFulfillments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderFulfillments(ctx, id)
	return err
}

// PostOrdersOrderFulfillmentsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderFulfillmentsCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "fulfillment_id" -------------
	var fulfillmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, ctx.Param("fulfillment_id"), &fulfillmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderFulfillmentsCancel(ctx, id, fulfillmentId)
	return err
}

// PostOrdersOrderRefunds converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderRefunds(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderRefunds(ctx, id)
	return err
}

// PostOrdersOrderReturns converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderReturns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderReturns(ctx, id)
	return err
}

// PostOrdersOrderShipment converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderShipment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderShipment(ctx, id)
	return err
}

// PostOrdersOrderShippingMethods converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderShippingMethods(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderShippingMethods(ctx, id)
	return err
}

// PostOrdersSwapCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersSwapCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "swap_id" -------------
	var swapId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, ctx.Param("swap_id"), &swapId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter swap_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersSwapCancel(ctx, id, swapId)
	return err
}

// PostOrdersOrderSwapsSwapFulfillments converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderSwapsSwapFulfillments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "swap_id" -------------
	var swapId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, ctx.Param("swap_id"), &swapId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter swap_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderSwapsSwapFulfillments(ctx, id, swapId)
	return err
}

// PostOrdersSwapFulfillmentsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersSwapFulfillmentsCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "swap_id" -------------
	var swapId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, ctx.Param("swap_id"), &swapId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter swap_id: %s", err))
	}

	// ------------- Path parameter "fulfillment_id" -------------
	var fulfillmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, ctx.Param("fulfillment_id"), &fulfillmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersSwapFulfillmentsCancel(ctx, id, swapId, fulfillmentId)
	return err
}

// PostOrdersOrderSwapsSwapProcessPayment converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderSwapsSwapProcessPayment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "swap_id" -------------
	var swapId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, ctx.Param("swap_id"), &swapId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter swap_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderSwapsSwapProcessPayment(ctx, id, swapId)
	return err
}

// PostOrdersOrderSwapsSwapShipments converts echo context to params.
func (w *ServerInterfaceWrapper) PostOrdersOrderSwapsSwapShipments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "swap_id" -------------
	var swapId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, ctx.Param("swap_id"), &swapId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter swap_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOrdersOrderSwapsSwapShipments(ctx, id, swapId)
	return err
}

// GetPriceLists converts echo context to params.
func (w *ServerInterfaceWrapper) GetPriceLists(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPriceListsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "customer_groups" -------------

	err = runtime.BindQueryParameter("form", false, false, "customer_groups", ctx.QueryParams(), &params.CustomerGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customer_groups: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", false, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPriceLists(ctx, params)
	return err
}

// PostPriceListsPriceList converts echo context to params.
func (w *ServerInterfaceWrapper) PostPriceListsPriceList(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostPriceListsPriceList(ctx)
	return err
}

// DeletePriceListsPriceList converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePriceListsPriceList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePriceListsPriceList(ctx, id)
	return err
}

// GetPriceListsPriceList converts echo context to params.
func (w *ServerInterfaceWrapper) GetPriceListsPriceList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPriceListsPriceList(ctx, id)
	return err
}

// PostPriceListsPriceListPriceList converts echo context to params.
func (w *ServerInterfaceWrapper) PostPriceListsPriceListPriceList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostPriceListsPriceListPriceList(ctx, id)
	return err
}

// DeletePriceListsPriceListPricesBatch converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePriceListsPriceListPricesBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePriceListsPriceListPricesBatch(ctx, id)
	return err
}

// PostPriceListsPriceListPricesBatch converts echo context to params.
func (w *ServerInterfaceWrapper) PostPriceListsPriceListPricesBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostPriceListsPriceListPricesBatch(ctx, id)
	return err
}

// GetPriceListsPriceListProducts converts echo context to params.
func (w *ServerInterfaceWrapper) GetPriceListsPriceListProducts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPriceListsPriceListProductsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "collection_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "collection_id", ctx.QueryParams(), &params.CollectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_id: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "handle" -------------

	err = runtime.BindQueryParameter("form", true, false, "handle", ctx.QueryParams(), &params.Handle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handle: %s", err))
	}

	// ------------- Optional query parameter "is_giftcard" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_giftcard", ctx.QueryParams(), &params.IsGiftcard)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_giftcard: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPriceListsPriceListProducts(ctx, id, params)
	return err
}

// DeletePriceListsPriceListProductsProductPrices converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePriceListsPriceListProductsProductPrices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "product_id" -------------
	var productId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "product_id", runtime.ParamLocationPath, ctx.Param("product_id"), &productId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePriceListsPriceListProductsProductPrices(ctx, id, productId)
	return err
}

// DeletePriceListsPriceListVariantsVariantPrices converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePriceListsPriceListVariantsVariantPrices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "variant_id" -------------
	var variantId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, ctx.Param("variant_id"), &variantId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter variant_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePriceListsPriceListVariantsVariantPrices(ctx, id, variantId)
	return err
}

// GetProductTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductTags(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductTagsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", false, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductTags(ctx, params)
	return err
}

// GetProductTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductTypesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", false, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductTypes(ctx, params)
	return err
}

// GetProducts converts echo context to params.
func (w *ServerInterfaceWrapper) GetProducts(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "collection_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "collection_id", ctx.QueryParams(), &params.CollectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_id: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "price_list_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "price_list_id", ctx.QueryParams(), &params.PriceListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter price_list_id: %s", err))
	}

	// ------------- Optional query parameter "sales_channel_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "sales_channel_id", ctx.QueryParams(), &params.SalesChannelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sales_channel_id: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "handle" -------------

	err = runtime.BindQueryParameter("form", true, false, "handle", ctx.QueryParams(), &params.Handle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handle: %s", err))
	}

	// ------------- Optional query parameter "is_giftcard" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_giftcard", ctx.QueryParams(), &params.IsGiftcard)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_giftcard: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProducts(ctx, params)
	return err
}

// PostProducts converts echo context to params.
func (w *ServerInterfaceWrapper) PostProducts(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProducts(ctx)
	return err
}

// GetProductsTagUsage converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsTagUsage(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductsTagUsage(ctx)
	return err
}

// GetProductsTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductsTypes(ctx)
	return err
}

// DeleteProductsProduct converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsProduct(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProductsProduct(ctx, id)
	return err
}

// GetProductsProduct converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProduct(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductsProduct(ctx, id)
	return err
}

// PostProductsProduct converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProduct(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProduct(ctx, id)
	return err
}

// PostProductsProductMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProductMetadata(ctx, id)
	return err
}

// PostProductsProductOptions converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProductOptions(ctx, id)
	return err
}

// DeleteProductsProductOptionsOption converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsProductOptionsOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "option_id" -------------
	var optionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "option_id", runtime.ParamLocationPath, ctx.Param("option_id"), &optionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter option_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProductsProductOptionsOption(ctx, id, optionId)
	return err
}

// PostProductsProductOptionsOption converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductOptionsOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "option_id" -------------
	var optionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "option_id", runtime.ParamLocationPath, ctx.Param("option_id"), &optionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter option_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProductOptionsOption(ctx, id, optionId)
	return err
}

// GetProductsProductVariants converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProductVariants(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsProductVariantsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProductsProductVariants(ctx, id, params)
	return err
}

// PostProductsProductVariants converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductVariants(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProductVariants(ctx, id)
	return err
}

// DeleteProductsProductVariantsVariant converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsProductVariantsVariant(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "variant_id" -------------
	var variantId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, ctx.Param("variant_id"), &variantId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter variant_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProductsProductVariantsVariant(ctx, id, variantId)
	return err
}

// PostProductsProductVariantsVariant converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductVariantsVariant(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "variant_id" -------------
	var variantId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, ctx.Param("variant_id"), &variantId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter variant_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProductsProductVariantsVariant(ctx, id, variantId)
	return err
}

// GetRegions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRegionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRegions(ctx, params)
	return err
}

// PostRegions converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegions(ctx)
	return err
}

// DeleteRegionsRegion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRegionsRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteRegionsRegion(ctx, id)
	return err
}

// GetRegionsRegion converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegionsRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRegionsRegion(ctx, id)
	return err
}

// PostRegionsRegion converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegion(ctx, id)
	return err
}

// PostRegionsRegionCountries converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionCountries(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionCountries(ctx, id)
	return err
}

// PostRegionsRegionCountriesCountry converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionCountriesCountry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "country_code" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "country_code", runtime.ParamLocationPath, ctx.Param("country_code"), &countryCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country_code: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionCountriesCountry(ctx, id, countryCode)
	return err
}

// GetRegionsRegionFulfillmentOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegionsRegionFulfillmentOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRegionsRegionFulfillmentOptions(ctx, id)
	return err
}

// PostRegionsRegionFulfillmentProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionFulfillmentProviders(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionFulfillmentProviders(ctx, id)
	return err
}

// PostRegionsRegionFulfillmentProvidersProvider converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionFulfillmentProvidersProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "provider_id" -------------
	var providerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, ctx.Param("provider_id"), &providerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionFulfillmentProvidersProvider(ctx, id, providerId)
	return err
}

// PostRegionsRegionPaymentProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionPaymentProviders(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionPaymentProviders(ctx, id)
	return err
}

// PostRegionsRegionPaymentProvidersProvider converts echo context to params.
func (w *ServerInterfaceWrapper) PostRegionsRegionPaymentProvidersProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "provider_id" -------------
	var providerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, ctx.Param("provider_id"), &providerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter provider_id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostRegionsRegionPaymentProvidersProvider(ctx, id, providerId)
	return err
}

// GetReturnReasons converts echo context to params.
func (w *ServerInterfaceWrapper) GetReturnReasons(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReturnReasons(ctx)
	return err
}

// PostReturnReasons converts echo context to params.
func (w *ServerInterfaceWrapper) PostReturnReasons(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostReturnReasons(ctx)
	return err
}

// DeleteReturnReason converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReturnReason(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteReturnReason(ctx, id)
	return err
}

// GetReturnReasonsReason converts echo context to params.
func (w *ServerInterfaceWrapper) GetReturnReasonsReason(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReturnReasonsReason(ctx, id)
	return err
}

// PostReturnReasonsReason converts echo context to params.
func (w *ServerInterfaceWrapper) PostReturnReasonsReason(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostReturnReasonsReason(ctx, id)
	return err
}

// GetReturns converts echo context to params.
func (w *ServerInterfaceWrapper) GetReturns(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReturnsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReturns(ctx, params)
	return err
}

// PostReturnsReturnCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostReturnsReturnCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostReturnsReturnCancel(ctx, id)
	return err
}

// PostReturnsReturnReceive converts echo context to params.
func (w *ServerInterfaceWrapper) PostReturnsReturnReceive(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostReturnsReturnReceive(ctx, id)
	return err
}

// GetSalesChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetSalesChannels(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSalesChannelsParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSalesChannels(ctx, params)
	return err
}

// PostSalesChannels converts echo context to params.
func (w *ServerInterfaceWrapper) PostSalesChannels(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSalesChannels(ctx)
	return err
}

// DeleteSalesChannelsSalesChannel converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSalesChannelsSalesChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteSalesChannelsSalesChannel(ctx, id)
	return err
}

// GetSalesChannelsSalesChannel converts echo context to params.
func (w *ServerInterfaceWrapper) GetSalesChannelsSalesChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSalesChannelsSalesChannel(ctx, id)
	return err
}

// PostSalesChannelsSalesChannel converts echo context to params.
func (w *ServerInterfaceWrapper) PostSalesChannelsSalesChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSalesChannelsSalesChannel(ctx, id)
	return err
}

// DeleteSalesChannelsChannelProductsBatch converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSalesChannelsChannelProductsBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteSalesChannelsChannelProductsBatch(ctx, id)
	return err
}

// PostSalesChannelsChannelProductsBatch converts echo context to params.
func (w *ServerInterfaceWrapper) PostSalesChannelsChannelProductsBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSalesChannelsChannelProductsBatch(ctx, id)
	return err
}

// GetShippingOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetShippingOptions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShippingOptionsParams
	// ------------- Optional query parameter "region_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "region_id", ctx.QueryParams(), &params.RegionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
	}

	// ------------- Optional query parameter "is_return" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_return", ctx.QueryParams(), &params.IsReturn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_return: %s", err))
	}

	// ------------- Optional query parameter "admin_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "admin_only", ctx.QueryParams(), &params.AdminOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter admin_only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShippingOptions(ctx, params)
	return err
}

// PostShippingOptions converts echo context to params.
func (w *ServerInterfaceWrapper) PostShippingOptions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostShippingOptions(ctx)
	return err
}

// DeleteShippingOptionsOption converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteShippingOptionsOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteShippingOptionsOption(ctx, id)
	return err
}

// GetShippingOptionsOption converts echo context to params.
func (w *ServerInterfaceWrapper) GetShippingOptionsOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShippingOptionsOption(ctx, id)
	return err
}

// PostShippingOptionsOption converts echo context to params.
func (w *ServerInterfaceWrapper) PostShippingOptionsOption(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostShippingOptionsOption(ctx, id)
	return err
}

// GetShippingProfiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetShippingProfiles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShippingProfiles(ctx)
	return err
}

// PostShippingProfiles converts echo context to params.
func (w *ServerInterfaceWrapper) PostShippingProfiles(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostShippingProfiles(ctx)
	return err
}

// DeleteShippingProfilesProfile converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteShippingProfilesProfile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteShippingProfilesProfile(ctx, id)
	return err
}

// GetShippingProfilesProfile converts echo context to params.
func (w *ServerInterfaceWrapper) GetShippingProfilesProfile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShippingProfilesProfile(ctx, id)
	return err
}

// PostShippingProfilesProfile converts echo context to params.
func (w *ServerInterfaceWrapper) PostShippingProfilesProfile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostShippingProfilesProfile(ctx, id)
	return err
}

// GetStore converts echo context to params.
func (w *ServerInterfaceWrapper) GetStore(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStore(ctx)
	return err
}

// PostStore converts echo context to params.
func (w *ServerInterfaceWrapper) PostStore(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStore(ctx)
	return err
}

// DeleteStoreCurrenciesCode converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStoreCurrenciesCode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteStoreCurrenciesCode(ctx, code)
	return err
}

// PostStoreCurrenciesCode converts echo context to params.
func (w *ServerInterfaceWrapper) PostStoreCurrenciesCode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, ctx.Param("code"), &code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStoreCurrenciesCode(ctx, code)
	return err
}

// GetStorePaymentProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetStorePaymentProviders(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStorePaymentProviders(ctx)
	return err
}

// GetStoreTaxProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetStoreTaxProviders(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStoreTaxProviders(ctx)
	return err
}

// GetSwaps converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwaps(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwaps(ctx, params)
	return err
}

// GetSwapsSwap converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapsSwap(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapsSwap(ctx, id)
	return err
}

// GetTaxRates converts echo context to params.
func (w *ServerInterfaceWrapper) GetTaxRates(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTaxRatesParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "region_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "region_id", ctx.QueryParams(), &params.RegionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_id: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "rate" -------------

	err = runtime.BindQueryParameter("form", false, false, "rate", ctx.QueryParams(), &params.Rate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rate: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTaxRates(ctx, params)
	return err
}

// PostTaxRates converts echo context to params.
func (w *ServerInterfaceWrapper) PostTaxRates(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTaxRatesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTaxRates(ctx, params)
	return err
}

// DeleteTaxRatesTaxRate converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTaxRatesTaxRate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteTaxRatesTaxRate(ctx, id)
	return err
}

// GetTaxRatesTaxRate converts echo context to params.
func (w *ServerInterfaceWrapper) GetTaxRatesTaxRate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTaxRatesTaxRateParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTaxRatesTaxRate(ctx, id, params)
	return err
}

// PostTaxRatesTaxRate converts echo context to params.
func (w *ServerInterfaceWrapper) PostTaxRatesTaxRate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTaxRatesTaxRateParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTaxRatesTaxRate(ctx, id, params)
	return err
}

// DeleteTaxRatesTaxRateProductTypes converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTaxRatesTaxRateProductTypes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTaxRatesTaxRateProductTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteTaxRatesTaxRateProductTypes(ctx, id, params)
	return err
}

// PostTaxRatesTaxRateProductTypes converts echo context to params.
func (w *ServerInterfaceWrapper) PostTaxRatesTaxRateProductTypes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTaxRatesTaxRateProductTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTaxRatesTaxRateProductTypes(ctx, id, params)
	return err
}

// DeleteTaxRatesTaxRateProducts converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTaxRatesTaxRateProducts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTaxRatesTaxRateProductsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteTaxRatesTaxRateProducts(ctx, id, params)
	return err
}

// PostTaxRatesTaxRateProducts converts echo context to params.
func (w *ServerInterfaceWrapper) PostTaxRatesTaxRateProducts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTaxRatesTaxRateProductsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTaxRatesTaxRateProducts(ctx, id, params)
	return err
}

// DeleteTaxRatesTaxRateShippingOptions converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTaxRatesTaxRateShippingOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTaxRatesTaxRateShippingOptionsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteTaxRatesTaxRateShippingOptions(ctx, id, params)
	return err
}

// PostTaxRatesTaxRateShippingOptions converts echo context to params.
func (w *ServerInterfaceWrapper) PostTaxRatesTaxRateShippingOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostTaxRatesTaxRateShippingOptionsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTaxRatesTaxRateShippingOptions(ctx, id, params)
	return err
}

// PostUploads converts echo context to params.
func (w *ServerInterfaceWrapper) PostUploads(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUploads(ctx)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// PostUsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsers(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsers(ctx)
	return err
}

// PostUsersUserPasswordToken converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersUserPasswordToken(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersUserPasswordToken(ctx)
	return err
}

// PostUsersUserPassword converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersUserPassword(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersUserPassword(ctx)
	return err
}

// DeleteUsersUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUsersUser(ctx, id)
	return err
}

// GetUsersUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersUser(ctx, id)
	return err
}

// PostUsersUser converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersUser(ctx, id)
	return err
}

// GetVariants converts echo context to params.
func (w *ServerInterfaceWrapper) GetVariants(ctx echo.Context) error {
	var err error

	ctx.Set(Api_tokenScopes, []string{""})

	ctx.Set(Cookie_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVariantsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVariants(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/admin/draft-orders/:id", wrapper.PostDraftOrdersDraftOrder)
	router.GET(baseURL+"/apps", wrapper.GetApps)
	router.POST(baseURL+"/apps/authorizations", wrapper.PostApps)
	router.DELETE(baseURL+"/auth", wrapper.DeleteAuth)
	router.GET(baseURL+"/auth", wrapper.GetAuth)
	router.POST(baseURL+"/auth", wrapper.PostAuth)
	router.GET(baseURL+"/batch-jobs", wrapper.GetBatchJobs)
	router.POST(baseURL+"/batch-jobs", wrapper.PostBatchJobs)
	router.GET(baseURL+"/batch-jobs/:id", wrapper.GetBatchJobsBatchJob)
	router.POST(baseURL+"/batch-jobs/:id/cancel", wrapper.PostBatchJobsBatchJobCancel)
	router.POST(baseURL+"/batch-jobs/:id/confirm", wrapper.PostBatchJobsBatchJobConfirmProcessing)
	router.GET(baseURL+"/collections", wrapper.GetCollections)
	router.POST(baseURL+"/collections", wrapper.PostCollections)
	router.DELETE(baseURL+"/collections/:id", wrapper.DeleteCollectionsCollection)
	router.GET(baseURL+"/collections/:id", wrapper.GetCollectionsCollection)
	router.POST(baseURL+"/collections/:id", wrapper.PostCollectionsCollection)
	router.DELETE(baseURL+"/collections/:id/products/batch", wrapper.DeleteProductsFromCollection)
	router.POST(baseURL+"/collections/:id/products/batch", wrapper.PostProductsToCollection)
	router.GET(baseURL+"/currencies", wrapper.GetCurrencies)
	router.POST(baseURL+"/currencies/:code", wrapper.PostCurrenciesCurrency)
	router.GET(baseURL+"/customer-groups", wrapper.GetCustomerGroups)
	router.POST(baseURL+"/customer-groups", wrapper.PostCustomerGroups)
	router.DELETE(baseURL+"/customer-groups/:id", wrapper.DeleteCustomerGroupsCustomerGroup)
	router.GET(baseURL+"/customer-groups/:id", wrapper.GetCustomerGroupsGroup)
	router.POST(baseURL+"/customer-groups/:id", wrapper.PostCustomerGroupsGroup)
	router.GET(baseURL+"/customer-groups/:id/customers", wrapper.GetCustomerGroupsGroupCustomers)
	router.DELETE(baseURL+"/customer-groups/:id/customers/batch", wrapper.DeleteCustomerGroupsGroupCustomerBatch)
	router.POST(baseURL+"/customer-groups/:id/customers/batch", wrapper.PostCustomerGroupsGroupCustomersBatch)
	router.GET(baseURL+"/customers", wrapper.GetCustomers)
	router.POST(baseURL+"/customers", wrapper.PostCustomers)
	router.GET(baseURL+"/customers/:id", wrapper.GetCustomersCustomer)
	router.POST(baseURL+"/customers/:id", wrapper.PostCustomersCustomer)
	router.GET(baseURL+"/discounts", wrapper.GetDiscounts)
	router.POST(baseURL+"/discounts", wrapper.PostDiscounts)
	router.GET(baseURL+"/discounts/code/:code", wrapper.GetDiscountsDiscountCode)
	router.POST(baseURL+"/discounts/:discount_id/conditions", wrapper.PostDiscountsDiscountConditions)
	router.DELETE(baseURL+"/discounts/:discount_id/conditions/:condition_id", wrapper.DeleteDiscountsDiscountConditionsCondition)
	router.GET(baseURL+"/discounts/:discount_id/conditions/:condition_id", wrapper.GetDiscountsDiscountConditionsCondition)
	router.POST(baseURL+"/discounts/:discount_id/conditions/:condition_id", wrapper.PostDiscountsDiscountConditionsCondition)
	router.DELETE(baseURL+"/discounts/:id", wrapper.DeleteDiscountsDiscount)
	router.GET(baseURL+"/discounts/:id", wrapper.GetDiscountsDiscount)
	router.POST(baseURL+"/discounts/:id", wrapper.PostDiscountsDiscount)
	router.POST(baseURL+"/discounts/:id/dynamic-codes", wrapper.PostDiscountsDiscountDynamicCodes)
	router.DELETE(baseURL+"/discounts/:id/dynamic-codes/:code", wrapper.DeleteDiscountsDiscountDynamicCodesCode)
	router.DELETE(baseURL+"/discounts/:id/regions/:region_id", wrapper.DeleteDiscountsDiscountRegionsRegion)
	router.POST(baseURL+"/discounts/:id/regions/:region_id", wrapper.PostDiscountsDiscountRegionsRegion)
	router.GET(baseURL+"/draft-orders", wrapper.GetDraftOrders)
	router.POST(baseURL+"/draft-orders", wrapper.PostDraftOrders)
	router.DELETE(baseURL+"/draft-orders/:id", wrapper.DeleteDraftOrdersDraftOrder)
	router.GET(baseURL+"/draft-orders/:id", wrapper.GetDraftOrdersDraftOrder)
	router.POST(baseURL+"/draft-orders/:id/line-items", wrapper.PostDraftOrdersDraftOrderLineItems)
	router.DELETE(baseURL+"/draft-orders/:id/line-items/:line_id", wrapper.DeleteDraftOrdersDraftOrderLineItemsItem)
	router.POST(baseURL+"/draft-orders/:id/line-items/:line_id", wrapper.PostDraftOrdersDraftOrderLineItemsItem)
	router.POST(baseURL+"/draft-orders/:id/pay", wrapper.PostDraftOrdersDraftOrderRegisterPayment)
	router.GET(baseURL+"/gift-cards", wrapper.GetGiftCards)
	router.POST(baseURL+"/gift-cards", wrapper.PostGiftCards)
	router.DELETE(baseURL+"/gift-cards/:id", wrapper.DeleteGiftCardsGiftCard)
	router.GET(baseURL+"/gift-cards/:id", wrapper.GetGiftCardsGiftCard)
	router.POST(baseURL+"/gift-cards/:id", wrapper.PostGiftCardsGiftCard)
	router.GET(baseURL+"/invites", wrapper.GetInvites)
	router.POST(baseURL+"/invites", wrapper.PostInvites)
	router.POST(baseURL+"/invites/accept", wrapper.PostInvitesInviteAccept)
	router.DELETE(baseURL+"/invites/:invite_id", wrapper.DeleteInvitesInvite)
	router.POST(baseURL+"/invites/:invite_id/resend", wrapper.PostInvitesInviteResend)
	router.GET(baseURL+"/notes", wrapper.GetNotes)
	router.POST(baseURL+"/notes", wrapper.PostNotes)
	router.DELETE(baseURL+"/notes/:id", wrapper.DeleteNotesNote)
	router.GET(baseURL+"/notes/:id", wrapper.GetNotesNote)
	router.POST(baseURL+"/notes/:id", wrapper.PostNotesNote)
	router.GET(baseURL+"/notifications", wrapper.GetNotifications)
	router.POST(baseURL+"/notifications/:id/resend", wrapper.PostNotificationsNotificationResend)
	router.POST(baseURL+"/order/:id/claims", wrapper.PostOrdersOrderClaims)
	router.POST(baseURL+"/order/:id/claims/:claim_id", wrapper.PostOrdersOrderClaimsClaim)
	router.POST(baseURL+"/order/:id/swaps", wrapper.PostOrdersOrderSwaps)
	router.GET(baseURL+"/orders", wrapper.GetOrders)
	router.GET(baseURL+"/orders/:id", wrapper.GetOrdersOrder)
	router.POST(baseURL+"/orders/:id", wrapper.PostOrdersOrder)
	router.POST(baseURL+"/orders/:id/archive", wrapper.PostOrdersOrderArchive)
	router.POST(baseURL+"/orders/:id/cancel", wrapper.PostOrdersOrderCancel)
	router.POST(baseURL+"/orders/:id/capture", wrapper.PostOrdersOrderCapture)
	router.POST(baseURL+"/orders/:id/claims/:claim_id/cancel", wrapper.PostOrdersClaimCancel)
	router.POST(baseURL+"/orders/:id/claims/:claim_id/fulfillments", wrapper.PostOrdersOrderClaimsClaimFulfillments)
	router.POST(baseURL+"/orders/:id/claims/:claim_id/fulfillments/:fulfillment_id/cancel", wrapper.PostOrdersClaimFulfillmentsCancel)
	router.POST(baseURL+"/orders/:id/claims/:claim_id/shipments", wrapper.PostOrdersOrderClaimsClaimShipments)
	router.POST(baseURL+"/orders/:id/complete", wrapper.PostOrdersOrderComplete)
	router.POST(baseURL+"/orders/:id/fulfillment", wrapper.PostOrdersOrderFulfillments)
	router.POST(baseURL+"/orders/:id/fulfillments/:fulfillment_id/cancel", wrapper.PostOrdersOrderFulfillmentsCancel)
	router.POST(baseURL+"/orders/:id/refund", wrapper.PostOrdersOrderRefunds)
	router.POST(baseURL+"/orders/:id/return", wrapper.PostOrdersOrderReturns)
	router.POST(baseURL+"/orders/:id/shipment", wrapper.PostOrdersOrderShipment)
	router.POST(baseURL+"/orders/:id/shipping-methods", wrapper.PostOrdersOrderShippingMethods)
	router.POST(baseURL+"/orders/:id/swaps/:swap_id/cancel", wrapper.PostOrdersSwapCancel)
	router.POST(baseURL+"/orders/:id/swaps/:swap_id/fulfillments", wrapper.PostOrdersOrderSwapsSwapFulfillments)
	router.POST(baseURL+"/orders/:id/swaps/:swap_id/fulfillments/:fulfillment_id/cancel", wrapper.PostOrdersSwapFulfillmentsCancel)
	router.POST(baseURL+"/orders/:id/swaps/:swap_id/process-payment", wrapper.PostOrdersOrderSwapsSwapProcessPayment)
	router.POST(baseURL+"/orders/:id/swaps/:swap_id/shipments", wrapper.PostOrdersOrderSwapsSwapShipments)
	router.GET(baseURL+"/price-lists", wrapper.GetPriceLists)
	router.POST(baseURL+"/price-lists", wrapper.PostPriceListsPriceList)
	router.DELETE(baseURL+"/price-lists/:id", wrapper.DeletePriceListsPriceList)
	router.GET(baseURL+"/price-lists/:id", wrapper.GetPriceListsPriceList)
	router.POST(baseURL+"/price-lists/:id", wrapper.PostPriceListsPriceListPriceList)
	router.DELETE(baseURL+"/price-lists/:id/prices/batch", wrapper.DeletePriceListsPriceListPricesBatch)
	router.POST(baseURL+"/price-lists/:id/prices/batch", wrapper.PostPriceListsPriceListPricesBatch)
	router.GET(baseURL+"/price-lists/:id/products", wrapper.GetPriceListsPriceListProducts)
	router.DELETE(baseURL+"/price-lists/:id/products/:product_id/prices", wrapper.DeletePriceListsPriceListProductsProductPrices)
	router.DELETE(baseURL+"/price-lists/:id/variants/:variant_id/prices", wrapper.DeletePriceListsPriceListVariantsVariantPrices)
	router.GET(baseURL+"/product-tags", wrapper.GetProductTags)
	router.GET(baseURL+"/product-types", wrapper.GetProductTypes)
	router.GET(baseURL+"/products", wrapper.GetProducts)
	router.POST(baseURL+"/products", wrapper.PostProducts)
	router.GET(baseURL+"/products/tag-usage", wrapper.GetProductsTagUsage)
	router.GET(baseURL+"/products/types", wrapper.GetProductsTypes)
	router.DELETE(baseURL+"/products/:id", wrapper.DeleteProductsProduct)
	router.GET(baseURL+"/products/:id", wrapper.GetProductsProduct)
	router.POST(baseURL+"/products/:id", wrapper.PostProductsProduct)
	router.POST(baseURL+"/products/:id/metadata", wrapper.PostProductsProductMetadata)
	router.POST(baseURL+"/products/:id/options", wrapper.PostProductsProductOptions)
	router.DELETE(baseURL+"/products/:id/options/:option_id", wrapper.DeleteProductsProductOptionsOption)
	router.POST(baseURL+"/products/:id/options/:option_id", wrapper.PostProductsProductOptionsOption)
	router.GET(baseURL+"/products/:id/variants", wrapper.GetProductsProductVariants)
	router.POST(baseURL+"/products/:id/variants", wrapper.PostProductsProductVariants)
	router.DELETE(baseURL+"/products/:id/variants/:variant_id", wrapper.DeleteProductsProductVariantsVariant)
	router.POST(baseURL+"/products/:id/variants/:variant_id", wrapper.PostProductsProductVariantsVariant)
	router.GET(baseURL+"/regions", wrapper.GetRegions)
	router.POST(baseURL+"/regions", wrapper.PostRegions)
	router.DELETE(baseURL+"/regions/:id", wrapper.DeleteRegionsRegion)
	router.GET(baseURL+"/regions/:id", wrapper.GetRegionsRegion)
	router.POST(baseURL+"/regions/:id", wrapper.PostRegionsRegion)
	router.POST(baseURL+"/regions/:id/countries", wrapper.PostRegionsRegionCountries)
	router.DELETE(baseURL+"/regions/:id/countries/:country_code", wrapper.PostRegionsRegionCountriesCountry)
	router.GET(baseURL+"/regions/:id/fulfillment-options", wrapper.GetRegionsRegionFulfillmentOptions)
	router.POST(baseURL+"/regions/:id/fulfillment-providers", wrapper.PostRegionsRegionFulfillmentProviders)
	router.DELETE(baseURL+"/regions/:id/fulfillment-providers/:provider_id", wrapper.PostRegionsRegionFulfillmentProvidersProvider)
	router.POST(baseURL+"/regions/:id/payment-providers", wrapper.PostRegionsRegionPaymentProviders)
	router.DELETE(baseURL+"/regions/:id/payment-providers/:provider_id", wrapper.PostRegionsRegionPaymentProvidersProvider)
	router.GET(baseURL+"/return-reasons", wrapper.GetReturnReasons)
	router.POST(baseURL+"/return-reasons", wrapper.PostReturnReasons)
	router.DELETE(baseURL+"/return-reasons/:id", wrapper.DeleteReturnReason)
	router.GET(baseURL+"/return-reasons/:id", wrapper.GetReturnReasonsReason)
	router.POST(baseURL+"/return-reasons/:id", wrapper.PostReturnReasonsReason)
	router.GET(baseURL+"/returns", wrapper.GetReturns)
	router.POST(baseURL+"/returns/:id/cancel", wrapper.PostReturnsReturnCancel)
	router.POST(baseURL+"/returns/:id/receive", wrapper.PostReturnsReturnReceive)
	router.GET(baseURL+"/sales-channels", wrapper.GetSalesChannels)
	router.POST(baseURL+"/sales-channels", wrapper.PostSalesChannels)
	router.DELETE(baseURL+"/sales-channels/:id", wrapper.DeleteSalesChannelsSalesChannel)
	router.GET(baseURL+"/sales-channels/:id", wrapper.GetSalesChannelsSalesChannel)
	router.POST(baseURL+"/sales-channels/:id", wrapper.PostSalesChannelsSalesChannel)
	router.DELETE(baseURL+"/sales-channels/:id/products/batch", wrapper.DeleteSalesChannelsChannelProductsBatch)
	router.POST(baseURL+"/sales-channels/:id/products/batch", wrapper.PostSalesChannelsChannelProductsBatch)
	router.GET(baseURL+"/shipping-options", wrapper.GetShippingOptions)
	router.POST(baseURL+"/shipping-options", wrapper.PostShippingOptions)
	router.DELETE(baseURL+"/shipping-options/:id", wrapper.DeleteShippingOptionsOption)
	router.GET(baseURL+"/shipping-options/:id", wrapper.GetShippingOptionsOption)
	router.POST(baseURL+"/shipping-options/:id", wrapper.PostShippingOptionsOption)
	router.GET(baseURL+"/shipping-profiles", wrapper.GetShippingProfiles)
	router.POST(baseURL+"/shipping-profiles", wrapper.PostShippingProfiles)
	router.DELETE(baseURL+"/shipping-profiles/:id", wrapper.DeleteShippingProfilesProfile)
	router.GET(baseURL+"/shipping-profiles/:id", wrapper.GetShippingProfilesProfile)
	router.POST(baseURL+"/shipping-profiles/:id", wrapper.PostShippingProfilesProfile)
	router.GET(baseURL+"/store", wrapper.GetStore)
	router.POST(baseURL+"/store", wrapper.PostStore)
	router.DELETE(baseURL+"/store/currencies/:code", wrapper.DeleteStoreCurrenciesCode)
	router.POST(baseURL+"/store/currencies/:code", wrapper.PostStoreCurrenciesCode)
	router.GET(baseURL+"/store/payment-providers", wrapper.GetStorePaymentProviders)
	router.GET(baseURL+"/store/tax-providers", wrapper.GetStoreTaxProviders)
	router.GET(baseURL+"/swaps", wrapper.GetSwaps)
	router.GET(baseURL+"/swaps/:id", wrapper.GetSwapsSwap)
	router.GET(baseURL+"/tax-rates", wrapper.GetTaxRates)
	router.POST(baseURL+"/tax-rates", wrapper.PostTaxRates)
	router.DELETE(baseURL+"/tax-rates/:id", wrapper.DeleteTaxRatesTaxRate)
	router.GET(baseURL+"/tax-rates/:id", wrapper.GetTaxRatesTaxRate)
	router.POST(baseURL+"/tax-rates/:id", wrapper.PostTaxRatesTaxRate)
	router.DELETE(baseURL+"/tax-rates/:id/product-types/batch", wrapper.DeleteTaxRatesTaxRateProductTypes)
	router.POST(baseURL+"/tax-rates/:id/product-types/batch", wrapper.PostTaxRatesTaxRateProductTypes)
	router.DELETE(baseURL+"/tax-rates/:id/products/batch", wrapper.DeleteTaxRatesTaxRateProducts)
	router.POST(baseURL+"/tax-rates/:id/products/batch", wrapper.PostTaxRatesTaxRateProducts)
	router.DELETE(baseURL+"/tax-rates/:id/shipping-options/batch", wrapper.DeleteTaxRatesTaxRateShippingOptions)
	router.POST(baseURL+"/tax-rates/:id/shipping-options/batch", wrapper.PostTaxRatesTaxRateShippingOptions)
	router.POST(baseURL+"/uploads", wrapper.PostUploads)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.POST(baseURL+"/users", wrapper.PostUsers)
	router.POST(baseURL+"/users/password-token", wrapper.PostUsersUserPasswordToken)
	router.POST(baseURL+"/users/reset-password", wrapper.PostUsersUserPassword)
	router.DELETE(baseURL+"/users/:id", wrapper.DeleteUsersUser)
	router.GET(baseURL+"/users/:id", wrapper.GetUsersUser)
	router.POST(baseURL+"/users/:id", wrapper.PostUsersUser)
	router.GET(baseURL+"/variants", wrapper.GetVariants)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nX3+9v8HAAD//wgd94qS+wcA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
